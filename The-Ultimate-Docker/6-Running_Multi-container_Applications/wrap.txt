*** 1- Introduction ***

- Welcome back to another section of the ultimate Docker course. In this section, we're going to
talk about running multi-container applications. 

- So we're going to give we a real world application
with three building blocks, a front end built with React, a back end built with Node, and a
MongoDB database. Once again, we don't need to be familiar or use any of these tools. Our focus
here is on Docker and not on development tools.

- the most exciting part of this
course where we can see everything coming together. We'll talk about Docker compose for
building and running multi-container applications. We'll also talk about Docker networking, database
migration, and running automated tests. 
-------------------code----------------------
• Docker Compose
• Docker networking
• Database migration
• Running automated tests
-------------------code----------------------

*** 2- Installing Docker Compose ***

- In this section we're going to use a tool called
docker compose which is built on top of docker engine. It makes it incredibly easy
to start applications with multiple containers. 

- So google docker compose install, On this page we can see the installation instructions.
-------------------code----------------------
docs.docker.com/compose/install/
-------------------code----------------------

- Now at the time of recording this, docker compose is shipped with
docker desktop for mac and windows. So if we're on mac or
windows, we don't have to do anything extra. we already have docker compose.
To verify it, just go to the terminal window and type docker compose version.
-------------------code----------------------
$ docker compose version
Docker Compose version v2.33.1-desktop.1
-------------------code----------------------

- So we're running docker compose version 2.33.1. Make sure
the version is the same or newer. 

- Now if we're using an older version, again google upgrade docker compose. Or we might just install
the latest version of docker. 

- Now, back to the installation page.
If we're using windows server or linux, there are specific instructions
we have to follow to install docker compose. 


*** 3- Cleaning Up our Workspace ***

- Before we get started, we want to show we a couple of techniques for cleaning up our workspace.
So on this machine we have a bunch of images and
some running containers. They're getting in the way. we want to get rid of them all.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    d63e19272668   22 hours ago   482MB
<none>       <none>    ce326f24856a   23 hours ago   482MB
<none>       <none>    0211703e719b   47 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- How do we do this? Well, we know that we can remove images using
docker image remove command. And here we can type one or more
image IDs.
-------------------code----------------------
docker image rm 123 123
-------------------code----------------------

- Now how can we get all image IDs and pass them here?
as a cool trick. So we can run docker image ls we see all the images.
-------------------code----------------------
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    d63e19272668   22 hours ago   482MB
<none>       <none>    ce326f24856a   23 hours ago   482MB
<none>       <none>    0211703e719b   47 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- But if we pass dash q at the end, we only get image IDs. 

- Now we can pass this as an argument to docker image remove. So,
docker image remove. Now here we add a dollar sign,
and in parenthesis, we type that other command. So docker
image ls dash q. 
-------------------code----------------------
$ docker image ls -q
d63e19272668
ce326f24856a
0211703e719b
8d591b0b7dea
c3d1a3432580
-------------------code----------------------

- Now if we run this we're going to get an error
because some of these images are already in running containers, or
stopped containers. So we should always
remove containers first.
-------------------code----------------------
$ docker image rm $(docker image ls -q)
Deleted: sha256:ce326f24856a64a01179135c2b35fd7bd17e2efd71e61ecec7bb30c74364b9be
Untagged: alpine:latest
Untagged: alpine@sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c
Deleted: sha256:8d591b0b7dea080ea3be9e12ae563eebf9869168ffced1cb25b2470a3d9fe15e
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:72297848456d5d37d1262630108ab308d3e9ec7ed1c3286a32fe09856619a782
Deleted: sha256:c3d1a34325805c22bf44a5157224bcff58dc6a8868558c7746d6a2ea64eb191c
Deleted: sha256:375990b2a90a8d8f332d9b9422d948f7068a3313bf5a1c9fbb91ff2d29046130
Error response from daemon: conflict: unable to delete d63e19272668 (must be forced) - image is being used by stopped container e1c9962056ab
Error response from daemon: conflict: unable to delete 0211703e719b (must be forced) - image is being used by stopped container 912a9f10ea96
-------------------code----------------------

- We're going to do that using the same technique. So we're going to replace
image with container, so we get all container IDs, and then
we're going to remove them all in one go. Also,
we would like to add dash a here as well,
this will bring stopped containers as well. Okay? We can also combine
switches, that's another technique. Let's go ahead. Alright, we get an error saying
we cannot remove a running container, because we forgot to pass the
force option.
-------------------code----------------------
$ docker container rm $(docker container ls -aq)
Error response from daemon: You cannot remove a running container
-------------------code----------------------

- So, let's bring this up one more time. When removing, we're going to use dash f.
So all these containers are removed.
-------------------code----------------------
$ docker container rm -f $(docker container ls -aq)
4c042c40552d
bcdb2cf69efd
e1c9962056ab
1f0feff2e673
300b6cd7fa2d
912a9f10ea96
-------------------code----------------------

- Now let's remove the images. So, docker image ls, and docker image remove.
-------------------code----------------------
$ docker image rm $(docker image ls -q)
Untagged: react-app:latest
Deleted: sha256:d63e19272668b1d5fe42f33e1bef69b77f1ee11d565f5d324cf4ce4b33c2468e
Deleted: sha256:0211703e719b294529c6ff5579540f917db0778d832ae1cc85925770778759d2
-------------------code----------------------

- Now, take a look. We don't have any images.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
-------------------code----------------------

- and no containers, including stopped containers.
So we have a clean workspace.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- That's one way. There is a shortcut for this as well. If we're on Mac, we can find the docker icon
on the top status bar. If we're on Windows, we will find it in our notification tray.
Let's click on this, and then go to preferences.

- Now, on this page, let's click on the troubleshoot icon. On this page, we have a bunch of useful
utilities. For example, we can restart docker desktop.
We can also clean and purge data. This will essentially remove everything
in docker. our images, our containers, our volumes, and so on.

- Now, be aware that if we click on this, this is going to restart docker engine.
So on the top, look, we can see this animation showing that the docker engine is not started yet.
So at this point, if we go to the terminal window and execute any of docker commands,
we're going to get an error. So we'll have to wait about half a minute
for the docker engine to start. That's another way. 


*** 4- The Sample Web Application ***

So in this section we're going to look at a real world application with multiple building blocks. A frontend, a backend
and a database. We have this backend folder which is our node project.
This is a basic node project that starts a web server on port 3001. Once again, we don't need to know node
to go through this section. Then we have the frontend project which is a react application that talks to the backend.

- Now, if we want to run this application outside
of docker, there are a number of steps we have to follow. Let's say
we just check this out from a github repository. First we have to go to our backend project,
install all dependencies, and then start the web server. Now at the same time, we have to open up
another terminal window and do the same steps with our frontend project. So we have to go
to the frontend project, install all the dependencies, and then start the web server.
And of course, we need two more terminal windows for running our frontend and backend tests.
And not to mention that, we should also download and install MongoDB on this machine. So there are so
many steps we have to follow the moment we check out the source code from our github repository. 
-------------------code----------------------
cd backend
npm i
cd ../frontend
npm i
-------------------code----------------------

- Now with docker, we don't have to do any of these things. All we have to do
is run a single command.
So, Now we are in the root of this project. If we look, here we have a file called docker compose
which is used for composing a multi-container application.
We're going to talk about that in detail soon.
-------------------code----------------------
$ ls
backend			docker-compose.yml	frontend
-------------------code----------------------

- Now, once we have this file in our project,
we can simply run docker compose up. That's all we have to do.
Now, docker is automatically downloading this particular version of MongoDB. So it's downloading
all these layers. Then at the same time, it's going to install all the dependencies for our frontend
and backend project. It will start web servers and run automated tests all in this window.
-------------------code----------------------
$ docker compose up
WARN[0000] 6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 13/13
 ✔ db Pulled                                                                                                                                      13.2s
   ✔ 828b35a09f0b Pull complete                                                                                                                    3.3s
   ✔ 66927c6d1d3d Pull complete                                                                                                                    3.4s
   ✔ 000560be9165 Pull complete                                                                                                                    3.4s
   ✔ 6225a0253717 Pull complete                                                                                                                    3.4s
   ✔ 20462772c88a Pull complete                                                                                                                    3.4s
   ✔ 8892f6e8bb20 Pull complete                                                                                                                    3.5s
   ✔ ba880f936bf8 Pull complete                                                                                                                    3.5s
   ✔ 62a85e868ee1 Pull complete                                                                                                                    3.5s
   ✔ 5c2a89ead641 Pull complete                                                                                                                    3.5s
   ✔ 5970f465dd7d Pull complete                                                                                                                    3.5s
   ✔ ec025da43478 Pull complete                                                                                                                    6.5s
   ✔ 91ff9a6f40b5 Pull complete                                                                                                                    6.5s
Compose now can delegate build to bake for better performances
Just set COMPOSE_BAKE=true
[+] Building 24.0s (20/20) FINISHED                                                                                                docker:desktop-linux
 => [backend internal] load build definition from Dockerfile                                                                                       0.0s
 => => transferring dockerfile: 266B                                                                                                               0.0s
 => [frontend internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                2.4s
 => [backend internal] load .dockerignore                                                                                                          0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [frontend 1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b          0.0s
 => [backend internal] load build context                                                                                                          0.0s
 => => transferring context: 277.43kB                                                                                                              0.0s
 => CACHED [frontend 2/6] RUN addgroup app && adduser -S -G app app                                                                                0.0s
 => CACHED [frontend 3/6] WORKDIR /app                                                                                                             0.0s
 => [backend 4/6] COPY package*.json ./                                                                                                            0.1s
 => [backend 5/6] RUN npm install                                                                                                                  6.1s
 => [backend 6/6] COPY . .                                                                                                                         0.0s
 => [backend] exporting to image                                                                                                                   0.7s
 => => exporting layers                                                                                                                            0.6s
 => => writing image sha256:bf304fa22d9a611c49cbbf9c2ce76ab47ca7ee08fd6fb4298632a72093e9cfdf                                                       0.0s
 => => naming to docker.io/library/vidly-backend                                                                                                   0.0s
 => [backend] resolving provenance for metadata file                                                                                               0.0s
 => [frontend internal] load build definition from Dockerfile                                                                                      0.0s
 => => transferring dockerfile: 265B                                                                                                               0.0s
 => [frontend internal] load .dockerignore                                                                                                         0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [frontend internal] load build context                                                                                                         0.0s
 => => transferring context: 673.53kB                                                                                                              0.0s
 => [frontend 4/6] COPY package*.json ./                                                                                                           0.0s
 => [frontend 5/6] RUN npm install                                                                                                                13.0s
 => [frontend 6/6] COPY . .                                                                                                                        0.0s
 => [frontend] exporting to image                                                                                                                  1.5s
 => => exporting layers                                                                                                                            1.5s
 => => writing image sha256:8352bb4950d270f2a86b71c5a5298a2fd753457a567fb7976c97a1664eccda0a                                                       0.0s
 => => naming to docker.io/library/vidly-frontend                                                                                                  0.0s
 => [frontend] resolving provenance for metadata file                                                                                              0.0s
[+] Running 7/7
 ✔ backend                     Built                                                                                                               0.0s
 ✔ frontend                    Built                                                                                                               0.0s
 ✔ Network vidly_default       Created                                                                                                             0.0s
 ✔ Volume "vidly_vidly"        Created                                                                                                             0.0s
 ✔ Container vidly-db-1        Created                                                                                                             0.0s
 ✔ Container vidly-backend-1   Created                                                                                                             0.0s
 ✔ Container vidly-frontend-1  Created                                                                                                             0.0s
Attaching to backend-1, db-1, frontend-1
db-1        | 2025-03-22T05:33:38.415+0000  CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=0e8272cc3a01
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] db version v4.0.28
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] git version: af1a9dc12adcfa83cc19571cb3faba26eeddac92
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2g  1 Mar 2016
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] allocator: tcmalloc
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] modules: none
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] build environment:
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     distmod: ubuntu1604
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     distarch: aarch64
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     target_arch: aarch64
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] options: { net: { bindIpAll: true } }
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten]
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=474M,cache_overflow=(file_max=0M),session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),
db-1        | 2025-03-22T05:33:38.426+0000  STORAGE  [initandlisten] WiredTiger message [1742621618:426854][1:0xffffaefcd000], txn-recover: Set global recovery timestamp: 0
db-1        | 2025-03-22T05:33:38.430+0000  RECOVERY [initandlisten] WiredTiger recoveryTimestamp. Ts: Timestamp(0, 0)
db-1        | 2025-03-22T05:33:38.435+0000  STORAGE  [initandlisten] Starting to check the table logging settings for existing WiredTiger tables
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] **        We suggest setting it to 'never'
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  STORAGE  [initandlisten] createCollection: admin.system.version with provided UUID: 70df6218-248d-4e23-9a1a-6421c6199541
db-1        | 2025-03-22T05:33:38.443+0000  COMMAND  [initandlisten] setting featureCompatibilityVersion to 4.0
db-1        | 2025-03-22T05:33:38.443+0000  STORAGE  [initandlisten] Finished adjusting the table logging settings for existing WiredTiger tables
db-1        | 2025-03-22T05:33:38.443+0000  STORAGE  [initandlisten] createCollection: local.startup_log with generated UUID: 3d84ad6f-d067-4853-b803-bf8d54b2a3d8
backend-1   | /usr/local/bin/docker-entrypoint.sh: exec: line 8: ./docker-entrypoint.sh: Permission denied
db-1        | 2025-03-22T05:33:38.448+0000  FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory '/data/db/diagnostic.data'
db-1        | 2025-03-22T05:33:38.451+0000  STORAGE  [LogicalSessionCacheRefresh] createCollection: config.system.sessions with generated UUID: 789443b1-56c1-45b7-a38d-0bdc942c1848
db-1        | 2025-03-22T05:33:38.451+0000  NETWORK  [initandlisten] waiting for connections on port 27017
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] build index on: config.system.sessions properties: { v: 2, key: { lastUse: 1 }, name: "lsidTTLIndex", ns: "config.system.sessions", expireAfterSeconds: 1800 }
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] 	 building index using bulk method; build may temporarily use up to 500 megabytes of RAM
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] build index done.  scanned 0 total records. 0 secs
backend-1 exited with code 126
frontend-1  |
frontend-1  | > vidly-frontend@0.1.0 start /app
frontend-1  | > react-scripts start
frontend-1  |
frontend-1  | ℹ ｢wds｣: Project is running at http://172.18.0.4/
frontend-1  | ℹ ｢wds｣: webpack output is served from
frontend-1  | ℹ ｢wds｣: Content not from webpack is served from /app/public
frontend-1  | ℹ ｢wds｣: 404s will fallback to /
frontend-1  | Starting the development server...
frontend-1  |
frontend-1  | Browserslist: caniuse-lite is outdated. Please run:
frontend-1  | npx browserslist@latest --update-db
frontend-1  |
frontend-1  | Why should do it regularly:
frontend-1  | https://github.com/browserslist/browserslist#browsers-data-updating
frontend-1  | Compiled successfully!
frontend-1  |
frontend-1  | You can now view vidly-frontend in the browser.
frontend-1  |
frontend-1  |   Local:            http://localhost:3000
frontend-1  |   On Your Network:  http://172.18.0.4:3000
frontend-1  |
frontend-1  | Note that the development build is not optimized.
frontend-1  | To create a production build, use npm run build.
frontend-1  |
-------------------code----------------------

- our application is up and running and we can access it at localhost
port 3000. So, here's what we get. We have a mini application for managing a list of movies.
Now we know what's the beauty here? The beauty is that our database
is populated with these movies as part of bringing up our application.
we didn't have to manually insert these movies in our database.
So we have a migration script for populating our database
and docker automatically executed our migration script as part of bringing up this application.
This is a very common real world scenario. Now here we can add new movies, movie one, movie two, whatever.
And we can also delete these movies.
So we brought up this application using a single command.

*** 5- JSON and YAML Formats ***

- Let's talk about JSON and YAML formats. If we know these formats
in the root of this project we're going to add a new file called data.json.

- Now JSON, as we probably know, is a language, it's a human readable language
for representing data. So in this JSON file we can have an object
or an array. Let's say we want to represent a course. A course can
have properties like name, price, and so on. So in this object
we can add one or more key value pairs. Our keys should always be
surrounded in double quotes. So we can add a key called name and set its value
to, we can use a string, the ultimate docker course,
then we add a comma to define the next key value pair.
So we can say price, we can set this to a number,
now the value can also be a boolean, so we can define
another key value pair, and set the value to true or false.
We can define another key value pair and set the value to an array.
So, we define an array using square brackets. Now in this array
we can have any valid objects, so we can have strings, numbers,
booleans, or other objects. So we're going to add a couple of strings,
let's say software and devops.
one last key value pair. Author, we're going to make this an object,
so once again we use curly braces to define an object. In this object
we add a couple key value pairs, first name and last name so here we have a JSON file.
data.json
-------------------code----------------------
{
 "name": "The Ultimate Docker Course",
 "price": 149,
 "is_published": true,
 "tags": ["software", "devops"],
 "author": {
   "first_name": "hoge",
   "last_name": "hoge"
  }
}
-------------------code----------------------

- now let's see how we can convert this to YAML. YAML is another language
for presenting data, but it has less clutter than JSON, it's easier to read.
So, we're going to copy all this code. Here in the project, we're going to add a new file
called data.yaml. The extension can be yaml
or yml. Now, on the top we add three hyphens to indicate the beginning of a YAML file.
Then we paste our code. Now, in YAML, we don't use curly braces to indicate hierarchy.
This idea has come from Python. If we have programmed in Python, we know
that in Python, we use indentation to represent hierarchy. So we don't
have curly braces. So, let's get rid of these braces
and remove the indentation. Now, the next thing we need to know about YAML is that we
don't have to use quotes. So we can bring up the replace dialog and
replace all these double quotes with nothing.
That immediately takes a lot of clutter away. Also,
we're not going to use commas to separate key value pairs.
So on the top we have name, price, is published. Now, how do we represent a list
or an array? We use hyphens. then add a tab
on a new line, we type hyphen to define the
first item in the list. Software. Then, at the same indentation
we add the next item. DevOps. Now, author is an object, but as we told that we don't use curly braces, we use indentation.
So because these two properties are indented, they belong
to the author property.
So, this is our YAML file.
data.yml
-------------------code----------------------
name: The Ultimate Docker Course
price: 149
is_published: true
tags:
  - software
  - devops
author:
  first_name: hoge
  last_name: hoge
-------------------code----------------------

- Let's compare this with JSON. As we can see, YAML
is easier to read and understand.

- Now, why don't we use YAML all the time?
Well, because parsing YAML files is a little bit slower
than parsing JSON files. Because the parser doesn't know
if this is a string or a number. So it has to read everything as a string
and then try to evaluate it. In contrast, in JSON, strings are represented using quotes
and more specifically double quotes. So the parser knows that. This is a string
and it shouldn't evaluate it. So, quite often we use YAML files
for configuration files and JSON for exchanging data between multiple
computers, like a client and a server.
