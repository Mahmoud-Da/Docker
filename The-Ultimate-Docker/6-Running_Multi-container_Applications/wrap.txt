*** 1- Introduction ***

- Welcome back to another section of the ultimate Docker course. In this section, we're going to
talk about running multi-container applications. 

- So we're going to give we a real world application
with three building blocks, a front end built with React, a back end built with Node, and a
MongoDB database. Once again, we don't need to be familiar or use any of these tools. Our focus
here is on Docker and not on development tools.

- the most exciting part of this
course where we can see everything coming together. We'll talk about Docker compose for
building and running multi-container applications. We'll also talk about Docker networking, database
migration, and running automated tests. 
-------------------code----------------------
• Docker Compose
• Docker networking
• Database migration
• Running automated tests
-------------------code----------------------

*** 2- Installing Docker Compose ***

- In this section we're going to use a tool called
docker compose which is built on top of docker engine. It makes it incredibly easy
to start applications with multiple containers. 

- So google docker compose install, On this page we can see the installation instructions.
-------------------code----------------------
docs.docker.com/compose/install/
-------------------code----------------------

- Now at the time of recording this, docker compose is shipped with
docker desktop for mac and windows. So if we're on mac or
windows, we don't have to do anything extra. we already have docker compose.
To verify it, just go to the terminal window and type docker compose version.
-------------------code----------------------
$ docker compose version
Docker Compose version v2.33.1-desktop.1
-------------------code----------------------

- So we're running docker compose version 2.33.1. Make sure
the version is the same or newer. 

- Now if we're using an older version, again google upgrade docker compose. Or we might just install
the latest version of docker. 

- Now, back to the installation page.
If we're using windows server or linux, there are specific instructions
we have to follow to install docker compose. 


*** 3- Cleaning Up our Workspace ***

- Before we get started, we want to show we a couple of techniques for cleaning up our workspace.
So on this machine we have a bunch of images and
some running containers. They're getting in the way. we want to get rid of them all.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    d63e19272668   22 hours ago   482MB
<none>       <none>    ce326f24856a   23 hours ago   482MB
<none>       <none>    0211703e719b   47 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- How do we do this? Well, we know that we can remove images using
docker image remove command. And here we can type one or more
image IDs.
-------------------code----------------------
docker image rm 123 123
-------------------code----------------------

- Now how can we get all image IDs and pass them here?
as a cool trick. So we can run docker image ls we see all the images.
-------------------code----------------------
$ docker image ls
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    d63e19272668   22 hours ago   482MB
<none>       <none>    ce326f24856a   23 hours ago   482MB
<none>       <none>    0211703e719b   47 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- But if we pass dash q at the end, we only get image IDs. 

- Now we can pass this as an argument to docker image remove. So,
docker image remove. Now here we add a dollar sign,
and in parenthesis, we type that other command. So docker
image ls dash q. 
-------------------code----------------------
$ docker image ls -q
d63e19272668
ce326f24856a
0211703e719b
8d591b0b7dea
c3d1a3432580
-------------------code----------------------

- Now if we run this we're going to get an error
because some of these images are already in running containers, or
stopped containers. So we should always
remove containers first.
-------------------code----------------------
$ docker image rm $(docker image ls -q)
Deleted: sha256:ce326f24856a64a01179135c2b35fd7bd17e2efd71e61ecec7bb30c74364b9be
Untagged: alpine:latest
Untagged: alpine@sha256:a8560b36e8b8210634f77d9f7f9efd7ffa463e380b75e2e74aff4511df3ef88c
Deleted: sha256:8d591b0b7dea080ea3be9e12ae563eebf9869168ffced1cb25b2470a3d9fe15e
Untagged: ubuntu:latest
Untagged: ubuntu@sha256:72297848456d5d37d1262630108ab308d3e9ec7ed1c3286a32fe09856619a782
Deleted: sha256:c3d1a34325805c22bf44a5157224bcff58dc6a8868558c7746d6a2ea64eb191c
Deleted: sha256:375990b2a90a8d8f332d9b9422d948f7068a3313bf5a1c9fbb91ff2d29046130
Error response from daemon: conflict: unable to delete d63e19272668 (must be forced) - image is being used by stopped container e1c9962056ab
Error response from daemon: conflict: unable to delete 0211703e719b (must be forced) - image is being used by stopped container 912a9f10ea96
-------------------code----------------------

- We're going to do that using the same technique. So we're going to replace
image with container, so we get all container IDs, and then
we're going to remove them all in one go. Also,
we would like to add dash a here as well,
this will bring stopped containers as well. Okay? We can also combine
switches, that's another technique. Let's go ahead. Alright, we get an error saying
we cannot remove a running container, because we forgot to pass the
force option.
-------------------code----------------------
$ docker container rm $(docker container ls -aq)
Error response from daemon: You cannot remove a running container
-------------------code----------------------

- So, let's bring this up one more time. When removing, we're going to use dash f.
So all these containers are removed.
-------------------code----------------------
$ docker container rm -f $(docker container ls -aq)
4c042c40552d
bcdb2cf69efd
e1c9962056ab
1f0feff2e673
300b6cd7fa2d
912a9f10ea96
-------------------code----------------------

- Now let's remove the images. So, docker image ls, and docker image remove.
-------------------code----------------------
$ docker image rm $(docker image ls -q)
Untagged: react-app:latest
Deleted: sha256:d63e19272668b1d5fe42f33e1bef69b77f1ee11d565f5d324cf4ce4b33c2468e
Deleted: sha256:0211703e719b294529c6ff5579540f917db0778d832ae1cc85925770778759d2
-------------------code----------------------

- Now, take a look. We don't have any images.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID   CREATED   SIZE
-------------------code----------------------

- and no containers, including stopped containers.
So we have a clean workspace.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- That's one way. There is a shortcut for this as well. If we're on Mac, we can find the docker icon
on the top status bar. If we're on Windows, we will find it in our notification tray.
Let's click on this, and then go to preferences.

- Now, on this page, let's click on the troubleshoot icon. On this page, we have a bunch of useful
utilities. For example, we can restart docker desktop.
We can also clean and purge data. This will essentially remove everything
in docker. our images, our containers, our volumes, and so on.

- Now, be aware that if we click on this, this is going to restart docker engine.
So on the top, look, we can see this animation showing that the docker engine is not started yet.
So at this point, if we go to the terminal window and execute any of docker commands,
we're going to get an error. So we'll have to wait about half a minute
for the docker engine to start. That's another way. 


*** 4- The Sample Web Application ***

So in this section we're going to look at a real world application with multiple building blocks. A frontend, a backend
and a database. We have this backend folder which is our node project.
This is a basic node project that starts a web server on port 3001. Once again, we don't need to know node
to go through this section. Then we have the frontend project which is a react application that talks to the backend.

- Now, if we want to run this application outside
of docker, there are a number of steps we have to follow. Let's say
we just check this out from a github repository. First we have to go to our backend project,
install all dependencies, and then start the web server. Now at the same time, we have to open up
another terminal window and do the same steps with our frontend project. So we have to go
to the frontend project, install all the dependencies, and then start the web server.
And of course, we need two more terminal windows for running our frontend and backend tests.
And not to mention that, we should also download and install MongoDB on this machine. So there are so
many steps we have to follow the moment we check out the source code from our github repository. 
-------------------code----------------------
cd backend
npm i
cd ../frontend
npm i
-------------------code----------------------

- Now with docker, we don't have to do any of these things. All we have to do
is run a single command.
So, Now we are in the root of this project. If we look, here we have a file called docker compose
which is used for composing a multi-container application.
We're going to talk about that in detail soon.
-------------------code----------------------
$ ls
backend			docker-compose.yml	frontend
-------------------code----------------------

- Now, once we have this file in our project,
we can simply run docker compose up. That's all we have to do.
Now, docker is automatically downloading this particular version of MongoDB. So it's downloading
all these layers. Then at the same time, it's going to install all the dependencies for our frontend
and backend project. It will start web servers and run automated tests all in this window.
-------------------code----------------------
$ docker compose up
WARN[0000] 6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 13/13
 ✔ db Pulled                                                                                                                                      13.2s
   ✔ 828b35a09f0b Pull complete                                                                                                                    3.3s
   ✔ 66927c6d1d3d Pull complete                                                                                                                    3.4s
   ✔ 000560be9165 Pull complete                                                                                                                    3.4s
   ✔ 6225a0253717 Pull complete                                                                                                                    3.4s
   ✔ 20462772c88a Pull complete                                                                                                                    3.4s
   ✔ 8892f6e8bb20 Pull complete                                                                                                                    3.5s
   ✔ ba880f936bf8 Pull complete                                                                                                                    3.5s
   ✔ 62a85e868ee1 Pull complete                                                                                                                    3.5s
   ✔ 5c2a89ead641 Pull complete                                                                                                                    3.5s
   ✔ 5970f465dd7d Pull complete                                                                                                                    3.5s
   ✔ ec025da43478 Pull complete                                                                                                                    6.5s
   ✔ 91ff9a6f40b5 Pull complete                                                                                                                    6.5s
Compose now can delegate build to bake for better performances
Just set COMPOSE_BAKE=true
[+] Building 24.0s (20/20) FINISHED                                                                                                docker:desktop-linux
 => [backend internal] load build definition from Dockerfile                                                                                       0.0s
 => => transferring dockerfile: 266B                                                                                                               0.0s
 => [frontend internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                2.4s
 => [backend internal] load .dockerignore                                                                                                          0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [frontend 1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b          0.0s
 => [backend internal] load build context                                                                                                          0.0s
 => => transferring context: 277.43kB                                                                                                              0.0s
 => CACHED [frontend 2/6] RUN addgroup app && adduser -S -G app app                                                                                0.0s
 => CACHED [frontend 3/6] WORKDIR /app                                                                                                             0.0s
 => [backend 4/6] COPY package*.json ./                                                                                                            0.1s
 => [backend 5/6] RUN npm install                                                                                                                  6.1s
 => [backend 6/6] COPY . .                                                                                                                         0.0s
 => [backend] exporting to image                                                                                                                   0.7s
 => => exporting layers                                                                                                                            0.6s
 => => writing image sha256:bf304fa22d9a611c49cbbf9c2ce76ab47ca7ee08fd6fb4298632a72093e9cfdf                                                       0.0s
 => => naming to docker.io/library/vidly-backend                                                                                                   0.0s
 => [backend] resolving provenance for metadata file                                                                                               0.0s
 => [frontend internal] load build definition from Dockerfile                                                                                      0.0s
 => => transferring dockerfile: 265B                                                                                                               0.0s
 => [frontend internal] load .dockerignore                                                                                                         0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [frontend internal] load build context                                                                                                         0.0s
 => => transferring context: 673.53kB                                                                                                              0.0s
 => [frontend 4/6] COPY package*.json ./                                                                                                           0.0s
 => [frontend 5/6] RUN npm install                                                                                                                13.0s
 => [frontend 6/6] COPY . .                                                                                                                        0.0s
 => [frontend] exporting to image                                                                                                                  1.5s
 => => exporting layers                                                                                                                            1.5s
 => => writing image sha256:8352bb4950d270f2a86b71c5a5298a2fd753457a567fb7976c97a1664eccda0a                                                       0.0s
 => => naming to docker.io/library/vidly-frontend                                                                                                  0.0s
 => [frontend] resolving provenance for metadata file                                                                                              0.0s
[+] Running 7/7
 ✔ backend                     Built                                                                                                               0.0s
 ✔ frontend                    Built                                                                                                               0.0s
 ✔ Network vidly_default       Created                                                                                                             0.0s
 ✔ Volume "vidly_vidly"        Created                                                                                                             0.0s
 ✔ Container vidly-db-1        Created                                                                                                             0.0s
 ✔ Container vidly-backend-1   Created                                                                                                             0.0s
 ✔ Container vidly-frontend-1  Created                                                                                                             0.0s
Attaching to backend-1, db-1, frontend-1
db-1        | 2025-03-22T05:33:38.415+0000  CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=0e8272cc3a01
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] db version v4.0.28
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] git version: af1a9dc12adcfa83cc19571cb3faba26eeddac92
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2g  1 Mar 2016
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] allocator: tcmalloc
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] modules: none
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] build environment:
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     distmod: ubuntu1604
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     distarch: aarch64
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten]     target_arch: aarch64
db-1        | 2025-03-22T05:33:38.416+0000  CONTROL  [initandlisten] options: { net: { bindIpAll: true } }
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten]
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem
db-1        | 2025-03-22T05:33:38.417+0000  STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=474M,cache_overflow=(file_max=0M),session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),
db-1        | 2025-03-22T05:33:38.426+0000  STORAGE  [initandlisten] WiredTiger message [1742621618:426854][1:0xffffaefcd000], txn-recover: Set global recovery timestamp: 0
db-1        | 2025-03-22T05:33:38.430+0000  RECOVERY [initandlisten] WiredTiger recoveryTimestamp. Ts: Timestamp(0, 0)
db-1        | 2025-03-22T05:33:38.435+0000  STORAGE  [initandlisten] Starting to check the table logging settings for existing WiredTiger tables
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] ** WARNING: Access control is not enabled for the database.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] **          Read and write access to data and configuration is unrestricted.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] ** WARNING: /sys/kernel/mm/transparent_hugepage/enabled is 'always'.
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten] **        We suggest setting it to 'never'
db-1        | 2025-03-22T05:33:38.437+0000  CONTROL  [initandlisten]
db-1        | 2025-03-22T05:33:38.437+0000  STORAGE  [initandlisten] createCollection: admin.system.version with provided UUID: 70df6218-248d-4e23-9a1a-6421c6199541
db-1        | 2025-03-22T05:33:38.443+0000  COMMAND  [initandlisten] setting featureCompatibilityVersion to 4.0
db-1        | 2025-03-22T05:33:38.443+0000  STORAGE  [initandlisten] Finished adjusting the table logging settings for existing WiredTiger tables
db-1        | 2025-03-22T05:33:38.443+0000  STORAGE  [initandlisten] createCollection: local.startup_log with generated UUID: 3d84ad6f-d067-4853-b803-bf8d54b2a3d8
backend-1   | /usr/local/bin/docker-entrypoint.sh: exec: line 8: ./docker-entrypoint.sh: Permission denied
db-1        | 2025-03-22T05:33:38.448+0000  FTDC     [initandlisten] Initializing full-time diagnostic data capture with directory '/data/db/diagnostic.data'
db-1        | 2025-03-22T05:33:38.451+0000  STORAGE  [LogicalSessionCacheRefresh] createCollection: config.system.sessions with generated UUID: 789443b1-56c1-45b7-a38d-0bdc942c1848
db-1        | 2025-03-22T05:33:38.451+0000  NETWORK  [initandlisten] waiting for connections on port 27017
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] build index on: config.system.sessions properties: { v: 2, key: { lastUse: 1 }, name: "lsidTTLIndex", ns: "config.system.sessions", expireAfterSeconds: 1800 }
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] 	 building index using bulk method; build may temporarily use up to 500 megabytes of RAM
db-1        | 2025-03-22T05:33:38.461+0000  INDEX    [LogicalSessionCacheRefresh] build index done.  scanned 0 total records. 0 secs
backend-1 exited with code 126
frontend-1  |
frontend-1  | > vidly-frontend@0.1.0 start /app
frontend-1  | > react-scripts start
frontend-1  |
frontend-1  | ℹ ｢wds｣: Project is running at http://172.18.0.4/
frontend-1  | ℹ ｢wds｣: webpack output is served from
frontend-1  | ℹ ｢wds｣: Content not from webpack is served from /app/public
frontend-1  | ℹ ｢wds｣: 404s will fallback to /
frontend-1  | Starting the development server...
frontend-1  |
frontend-1  | Browserslist: caniuse-lite is outdated. Please run:
frontend-1  | npx browserslist@latest --update-db
frontend-1  |
frontend-1  | Why should do it regularly:
frontend-1  | https://github.com/browserslist/browserslist#browsers-data-updating
frontend-1  | Compiled successfully!
frontend-1  |
frontend-1  | You can now view vidly-frontend in the browser.
frontend-1  |
frontend-1  |   Local:            http://localhost:3000
frontend-1  |   On Your Network:  http://172.18.0.4:3000
frontend-1  |
frontend-1  | Note that the development build is not optimized.
frontend-1  | To create a production build, use npm run build.
frontend-1  |
-------------------code----------------------

- our application is up and running and we can access it at localhost
port 3000. So, here's what we get. We have a mini application for managing a list of movies.
Now we know what's the beauty here? The beauty is that our database
is populated with these movies as part of bringing up our application.
we didn't have to manually insert these movies in our database.
So we have a migration script for populating our database
and docker automatically executed our migration script as part of bringing up this application.
This is a very common real world scenario. Now here we can add new movies, movie one, movie two, whatever.
And we can also delete these movies.
So we brought up this application using a single command.

*** 5- JSON and YAML Formats ***

- Let's talk about JSON and YAML formats. If we know these formats
in the root of this project we're going to add a new file called data.json.

- Now JSON, as we probably know, is a language, it's a human readable language
for representing data. So in this JSON file we can have an object
or an array. Let's say we want to represent a course. A course can
have properties like name, price, and so on. So in this object
we can add one or more key value pairs. Our keys should always be
surrounded in double quotes. So we can add a key called name and set its value
to, we can use a string, the ultimate docker course,
then we add a comma to define the next key value pair.
So we can say price, we can set this to a number,
now the value can also be a boolean, so we can define
another key value pair, and set the value to true or false.
We can define another key value pair and set the value to an array.
So, we define an array using square brackets. Now in this array
we can have any valid objects, so we can have strings, numbers,
booleans, or other objects. So we're going to add a couple of strings,
let's say software and devops.
one last key value pair. Author, we're going to make this an object,
so once again we use curly braces to define an object. In this object
we add a couple key value pairs, first name and last name so here we have a JSON file.
data.json
-------------------code----------------------
{
 "name": "The Ultimate Docker Course",
 "price": 149,
 "is_published": true,
 "tags": ["software", "devops"],
 "author": {
   "first_name": "hoge",
   "last_name": "hoge"
  }
}
-------------------code----------------------

- now let's see how we can convert this to YAML. YAML is another language
for presenting data, but it has less clutter than JSON, it's easier to read.
So, we're going to copy all this code. Here in the project, we're going to add a new file
called data.yaml. The extension can be yaml
or yml. Now, on the top we add three hyphens to indicate the beginning of a YAML file.
Then we paste our code. Now, in YAML, we don't use curly braces to indicate hierarchy.
This idea has come from Python. If we have programmed in Python, we know
that in Python, we use indentation to represent hierarchy. So we don't
have curly braces. So, let's get rid of these braces
and remove the indentation. Now, the next thing we need to know about YAML is that we
don't have to use quotes. So we can bring up the replace dialog and
replace all these double quotes with nothing.
That immediately takes a lot of clutter away. Also,
we're not going to use commas to separate key value pairs.
So on the top we have name, price, is published. Now, how do we represent a list
or an array? We use hyphens. then add a tab
on a new line, we type hyphen to define the
first item in the list. Software. Then, at the same indentation
we add the next item. DevOps. Now, author is an object, but as we told that we don't use curly braces, we use indentation.
So because these two properties are indented, they belong
to the author property.
So, this is our YAML file.
data.yml
-------------------code----------------------
name: The Ultimate Docker Course
price: 149
is_published: true
tags:
  - software
  - devops
author:
  first_name: hoge
  last_name: hoge
-------------------code----------------------

- Let's compare this with JSON. As we can see, YAML
is easier to read and understand.

- Now, why don't we use YAML all the time?
Well, because parsing YAML files is a little bit slower
than parsing JSON files. Because the parser doesn't know
if this is a string or a number. So it has to read everything as a string
and then try to evaluate it. In contrast, in JSON, strings are represented using quotes
and more specifically double quotes. So the parser knows that. This is a string
and it shouldn't evaluate it. So, quite often we use YAML files
for configuration files and JSON for exchanging data between multiple
computers, like a client and a server.


*** 6- Creating a Compose File ***

- Alright, let's see how we can create a compose file from scratch. So, for this lesson,
we're going to rename this file to underline docker compose. We want to set it aside and
create a new compose file from scratch.
-------------------code----------------------
_docker-compose.yml
-------------------code----------------------

- So, here we have a new file, called docker-compose, all in lower case,
make sure to spell it properly, otherwise docker compose is not going to find this file.
Because this is the default name that docker compose assumes.

- So, yaml, now the first thing that we need to set
here is the version property. What version should we use?
Well, let's search for docker compose file.
-------------------code----------------------
docs.docker.com/compose/compose-file/
-------------------code----------------------

- On this page, we can see various compose file
formats and their compatibility with docker engine.
We are using the latest version of docker engine, so we want to use the latest compose file
format, so we have access to the latest features. So,
we're going to set this to 3.8. Now, here we need to wrap this number
with double quotes, otherwise it will be evaluated as a number.
But docker compose expects this value to be a string. Why?
we have no clue. So, here's the version. 
-------------------code----------------------
version: "3.8" 
-------------------code----------------------

- Now, in this file we define various building blocks
or services of our application. So, we have a property called services.
Now, what services do we need here? Well, our application has a front end,
a back end, and a database. Now, our application might have other moving parts.
So we can define them here.
-------------------code----------------------
services:
 frontend:
 backend:
 database:
-------------------code----------------------

- Now, these names are arbitrary, so we can call them anything.
We can change this to db, we can change the back end to api,
and the front end to web. The idea here is that
we're defining various services and telling docker how to build images for each service
and how to run these images.
-------------------code----------------------
services:
 web:
 api:
 db:
-------------------code----------------------

- So, here we're going to have properties and the value of these properties
will eventually be used when running our containers. So, in the
previous section, we had to manually run our containers using docker run,
and here we used parameters like dash p for port mapping
-------------------code----------------------
docker run -p
-------------------code----------------------

- or dash v for volume mapping.
-------------------code----------------------
docker run -v
-------------------code----------------------

- We also had to specify an image like react app.
-------------------code----------------------
docker run react app
-------------------code----------------------

- All these values can be defined in our compose file. So we don't have to manually
start our containers. Docker compose will take care of starting our
containers under the hood.

- So, for each service, we need to tell docker how to build an image
for that service. So here we can use the build property and tell docker
compose where it can find a docker file. So,
if we look at this project, we can see that in our backend and
frontend folders, we have a docker file. This docker file is almost identical
to the one we created in the previous section.

- We have a similar docker file in our frontend project.
Let's have a quick look. So that was the backend, here's the frontend,
and here we have a docker file. Almost identical, but the
frontend application or the frontend server starts on a different port.

- That is the only difference. So each service should have its own
docker file. Now, back to our compose file, for our web or frontend,
we're going to set the build property to period, meaning current folder,
slash frontend. This is where we have a docker file.
For our API, we're going to set build to backend.
Now for our database, we're not going to build an image,
we're going to pull an image from docker hub. So instead of the build property,
we're going to use the image property.
Now for this application,
we're going to use mongo .So that is mongo version 4,
built on top of Xenio, which is Ubuntu version 16. If we look at docker hub,
we can see that mongo also has images built on top of windows,
but windows images are very large, over 2 gigabytes.
So that's why we prefer to use Linux images.
So for any of these services, we can either build an image or pull it down.
-------------------code----------------------
services:
 web:
   build: ./frontend
 api:
   build: ./backend
 db:
   image: mongo:4.0-xenial
-------------------code----------------------

- Now here we also have port mappings, so we set ports to.
Now because we can have multiple port mappings,
here we need to use the array or list syntax.
So we use a hyphen and then define a port mapping.
So our frontend application starts on port 3000.
So we want to map port 3000 of the host
to port 3000 of the container running this image.
Now similarly for our API, we're going to define a port mapping.
This one is going to be 3001 to 3001. Now, MongoDB by default listens on port
27017. So we want to map the same port so we can access MongoDB using a MongoDB client like
MongoDB compass. Now if we don't use MongoDB, we have the same concept
with other database engines. All these database engines
listen on a default port. You want to map that port
so we can connect to our database engine using our favorite database client.
-------------------code----------------------
services:
  web:
    build: ./frontend
    ports:
      - 3000:3000
  api:
    build: ./backend
    ports:
      - 3001:3001
    
  db:
    image: mongo:4.0-xenial
    ports:
      - 27017:27017
-------------------code----------------------

- Back to this page for compose file. If we look at version 3,
on the right, we can see all valid properties. Now a lot of these are for really special cases,
so we don't need to use them all the time, but the ones that we use most of the time are
build or image. 

- we also use ports, volumes, environment, and so on. So our API project
needs an environment variable that tells where our database is.
So, here we set environment. Now here we can use the list syntax
because we can have multiple environment variables.
So we set db underline url to here we need to type a MongoDB connection string.
These connection strings always start with MongoDB colon two forward slashes.
Here we need to type the name of a host.


- when we start an application with docker compose,
under the hood a network is created.
On this network we're going to have three hosts. The name of these hosts
are equal to the names we have defined here.
So we're going to have a host called db. So that is the connection string
to our MongoDB server.
-------------------code----------------------
api:
    build: ./backend
    ports:
      - 3001:3001
    environment:
      - DB_URL=mongodb://db/vidly
-------------------code----------------------


- Now, on this server we can have multiple databases.
So we're going to specify the database name and the connection string as well.
So this is one way to set an environment variable.
But instead of using the list syntax we can also use the object
or property value syntax. So, we get rid of the hyphen, we say db url
is a property and this is the value of that property.
we find the syntax more readable
because we get color coding and it's just cleaner.
-------------------code----------------------
api:
    build: ./backend
    ports:
      - 3001:3001
    environment:
      DB_URL: mongodb://db/vidly
-------------------code----------------------

- the last thing we want to add here is a volume.
because we don't want MongoDB to write data
to the temporary file system of the container.
So, here we set volumes
and again, we can have one or more volume mappings.
So, we add hyphen, we're going to map a volume called vidly,
and of course we can call it anything, vidly is the name of this application.
So, we're going to map this volume to a directory inside the container.


- Now, if we look at the documentation of MongoDB on Docker Hub
or just a typical MongoDB documentation, we know that by default, MongoDB stores this data
in slash data slash db. So, we want to map this volume to this directory,
so whatever that is written inside this directory
is actually outside of this container.
-------------------code----------------------
db:
    image: mongo:4.0-xenial
    ports:
      - 27017:27017
    volumes:
      - vidly:/data/db
-------------------code----------------------

- it's somewhere else in our volume.
Now, because we have used this volume here, we have to define it in our compose file.
so now we are at the same level as
services. Here we're going to define
another property called volumes, and here we're going to add another property called vidly
with no value.
we know this looks a little bit weird, but this is the syntax we have to follow.
We just have to define the volume first before we can use it.
So, this is our compose file.
-------------------code----------------------
volumes:
  vidly:
-------------------code----------------------

- Now, we can make this more readable by adding line breaks in between
these properties. We can also order these services any way we want.
So currently we're ordering them from front to back.
We can also order them from back to front, so we will put database first,
then API, and then web. So we're done with our compose file.
-------------------code----------------------
version: "3.8"
services:
  web:
    build: ./frontend
    ports:
      - 3000:3000
  api:
    build: ./backend
    ports:
      - 3001:3001
    environment:
      DB_URL: mongodb://db/vidly
    
  db:
    image: mongo:4.0-xenial
    ports:
      - 27017:27017
    volumes:
      - vidly:/data/db

volumes:
  vidly:
-------------------code----------------------

*** 7- Building Images ***

- Earlier told we that docker compose is built on top of docker engine. So everything we have done with docker engine like building
images, listing them, starting containers and so on, all of these operations
are also available using docker compose.

- So, we type docker compose without any arguments, enter,
look, we have all these subcommands like we have rm
for removing stopped containers, we have run, we have push,
pull and so on. The difference is that any of these commands will apply
to our application as a whole. So most of these commands will impact
multiple services or multiple containers in our application.
-------------------code----------------------
$ docker compose
Usage:  docker compose [OPTIONS] COMMAND

Define and run multi-container applications with Docker

Options:
      --all-resources              Include all resources, even those not used by services
      --ansi string                Control when to print ANSI control characters ("never"|"always"|"auto") (default "auto")
      --compatibility              Run compose in backward compatibility mode
      --dry-run                    Execute command in dry run mode
      --env-file stringArray       Specify an alternate environment file
  -f, --file stringArray           Compose configuration files
      --parallel int               Control max parallelism, -1 for unlimited (default -1)
      --profile stringArray        Specify a profile to enable
      --progress string            Set type of progress output (auto, tty, plain, json, quiet) (default "auto")
      --project-directory string   Specify an alternate working directory
                                   (default: the path of the, first specified, Compose file)
  -p, --project-name string        Project name

Commands:
  attach      Attach local standard input, output, and error streams to a service's running container
  build       Build or rebuild services
  commit      Create a new image from a service container's changes
  config      Parse, resolve and render compose file in canonical format
  cp          Copy files/folders between a service container and the local filesystem
  create      Creates containers for a service
  down        Stop and remove containers, networks
  events      Receive real time events from containers
  exec        Execute a command in a running container
  export      Export a service container's filesystem as a tar archive
  images      List images used by the created containers
  kill        Force stop service containers
  logs        View output from containers
  ls          List running compose projects
  pause       Pause services
  port        Print the public port for a port binding
  ps          List containers
  pull        Pull service images
  push        Push service images
  restart     Restart service containers
  rm          Removes stopped service containers
  run         Run a one-off command on a service
  scale       Scale services
  start       Start services
  stats       Display a live stream of container(s) resource usage statistics
  stop        Stop services
  top         Display the running processes
  unpause     Unpause services
  up          Create and start containers
  version     Show the Docker Compose version information
  wait        Block until containers of all (or specified) services stop.
  watch       Watch build context for service and rebuild/refresh containers when files are updated

Run 'docker compose COMMAND --help' for more information on a command.
-------------------code----------------------

- So, let's look at docker compose build
and also use the help option. So we have a bunch of options
here. A couple of them we want to point out that are useful to know is
no cache. With this we can prevent caching when building the image.
Sometimes we encounter weird issues and we want to make sure that cache is not
used. In that case we use this option. Another useful option is
dash dash pull. With this we can always pull
a newer version of the image. That is also good to know.
-------------------code----------------------
$ docker compose build --help
Usage:  docker compose build [OPTIONS] [SERVICE...]

Build or rebuild services

Options:
      --build-arg stringArray   Set build-time variables for services
      --builder string          Set builder to use
      --dry-run                 Execute command in dry run mode
  -m, --memory bytes            Set memory limit for the build container. Not supported by BuildKit.
      --no-cache                Do not use cache when building the image
      --pull                    Always attempt to pull a newer version of the image
      --push                    Push service images
  -q, --quiet                   Don't print anything to STDOUT
      --ssh string              Set SSH authentications used when building service images. (use 'default' for using our default SSH Agent)
      --with-dependencies       Also build dependencies (transitively)
-------------------code----------------------

- So, in this lesson we're not going to use any of this. We're just going to run docker compose
build. This build our web and api services.
-------------------code----------------------
$ docker compose build
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
Compose now can delegate build to bake for better performances
Just set COMPOSE_BAKE=true
[+] Building 1.8s (20/20) FINISHED                                                                                                 docker:desktop-linux
 => [web internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 265B                                                                                                               0.0s
 => [api internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 266B                                                                                                               0.0s
 => [web internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                     1.7s
 => [api internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [web internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [api 1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b               0.0s
 => [web internal] load build context                                                                                                              0.0s
 => => transferring context: 2.62kB                                                                                                                0.0s
 => [api internal] load build context                                                                                                              0.0s
 => => transferring context: 1.74kB                                                                                                                0.0s
 => CACHED [api 2/6] RUN addgroup app && adduser -S -G app app                                                                                     0.0s
 => CACHED [api 3/6] WORKDIR /app                                                                                                                  0.0s
 => CACHED [web 4/6] COPY package*.json ./                                                                                                         0.0s
 => CACHED [web 5/6] RUN npm install                                                                                                               0.0s
 => CACHED [web 6/6] COPY . .                                                                                                                      0.0s
 => [web] exporting to image                                                                                                                       0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:903657fa0a130f05f26c5a3d4f5c75107abfd1e5782c7aabcf313844e3c678bd                                                       0.0s
 => => naming to docker.io/library/vidly-web                                                                                                       0.0s
 => CACHED [api 4/6] COPY package*.json ./                                                                                                         0.0s
 => CACHED [api 5/6] RUN npm install                                                                                                               0.0s
 => CACHED [api 6/6] COPY . .                                                                                                                      0.0s
 => [api] exporting to image                                                                                                                       0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:e067d8a1ca102469fdafb674b184460dc59780758df425f2f83f0825202f5aaa                                                       0.0s
 => => naming to docker.io/library/vidly-api                                                                                                       0.0s
 => [web] resolving provenance for metadata file                                                                                                   0.0s
 => [api] resolving provenance for metadata file                                                                                                   0.0s
[+] Building 2/2
 ✔ api  Built                                                                                                                                      0.0s
 ✔ web  Built
-------------------code----------------------

- And as we noticed, our build was super fast because
pretty much everything came from the cache. So, let's run
docker images. So we have five images on this machine.
vidly frontend, vidly web, vidly api, vidly backend
and mongo. Mongo obviously came from docker hub.
Now as part of this build process in this lesson, we built vidly web and vidly api.
These two other images with the frontend and backend were built when we started this application earlier.
So, back to our project, in this original compose file that we included
in this project, look, we call these services
frontend and backend instead of web and api. That is why
we have these two images vidly frontend and vidly backend.
Also, as we have noticed, when building images with docker compose,
our images are prefixed with the name of our application.
Now where does this come from?
It is the name of the directory. So currently
we are inside a directory called vidly
and that is why all these images
are prefixed with vidly. 
-------------------code----------------------
$ docker images
REPOSITORY       TAG          IMAGE ID       CREATED             SIZE
vidly-frontend   latest       8352bb4950d2   About an hour ago   298MB
vidly-web        latest       903657fa0a13   About an hour ago   298MB
vidly-backend    latest       bf304fa22d9a   About an hour ago   183MB
vidly-api        latest       e067d8a1ca10   About an hour ago   183MB
mongo            4.0-xenial   001f0278293f   2 years ago         401MB
-------------------code----------------------

- Now we got a question for we. If we look at the created column,
we can see all these images were created an hour ago.
But didn't we just build the web and api images? Why do we think
this happened? Here's the answer.
Because we built these images frontend and
backend an hour ago at the previous lesson in this section.
Now, when building these new images, docker used everything in the
cache because all those files were already available, all those layers were there.
So docker didn't have to do a full rebuild. That is why
we are still using the build from an
hour ago.

- Now, if we want to force a full rebuild,
we can say docker compose build dash dash no cache.
Alright, our images are built. 
-------------------code----------------------
$ docker compose build --no-cache
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
Compose now can delegate build to bake for better performances
Just set COMPOSE_BAKE=true
[+] Building 22.2s (20/20) FINISHED                                                                                                docker:desktop-linux
 => [web internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 265B                                                                                                               0.0s
 => [api internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 266B                                                                                                               0.0s
 => [web internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                     0.8s
 => [web internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [api internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => CACHED [api 1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b        0.0s
 => [web internal] load build context                                                                                                              0.0s
 => => transferring context: 2.62kB                                                                                                                0.0s
 => [web 2/6] RUN addgroup app && adduser -S -G app app                                                                                            0.3s
 => [api internal] load build context                                                                                                              0.0s
 => => transferring context: 1.74kB                                                                                                                0.0s
 => [web 3/6] WORKDIR /app                                                                                                                         0.0s
 => [api 4/6] COPY package*.json ./                                                                                                                0.0s
 => [web 4/6] COPY package*.json ./                                                                                                                0.0s
 => [api 5/6] RUN npm install                                                                                                                      9.6s
 => [web 5/6] RUN npm install                                                                                                                     19.6s
 => [api 6/6] COPY . .                                                                                                                             0.1s
 => [api] exporting to image                                                                                                                       0.9s
 => => exporting layers                                                                                                                            0.9s
 => => writing image sha256:51904ca74d70d8b4a19c96e6689c176fac22bfe00ec7e68ef272ce447e38b6a7                                                       0.0s
 => => naming to docker.io/library/vidly-api                                                                                                       0.0s
 => [api] resolving provenance for metadata file                                                                                                   0.0s
 => [web 6/6] COPY . .                                                                                                                             0.0s
 => [web] exporting to image                                                                                                                       1.5s
 => => exporting layers                                                                                                                            1.5s
 => => writing image sha256:6f5c46c0500547e73a1141d6527aaff2139cb966050291e529395e18635fd9d4                                                       0.0s
 => => naming to docker.io/library/vidly-web                                                                                                       0.0s
 => [web] resolving provenance for metadata file                                                                                                   0.0s
[+] Building 2/2
 ✔ api  Built                                                                                                                                      0.0s
 ✔ web  Built
-------------------code----------------------

- So let's run docker images. There we go.
Look at the first two images, api and web
were built less than a minute ago. So that's all about building images.
-------------------code----------------------
$ docker images
REPOSITORY       TAG          IMAGE ID       CREATED              SIZE
vidly-web        latest       6f5c46c05005   53 seconds ago       298MB
vidly-api        latest       51904ca74d70   About a minute ago   183MB
vidly-frontend   latest       8352bb4950d2   About an hour ago    298MB
vidly-backend    latest       bf304fa22d9a   About an hour ago    183MB
mongo            4.0-xenial   001f0278293f   2 years ago          401MB
-------------------code----------------------

*** 8- Starting and Stopping the Application ***

- we briefly saw how we can start an application with docker compose.
We just type docker compose up. Now if the images are
ready, docker compose will run them inside containers, otherwise it's
going to build the images automatically. 

- Now, before executing this, let's look at the available options. So here we have a ton
of options, a couple of them that are useful are build.
-------------------code----------------------
$ docker compose up --help
Usage:  docker compose up [OPTIONS] [SERVICE...]

Create and start containers

Options:
      --abort-on-container-exit      Stops all containers if any container was stopped. Incompatible with -d
      --abort-on-container-failure   Stops all containers if any container exited with failure. Incompatible with -d
      --always-recreate-deps         Recreate dependent containers. Incompatible with --no-recreate.
      --attach stringArray           Restrict attaching to the specified services. Incompatible with --attach-dependencies.
      --attach-dependencies          Automatically attach to log output of dependent services
      --build                        Build images before starting containers
  -d, --detach                       Detached mode: Run containers in the background
      --dry-run                      Execute command in dry run mode
      --exit-code-from string        Return the exit code of the selected service container. Implies --abort-on-container-exit
      --force-recreate               Recreate containers even if their configuration and image haven't changed
      --menu                         Enable interactive shortcuts when running attached. Incompatible with --detach. Can also be enable/disable
                                     by setting COMPOSE_MENU environment var.
      --no-attach stringArray        Do not attach (stream logs) to the specified services
      --no-build                     Don't build an image, even if it's policy
      --no-color                     Produce monochrome output
      --no-deps                      Don't start linked services
      --no-log-prefix                Don't print prefix in logs
      --no-recreate                  If containers already exist, don't recreate them. Incompatible with --force-recreate.
      --no-start                     Don't start the services after creating them
      --pull string                  Pull image before running ("always"|"missing"|"never") (default "policy")
      --quiet-pull                   Pull without printing progress information
      --remove-orphans               Remove containers for services not defined in the Compose file
  -V, --renew-anon-volumes           Recreate anonymous volumes instead of retrieving data from the previous containers
      --scale scale                  Scale SERVICE to NUM instances. Overrides the scale setting in the Compose file if present.
  -t, --timeout int                  Use this timeout in seconds for container shutdown when attached or when containers are already running
      --timestamps                   Show timestamps
      --wait                         Wait for services to be running|healthy. Implies detached mode.
      --wait-timeout int             Maximum duration in seconds to wait for the project to be running|healthy
  -w, --watch                        Watch source code and rebuild/refresh containers when files are updated.
  -y, --y                            Assume "yes" as answer to all prompts and run non-interactively
-------------------code----------------------

- with this
we can force a rebuild every time we want to start our application. So we
don't have to explicitly run docker compose build and then up. We can combine the two
using the build option. 
-------------------code----------------------
docker compose up --build
-------------------code----------------------

- The other useful option is dash d for detached mode. So we will start these containers in the background. 
-------------------code----------------------
$ docker compose up -d
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 1/1
 ✔ db Pulled                                                                                                                                       7.3s
Compose now can delegate build to bake for better performances
Just set COMPOSE_BAKE=true
[+] Building 1.7s (20/20) FINISHED                                                                                                 docker:desktop-linux
 => [api internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 266B                                                                                                               0.0s
 => [web internal] load build definition from Dockerfile                                                                                           0.0s
 => => transferring dockerfile: 265B                                                                                                               0.0s
 => [api internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                     1.6s
 => [web internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [api internal] load .dockerignore                                                                                                              0.0s
 => => transferring context: 102B                                                                                                                  0.0s
 => [api 1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b               0.0s
 => [api internal] load build context                                                                                                              0.0s
 => => transferring context: 1.74kB                                                                                                                0.0s
 => [web internal] load build context                                                                                                              0.0s
 => => transferring context: 2.62kB                                                                                                                0.0s
 => CACHED [api 2/6] RUN addgroup app && adduser -S -G app app                                                                                     0.0s
 => CACHED [api 3/6] WORKDIR /app                                                                                                                  0.0s
 => CACHED [web 4/6] COPY package*.json ./                                                                                                         0.0s
 => CACHED [web 5/6] RUN npm install                                                                                                               0.0s
 => CACHED [web 6/6] COPY . .                                                                                                                      0.0s
 => [web] exporting to image                                                                                                                       0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:6f5c46c0500547e73a1141d6527aaff2139cb966050291e529395e18635fd9d4                                                       0.0s
 => => naming to docker.io/library/vidly-web                                                                                                       0.0s
 => CACHED [api 4/6] COPY package*.json ./                                                                                                         0.0s
 => CACHED [api 5/6] RUN npm install                                                                                                               0.0s
 => CACHED [api 6/6] COPY . .                                                                                                                      0.0s
 => [api] exporting to image                                                                                                                       0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:51904ca74d70d8b4a19c96e6689c176fac22bfe00ec7e68ef272ce447e38b6a7                                                       0.0s
 => => naming to docker.io/library/vidly-api                                                                                                       0.0s
 => [web] resolving provenance for metadata file                                                                                                   0.0s
 => [api] resolving provenance for metadata file                                                                                                   0.0s
WARN[0009] Found orphan containers ([vidly-frontend-1 vidly-backend-1]) for this project. If we removed or renamed this service in our compose file, we can run this command with the --remove-orphans flag to clean it up.
[+] Running 5/5
 ✔ api                    Built                                                                                                                    0.0s
 ✔ web                    Built                                                                                                                    0.0s
 ✔ Container vidly-web-1  Started                                                                                                                  0.3s
 ✔ Container vidly-api-1  Started                                                                                                                  0.3s
 ✔ Container vidly-db-1   Started
-------------------code----------------------

- So, now if we run docker compose ps, we can see
all the containers relevant to this application. In contrast,
if we type docker ps, we can see all the running containers across
all applications.
-------------------code----------------------
$ docker compose ps
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
NAME          IMAGE              COMMAND                   SERVICE   CREATED              STATUS              PORTS
vidly-api-1   vidly-api          "docker-entrypoint.s…"   api       About a minute ago   Up About a minute   0.0.0.0:3001->3001/tcp
vidly-db-1    mongo:4.0-xenial   "docker-entrypoint.s…"   db        About an hour ago    Up About a minute   0.0.0.0:27017->27017/tcp
vidly-web-1   vidly-web          "docker-entrypoint.s…"   web       About a minute ago   Up About a minute   0.0.0.0:3000->3000/tcp
-------------------code----------------------

- So, here we have three containers, vidly, api1, bitly db1, and web1.
Now what is this one? Well, we can start multiple containers
from the same image. And this is used for high availability and scalability. It's
something we'll look at in the future. So here we can see the container. You can see what command
started that container. So, for our api, that was npm start.
For our database, that was mongod, or mongodamon
process. And for our web front end, that was npm start as well. You can see all these
containers are up and running. And over here, we can see port mappings.
So now if we go to localhost port 3000,
we can see our application.
-------------------code----------------------
docker ps
-------------------code----------------------

- Now, how do we take this down? Let's say
we're done with this application, and we
want to free up resources.
Back to the terminal, we type docker compose down.
This will stop and remove these containers. But the images are still
there. So next time we want to start
the application, our application will start
pretty quickly.
-------------------code----------------------
 $ docker compose down
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 4/4
 ✔ Container vidly-api-1  Removed                                                                                                                  0.4s
 ✔ Container vidly-db-1   Removed                                                                                                                  0.5s
 ✔ Container vidly-web-1  Removed                                                                                                                  0.4s
 ✔ Network vidly_default  Removed
-------------------code----------------------

*** 9- Docker Networking ***

- Let's talk about networking in docker.
Let me run our application with docker compose, docker compose will automatically
create a network and add our containers on that network. 
So these containers can talk to each other. 

- Let's see this in action. So, we're going to
bring up the application one more time, in the detach mode.

- Now look at the first line. Creating network with the default.
-------------------code----------------------
$ docker compose up -d
[+] Running 2/3
 ✔ api                    Built                                                                                                                    0.0s
[+] Running 6/6           Built                                                                                                                    0.0s
 ✔ api                    Built                                                                                                                    0.0s
 ✔ web                    Built
 ✔ Network vidly_default  Created                                                                                                                    0.0s  ✔ Network vidly_default  Created                                                                                                                  0.0s
 ✔ Container vidly-db-1   Started                                                                                                                  0.2s
 ✔ Container vidly-web-1  Started                                                                                                                  0.2s
 ✔ Container vidly-api-1  Started
-------------------code----------------------

- So, we can run we can run docker network ls.
Here we can see all the networks on this machine. every docker
installation has three networks, bridge, host, and none.
Honestly, we're not sure what these networks are for, but what matters here is
that we have a network called vidly default. The driver for this
network is bridge on Linux or NAT on Windows.
-------------------code----------------------
$ docker network ls
NETWORK ID     NAME            DRIVER    SCOPE
e76d9a0aa96a   bridge          bridge    local
057102070b84   host            host      local
31c759c4dfd4   none            null      local
e6721f786f9d   vidly_default   bridge    local
-------------------code----------------------

- Now, this network contains three hosts or three containers.
web, api, and db. So, these hosts or these containers
can talk to each other using their name.

- Let's see this in action. So, back to the terminal.
Let's look at the running containers. So we have mongo, web, and api.
Now we're going to start a shell session on the web container and ping the api container. Take a look.
So, we're going to execute in the interactive mode.
-------------------code----------------------
$ $ docker ps
CONTAINER ID   IMAGE              COMMAND                   CREATED         STATUS         PORTS                      NAMES
2892f53872a0   mongo:4.0-xenial   "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes   0.0.0.0:27017->27017/tcp   vidly-db-1
c0e0ef1c9e85   vidly-web          "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes   0.0.0.0:3000->3000/tcp     vidly-web-1
8003c7121fb2   vidly-api          "docker-entrypoint.s…"   3 minutes ago   Up 3 minutes   0.0.0.0:3001->3001/tcp     vidly-api-1
-------------------code----------------------

- The container ID is c0e and we're going to run shell. So, let's ping api. We get a permission error.
Because we have logged in with the app user.
-------------------code----------------------
$ docker exec -it c0e sh
/app $ ping api
PING api (172.21.0.3): 56 data bytes ping: permission denied (are You root?)
-------------------code----------------------

- That comes from our docker file. So, we have logged in with the app user
and this user doesn't have ping permission.
-------------------code----------------------

- we're going to bring up the last command.
Now here we have to use an extra option for setting the user.
We're going to log in as the root user.
Good. Now look at the shell prompt. We have a pound sign which means
we have the highest privileges. So, here we can ping api. Now look, we're getting responses
from a machine with this ip address.
Now on our machine, this ip might be different. Now, let's press ctrl and c
to get out of this. So, this is what happens under the hood.
Docker comes with an embedded DNS server that contains the name and
IP of these containers.
-------------------code----------------------
$ docker exec -it -u root c0e sh
/app # ping api
PING api (172.18.0.2): 56 data bytes
64 bytes from 172.18.0.2: seq=0 ttl=64 time=0.086 ms
64 bytes from 172.18.0.2: seq=1 ttl=64 time=0.134 ms
64 bytes from 172.18.0.2: seq=2 ttl=64 time=0.148 ms
64 bytes from 172.18.0.2: seq=3 ttl=64 time=0.180 ms
64 bytes from 172.18.0.2: seq=4 ttl=64 time=0.265 ms
64 bytes from 172.18.0.2: seq=5 ttl=64 time=0.186 ms
64 bytes from 172.18.0.2: seq=6 ttl=64 time=0.233 ms
64 bytes from 172.18.0.2: seq=7 ttl=64 time=0.158 ms
64 bytes from 172.18.0.2: seq=8 ttl=64 time=0.161 ms
-------------------code----------------------

- Now inside each container, we have a component
called the DNS resolver. This DNS resolver talks to
the DNS server to find the IP address of the target container.
So, when we ping the api container this DNS resolver
asks the server, what is the IP address of the api machine
or api container. The DNS server returns the IP address
and then the web container can directly talk to the api container
using its IP address. So, each container has an IP address and is part of a network.

- Let see one more thing. So, back to the terminal, here we can run
ifconfig to see the IP address of this container.
Take a look. So, this container has two network adapters.
One of them is ethernet 0
and over here, we can see the IP address of this container.
So, 172.18.0.3 is the IP address of the web container.
-------------------code----------------------
/app # ifconfig
eth0      Link encap:Ethernet  HWaddr C6:40:98:0C:5B:4E
          inet addr:172.18.0.3  Bcast:172.18.255.255  Mask:255.255.0.0
          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1
          RX packets:50 errors:0 dropped:0 overruns:0 frame:0
          TX packets:27 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:0
          RX bytes:4216 (4.1 KiB)  TX bytes:2254 (2.2 KiB)

lo        Link encap:Local Loopback
          inet addr:127.0.0.1  Mask:255.0.0.0
          inet6 addr: ::1/128 Scope:Host
          UP LOOPBACK RUNNING  MTU:65536  Metric:1
          RX packets:8 errors:0 dropped:0 overruns:0 frame:0
          TX packets:8 errors:0 dropped:0 overruns:0 carrier:0
          collisions:0 txqueuelen:1000
          RX bytes:430 (430.0 B)  TX bytes:430 (430.0 B)
-------------------code----------------------

- Now, back to our compose file, earlier when we defined the api
service, we added an environment variable that contains a database connection string.
In this connection string, we have db which is the name of a host.
That is the db host or the db container. You saw that. Our api container
can talk to this container because both these containers or all
containers in this application are part of the same network.
-------------------code----------------------
environment:
  DB_URL: mongodb://db/vidly
-------------------code----------------------

- Now, one thing we want we to understand here is that
this host is only available inside the docker environment.
So, if we open up my browser and go to localhost
slash db, we're not going to get anything. So, the api container
can directly talk to the db container, but if we
want to access this container, we need port mappings. And, that is
why we have this port mapping over here. So, this port on the host
is mapped to this port on the container. So, if we open up mongodb compass, which is
a popular mongodb client, we can establish a connection
to localhost port 27017. Because this port is mapped to our container.
-------------------code----------------------
ports:
  - 27017:27017
-------------------code----------------------

*** 10- Viewing Logs ***

- a few different techniques for viewing the logs. So if we type
docker compose logs, we can view the logs across
all containers of this application in one place.

- So, here we have some messages coming from our database
container. Above that We have some messages coming from our web container. And these are color coded,
-------------------code----------------------
$ docker compose logs
WARN[0000] 6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
web-1  |
web-1  | > vidly-frontend@0.1.0 start /app
web-1  | > react-scripts start
web-1  |
web-1  | ℹ ｢wds｣: Project is running at http://172.18.0.3/
web-1  | ℹ ｢wds｣: webpack output is served from
web-1  | ℹ ｢wds｣: Content not from webpack is served from /app/public
web-1  | ℹ ｢wds｣: 404s will fallback to /
web-1  | Starting the development server...
web-1  |
web-1  | Browserslist: caniuse-lite is outdated. Please run:
web-1  | npx browserslist@latest --update-db
web-1  |
web-1  | Why we should do it regularly:
web-1  | https://github.com/browserslist/browserslist#browsers-data-updating
web-1  | Compiled successfully!
web-1  |
web-1  | You can now view vidly-frontend in the browser.
web-1  |
web-1  |   Local:            http://localhost:3000
web-1  |   On Your Network:  http://172.18.0.3:3000
api-1  |
api-1  | > vidly-backend@1.0.0 start /app
api-1  | > nodemon --ignore './tests' index.js
api-1  |
api-1  | [nodemon] 2.0.7
api-1  | [nodemon] to restart at any time, enter `rs`
api-1  | [nodemon] watching path(s): *.*
api-1  | [nodemon] watching extensions: js,mjs,json
api-1  | [nodemon] starting `node index.js`
api-1  | Server started on port 3001...
api-1  | Connected to MongoDB: mongodb://db/vidly
api-1  | Connected to MongoDB: mongodb://db/vidly
db-1   | 2025-03-22T07:20:29.974+0000 CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'
db-1   | 2025-03-22T07:20:29.979+0000 CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=2892f53872a0
db-1   | 2025-03-22T07:20:29.979+0000 CONTROL  [initandlisten] db version v4.0.28
db-1   | 2025-03-22T07:20:29.979+0000 CONTROL  [initandlisten] git version: af1a9dc12adcfa83cc19571cb3faba26eeddac92
db-1   | 2025-03-22T07:20:29.979+0000 CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2g  1 Mar 2016
db-1   | 2025-03-22T07:20:29.980+0000 CONTROL  [initandlisten] allocator: tcmalloc
-------------------code----------------------

- Now, let's bring up this command and add
dash dash help at the end to view the available options.
Here we have the same options we talked about earlier in the course. So, using dash
f or follow, we can follow the log output so we can
continuously see new messages as they come out. Also, we can add a
timestamp using dash t.
-------------------code----------------------
$ docker compose logs --help
Usage:  docker compose logs [OPTIONS] [SERVICE...]

View output from containers

Options:
      --dry-run         Execute command in dry run mode
  -f, --follow          Follow log output
      --index int       index of the container if service has multiple replicas
      --no-color        Produce monochrome output
      --no-log-prefix   Don't print prefix in logs
      --since string    Show logs since timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
  -n, --tail string     Number of lines to show from the end of the logs for each container (default "all")
  -t, --timestamps      Show timestamps
      --until string    Show logs before a timestamp (e.g. 2013-01-02T13:23:37Z) or relative (e.g. 42m for 42 minutes)
-------------------code----------------------

- Now, what if we don't want to see the logs
for all these containers in one place? Some people have big monitors or
multiple monitors, they prefer to have different windows for different
container logs.
we look at the running containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE              COMMAND                   CREATED          STATUS         PORTS                      NAMES
c0fa488b27ed   mongo:4.0-xenial   "docker-entrypoint.s…"   14 seconds ago   Up 5 seconds   0.0.0.0:27017->27017/tcp   vidly-db-1
51981921887f   vidly-api          "docker-entrypoint.s…"   14 seconds ago   Up 5 seconds   0.0.0.0:3001->3001/tcp     vidly-api-1
5a5b9eeeabe1   vidly-web          "docker-entrypoint.s…"   14 seconds ago   Up 5 seconds   0.0.0.0:3000->3000/tcp     vidly-web-1
-------------------code----------------------

- Let's say we only want to look at the logs for our web container. So, we can say
docker logs, here's the container ID,
And of course, we can follow this log as well. So, here's the log for this container. We can put
this on a separate window or on a separate monitor. So, that's all about logs.
-------------------code----------------------
$ docker logs 5a5 -f
> vidly-frontend@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.18.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db

Why we should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating

> vidly-frontend@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.18.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Browserslist: caniuse-lite is outdated. Please run:
npx browserslist@latest --update-db

Why we should do it regularly:
https://github.com/browserslist/browserslist#browsers-data-updating
Compiled successfully!

You can now view vidly-frontend in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.18.0.3:3000
-------------------code----------------------

*** 11- Publishing Changes ***

- Alright, let's talk about publishing changes. So obviously we don't want to rebuild our application images every time we change our code.
So we're going to map our project directory like the backend directory
to the app directory inside our container exactly like before.
This way any changes we make in this directory are immediately visible inside our container.
And of course we have to do the same with the frontend directory separately.

- So, let's open up our compose file.
Here's the definition of our API service. In this definition
we're going to add a new property, volumes.
Now we can have one or more volume mappings, so here we need the list
or array syntax. Now here we can type a relative path.
So, starting from the current directory, we go to the backend directory
and map this to the app directory inside the container.
-------------------code----------------------
volumes:
  - ./backend:/app
-------------------code----------------------

- Now in contrast, earlier, when we started our containers manually
we had to type an absolute path. So there, we had to use this syntax to get the current working directory
and map it to the app directory.
-------------------code----------------------
docker run -v $(pwd):/app
-------------------code----------------------

- with compose files, we don't have to do this.
So, we can type a relative path.
-------------------code----------------------
api:
    build: ./backend
    ports:
      - 3001:3001
    environment:
      DB_URL: mongodb://db/vidly
    volumes:
      - ./backend:/app
-------------------code----------------------


- So that's pretty much all we have to do to share our source code with our container. 

- There's just one tiny problem. Let's go ahead and start our application.
So docker compose up, and we're not going to use the detached option
because we're going to encounter an error and we want to see that immediately.
So, let's bring up the application.
we saw the error. it says node mon not found.
-------------------code----------------------
$ docker compose up
WARN[0000] /6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 1/4
 ✔ Network vidly_default  Created                                                                                                                  0.0s
 ⠋ Container vidly-web-1  Creating                                                                                                                 0.0s
 ⠋ Container vidly-db-1   Creating                                                                                                                 0.0s
 ⠋ Container vidly-api-1  Creating                                                                                                                 0.0s
Error response from daemon: node mon not found
-------------------code----------------------

- What is this?
Well, node mon is one of the packages that our backend project is dependent on.
So, back to our project, here in the backend folder,
we have this package.json and if we pay close attention,
we can see under dev dependencies or development dependencies,
we have a dependency to node mon or node monitor. node mon is a utility
that watches all of our files and anytime it detects a change,
it restarts our node server.
-------------------code----------------------
"devDependencies": {
    "jest": "^26.6.3",
    "migrate-mongo": "^8.1.4",
    "nodemon": "^2.0.7",
    "supertest": "^6.1.3"
  }
-------------------code----------------------

- Now, this error is saying that node mon cannot be found.
Can we tell why? Here's the reason. In the backend folder,
we don't have the node modules folder. Right?
Because we haven't installed npm dependencies on this machine.
These dependencies were only installed inside the docker container.
But now that we're sharing our application's code with our container,
what the container sees is essentially this directory. And here we don't have the node modules folder.
So, back to the terminal, let's stop this by pressing ctrl and c.
First we go to the backend directory and run npm install.
We can also type npm i. All right.
All our dependencies are installed.
-------------------code----------------------
$ cd backend
$ npm i
npm WARN old lockfile
npm WARN old lockfile The package-lock.json file was created with an old version of npm,
npm WARN old lockfile so supplemental metadata must be fetched from the registry.
npm WARN old lockfile
npm WARN old lockfile This is a one-time fix-up, please be patient...
npm WARN old lockfile
npm WARN deprecated is-data-descriptor@0.1.4: Please upgrade to v0.1.5
npm WARN deprecated is-accessor-descriptor@0.1.6: Please upgrade to v0.1.7
npm WARN deprecated inflight@1.0.6: This module is not supported, and leaks memory. Do not use it. Check out lru-cache if we want a good and tested way to coalesce async requests by a key value, which is much more comprehensive and powerful.
npm WARN deprecated is-accessor-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-data-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-data-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-accessor-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-accessor-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-data-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-data-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated is-accessor-descriptor@1.0.0: Please upgrade to v1.0.1
npm WARN deprecated source-map-url@0.4.1: See https://github.com/lydell/source-map-url#deprecated
npm WARN deprecated request-promise-native@1.0.9: request-promise-native has been deprecated because it extends the now deprecated request package, see https://github.com/request/request/issues/3142
npm WARN deprecated urix@0.1.0: Please see https://github.com/lydell/urix#deprecated
npm WARN deprecated har-validator@5.1.5: this library is no longer supported
npm WARN deprecated rimraf@3.0.2: Rimraf versions prior to v4 are no longer supported
npm WARN deprecated abab@2.0.5: Use our platform's native atob() and btoa() methods instead
npm WARN deprecated resolve-url@0.2.1: https://github.com/lydell/resolve-url#deprecated
npm WARN deprecated source-map-resolve@0.5.3: See https://github.com/lydell/source-map-resolve#deprecated
npm WARN deprecated glob@7.1.6: Glob versions prior to v9 are no longer supported
npm WARN deprecated domexception@2.0.1: Use our platform's native DOMException instead
npm WARN deprecated w3c-hr-time@1.0.2: Use our platform's native performance.now() and performance.timeOrigin.
npm WARN deprecated sane@4.1.0: some dependency vulnerabilities fixed, support for node < 10 dropped, and newer ECMAScript syntax/features added
npm WARN deprecated uuid@3.4.0: Please upgrade  to version 7 or higher.  Older versions may use Math.random() in certain circumstances, which is known to be problematic.  See https://v8.dev/blog/math-random for details.
npm WARN deprecated formidable@1.2.2: Please upgrade to latest, formidable@v2 or formidable@v3! Check these notes: https://bit.ly/2ZEqIau
npm WARN deprecated request@2.88.2: request has been deprecated, see https://github.com/request/request/issues/3142
npm WARN deprecated superagent@6.1.0: Please upgrade to v9.0.0+ as we have fixed a public vulnerability with formidable dependency. Note that v9.0.0+ requires Node.js v14.18.0+. See https://github.com/ladjs/superagent/pull/1800 for insight. This project is supported and maintained by the team at Forward Email @ https://forwardemail.net

added 771 packages, and audited 772 packages in 10s

35 packages are looking for funding
  run `npm fund` for details

59 vulnerabilities (3 low, 33 moderate, 18 high, 5 critical)
-------------------code----------------------

- So, let's bring up the app one more time. All right.
Over here we can see node mon is starting our node process.
-------------------code----------------------
$ docker compose up
WARN[0000] /Users/mahmouddabbbagh/moody/Docker/The-Ultimate-Docker/6-Running_Multi-container_Applications/vidly/docker-compose.yml: the attribute `version` is obsolete, it will be ignored, please remove it to avoid potential confusion
[+] Running 1/1
 ✔ Container vidly-api-1  Created                                                                                                                  0.0s
Attaching to api-1, db-1, web-1
db-1   | 2025-03-23T05:59:20.606+0000 CONTROL  [main] Automatically disabling TLS 1.0, to force-enable TLS 1.0 specify --sslDisabledProtocols 'none'
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] MongoDB starting : pid=1 port=27017 dbpath=/data/db 64-bit host=0c87cfea2ecb
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] db version v4.0.28
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] git version: af1a9dc12adcfa83cc19571cb3faba26eeddac92
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] OpenSSL version: OpenSSL 1.0.2g  1 Mar 2016
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] allocator: tcmalloc
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] modules: none
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] build environment:
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten]     distmod: ubuntu1604
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten]     distarch: aarch64
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten]     target_arch: aarch64
db-1   | 2025-03-23T05:59:20.615+0000 CONTROL  [initandlisten] options: { net: { bindIpAll: true } }
db-1   | 2025-03-23T05:59:20.617+0000 STORAGE  [initandlisten] Detected data files in /data/db created by the 'wiredTiger' storage engine, so setting the active storage engine to 'wiredTiger'.
db-1   | 2025-03-23T05:59:20.617+0000 STORAGE  [initandlisten]
db-1   | 2025-03-23T05:59:20.617+0000 STORAGE  [initandlisten] ** WARNING: Using the XFS filesystem is strongly recommended with the WiredTiger storage engine
db-1   | 2025-03-23T05:59:20.617+0000 STORAGE  [initandlisten] **          See http://dochub.mongodb.org/core/prodnotes-filesystem
db-1   | 2025-03-23T05:59:20.617+0000 STORAGE  [initandlisten] wiredtiger_open config: create,cache_size=474M,cache_overflow=(file_max=0M),session_max=20000,eviction=(threads_min=4,threads_max=4),config_base=false,statistics=(fast),log=(enabled=true,archive=true,path=journal,compressor=snappy),file_manager=(close_idle_time=100000),statistics_log=(wait=0),verbose=(recovery_progress),
api-1  |
api-1  | > vidly-backend@1.0.0 start /app
api-1  | > nodemon --ignore './tests' index.js
api-1  |
web-1  |
web-1  | > vidly-frontend@0.1.0 start /app
web-1  | > react-scripts start
-------------------code----------------------

- So, let's go to our browser and head over to local host
port 3001 slash API.
This is like the homepage of our API. So, our API is running.
-------------------code----------------------
http://localhost:3001/api
-------------------code----------------------

- Now, let's make a small change in our code
and see if that change is visible here or not.
So, back to our project. Here in the backend folder,
let's go to route and then index.js. This is where we can change that message.
So, API is running. we're going to add a few exclamation marks,
save the changes.
- vidly/backend/routes/index.js
-------------------code----------------------
res.send("<h1>Api is running!!!!</h1>");
-------------------code----------------------


- Now, in the terminal, we can see node mon detected our change
and restarted our web server. So, back to the browser, refresh,
we can see the changes.

- Now, we can apply the same technique to our frontend project.
first we install the npm for the node
-------------------code----------------------
$ cd frontend
$ npm i
npm WARN old lockfile
npm WARN old lockfile The package-lock.json file was created with an old version of npm,
npm WARN old lockfile so supplemental metadata must be fetched from the registry.
npm WARN old lockfile
npm WARN old lockfile This is a one-time fix-up, please be patient...
-------------------code----------------------

- then we set the volumes
-------------------code----------------------
volumes:
  - ./frontend:/app
-------------------code----------------------
