*** 1- Introduction ***
- In this section we're going to explore containers in more detail. 

- We'll talk about starting and stopping containers,
publishing ports, viewing container logs, executing commands in running containers,
removing containers, persisting data using volumes, and sharing source code with containers
so we don't have to rebuild our image every time we make a change in our code.
-------------------code----------------------
• Starting & stopping containers
• Publishing ports
• Viewing logs
• Executing commands in containers
• Removing containers
• Persisting data using volumes
• Sharing source code
-------------------code----------------------

*** 2- Starting Containers ***

- Alright, we briefly talked about container commands throughout the course, so we're
already familiar with many of them.  

- In this section we're going to review them one more time,
but we're also going to give us some extra tips along the way. For starters, let's look at our images.
So we've cleaned up some of the images that we created in the previous section,
now we only have react app with the latest tag.
We also have ubuntu and alpine which we're not going to use in this section.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    0211703e719b   22 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- how can we see the running containers? Using docker what?
Docker ps, short for processes. Because a container is just a process,
but it's a special kind of process, because it has its own file system
which is provided by the image. Okay, currently there are no running
containers here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

-so we want to run a new container using the react
app image. This is going to start a development web server.
our web server is ready.
-------------------code----------------------
$ docker run react-app

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.2/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.2:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now there's a problem. we cannot type in additional commands
on the terminal window. If we press control and c to get out of this, our container stops.
Let's verify that. So docker ps, look, no container is running.there is a cool technique.
Let's bring up the run command one more time. Now this time we're going to use an option,
dash d, that is short for detached. With this, we can run this container in the detached mode,
which means in the background. 
-------------------code----------------------
$ docker run -d react-app
912a9f10ea9610b8ba341e5b434be9441f24b7cb571b8149f6d6f32ac6160d0a
-------------------code----------------------

- Now the terminal window is free, and we can do whatever we want. Of course,
the container is going to take a few seconds to start,
because that's the time we need for the web server to start.

- So that's one option. Now, let's look at the running processes.
So, here we have one container.
Here's my container ID. Now, if we look
on the far right column,  In the last column, we can see the names column.
So docker automatically associates each container with a random name.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 seconds ago   Up 22 seconds   3000/tcp   jolly_dewdney
-------------------code----------------------

- So in the future, when we want to reference a container,
we can either use its ID or its name. But we can also give our container a name when starting them.
So, let's start another container in detached mode.
This time we're going to use dash dash name to give it a name.
we're going to call this blue dash sky.
It's easier to work with than a randomly generated name by docker.
And we're going to use the react app image.
-------------------code----------------------
$ docker run -d --name blue-sky react-app
300b6cd7fa2d8a7ac2dbd4c9034b786a5dc19054df097e0875d05f78c138f59e
-------------------code----------------------

- So, let's look at the running containers.
Now we have two containers, and one of them is called blue sky.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------


*** 3- Viewing the Logs ***

- So now we have two containers running in the background, but there's a problem.
We don't know what is going on inside these containers. What if something goes wrong?
What if our server generates an error? That's where we need to use the log command.

- But first, let's bring up our running containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------

- So now we're going to look at the logs for this container. We type docker
logs and then the container id. Of course on our machine
the container id is different. So whatever it is, just type the first few letters.
Okay, so here we can see the output of our web server.
This is exactly the same output that we saw when we started this container in the foreground.
-------------------code----------------------
$ docker logs 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, this logs command has some additional
options. So as we told before, whenever we want to play with the docker command
always use dash dash help to learn about various options.
So one of the options here that is useful is dash dash f or follow. This is useful if our container is
continuously producing output. 
-------------------code----------------------
$ docker logs --help

Usage:  docker logs [OPTIONS] CONTAINER

Fetch the logs of a container

Aliases:
  docker container logs, docker logs

Options:
      --details        Show extra details provided to logs
  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
  -n, --tail string    Number of lines to show from the end of the logs (default "all")
  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
-------------------code----------------------

- So instead of running
docker logs, some container id multiple times, we can just
use dash f to follow the log. Then, whatever it is
written to the log, we can see it in real time on the terminal. Of course, we have to
press control and c to get out of that. 
-------------------code----------------------
$ docker logs -f 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Let's look at the other options. Another option
is dash n or tail and with this we can specify
the number of lines to show. This is useful
if we have a really long log. so we're going to use dash n
5 to look at the last 5 lines.
-------------------code----------------------
$ docker logs -n 5 300
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, what if we want to see time stamps? We can
use dash t. So, dash t
and now we see the time stamp in front of each message. 
-------------------code----------------------
$ docker logs -n 5 -t 300
2025-03-21T03:36:58.554288887Z   On Your Network:  http://172.17.0.3:3000
2025-03-21T03:36:58.554335720Z
2025-03-21T03:36:58.554337512Z Note that the development build is not optimized.
2025-03-21T03:36:58.554417887Z To create a production build, use yarn build.
2025-03-21T03:36:58.554419262Z
-------------------code----------------------

- So, if we encounter any issues when running our
applications inside docker, the first thing we want to look at is the logs.

*** 4- Publishing Ports ***

- So currently we have two containers running our react application. But if we go to local host, port
3000, we cannot access this application. why?
Because as we told earlier, port 3000 is published on the container,
not on the host. So on the same machine we have multiple containers,
each of these containers is listening on port 3000, but the host itself
is not listening on this port. So this port is currently closed.
There is no way to send traffic into local host at this port.
This is where we need to publish a port. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- So first of all, let's look at our running containers. Now here we have a column called
ports. Here's the ports column. In this column, we can see the ports and their mapping.
As we can see, both these containers are listening to port
3000. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   18 minutes ago   Up 18 minutes   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   19 minutes ago   Up 19 minutes   3000/tcp   jolly_dewdney
-------------------code----------------------

- Now we're going to start a new container and publish a port
at the same time. So just like before, we run docker run dash d for detached.
Here we're going to use another option called
p that is for port. We're going to publish a port
on the host. Let's say port 3000 to port 3000 of the container.
-------------------code----------------------
$ docker run -d -p 3000:3000
-------------------code----------------------

- And of course, these numbers don't have to be the same.
So we can publish port 80 of the host to port 3000 of this container.
-------------------code----------------------
$ docker run -d -p 80:3000
-------------------code----------------------

- Now we can give this container a name so we can identify it. we're going to call this
C1. Now,  react-app, So this is going to take a few seconds
until our web server is ready.
-------------------code----------------------
$ docker run -d -p 80:3000 --name c1 react-app
ae66a7d9157e0b8fcc49aa02d30981a74ac585df544cffc85cc80a20a228372c
-------------------code----------------------

- Now if we go to local host, port 80, we can see our react application.
-------------------code----------------------
localhost:80
-------------------code----------------------

- Now, let's look at the running containers one more time.
Now look at the port mapping for our C1 container.
You can see port 80 of the host is mapped to port 3000
of the container. We do not have this notation for other containers.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS                  NAMES
ae66a7d9157e   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:80->3000/tcp   c1
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   20 minutes ago       Up 20 minutes       3000/tcp               blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 minutes ago       Up 22 minutes       3000/tcp               jolly_dewdney
-------------------code----------------------


*** 5- Executing Commands in Running Containers ***

- So we'll learn that when we start a container, it executes the
default command that we specified in our docker file. Now what if we want to
execute a command in a running container later on. Let's say we want to troubleshoot
something and we want to look at the file system of that container.

- how to do that. So, we have docker exec or
execute and with this we can execute a command in a running container.
-------------------code----------------------
docker exec
-------------------code----------------------

- Now some people say, what is the difference between docker exec and
docker run. With docker run we start a new container
and run a command, whereas with docker exec we execute a command
in a running container.
-------------------code----------------------
docker exec -->  execute a command in a running container
docker run  --> start a new container
-------------------code----------------------

- Now for this we're going to use my C1 container, this is the benefit of using friendly names.
Now what do we want to execute here? We can type any commands, any operating system
commands. So this can be Linux commands or Windows commands. Let's
run ls here. Now we can see the content of our app directory.
But why the app directory? Here's the answer. Because
earlier in our docker file we set the working directory to the app directory. So
when we run ls, we see the content of this directory.
-------------------code----------------------
$ docker exec c1 ls
Dockerfile
README.md
node_modules
package-lock.json
package.json
public
src
yarn.lock
-------------------code----------------------

- Now using the same command, we can open up a shell session. So we can
say docker exec. We want to do this in the interactive mode
so we can interact with it. Our container
is C1 and the shell we want to run is sh.
-------------------code----------------------
$ docker exec -it c1 sh
/app $
-------------------code----------------------
- So now we have a shell session inside this container. We can
run ls, we can run print working directory. We can do anything
we want. Now when we are done, we type exit and this doesn't
impact the state of our container.
-------------------code----------------------
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public             yarn.lock
/app $ pwd
/app
/app $ exit
-------------------code----------------------

- Our container is still running. Let's verify it.
Docker ps. So, our C1 container is the first item we see here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS                  NAMES
ae66a7d9157e   react-app   "docker-entrypoint.s…"   11 minutes ago   Up 11 minutes   0.0.0.0:80->3000/tcp   c1
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   30 minutes ago   Up 30 minutes   3000/tcp               blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   31 minutes ago   Up 31 minutes   3000/tcp               jolly_dewdney
-------------------code----------------------

- So using the exec command, we can execute any commands in a running container.


*** 6- Stopping and Starting Containers ***

- Earlier in the course we told we that a container is like a lightweight
virtual machine. So it can be stopped and then restarted.

- Let's see this in action. So we're going to stop our C1 container.
-------------------code----------------------
$ docker stop c1
c1
-------------------code----------------------

- Now let's verify that it's not running. It's not running anymore. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   37 minutes ago   Up 37 minutes   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   38 minutes ago   Up 38 minutes   3000/tcp   jolly_dewdney
-------------------code----------------------

- So now if we go back to our browser and refresh this page, look, our application is not available.
Because that container that was serving this application is no longer running.
It's stopped.


- So we need to bring it back up. And that is very easy.
We just type docker start C1. 
-------------------code----------------------
$ docker start c1
c1
-------------------code----------------------

- Now what is the difference between docker start
and docker run? With docker run we start a new container
whereas with docker start, we start a stopped container.
-------------------code----------------------
docker start -->  start an stopped container
docker run   -->  start a new container
-------------------code----------------------

*** 7- Removing Containers ***

- There are two ways to remove a container. We can type docker container remove
and then specify the name.
-------------------code----------------------
$ docker container rm c1
-------------------code----------------------

- or we can use the shortcut docker remove.
-------------------code----------------------
$ docker rm c1
-------------------code----------------------

- So, let's go with that. We get an error saying we cannot remove a
running container.
-------------------code----------------------
$ docker rm c1
Error response from daemon: cannot remove container "/c1": container is running: stop the container before removing or force remove
-------------------code----------------------

- So here we have two options. One option is to stop the
container and then remove it. The other option is to use the force option.
So, if we want to force the removal, we bring up the last command
and add dash f.
-------------------code----------------------
$ docker rm -f c1
c1
-------------------code----------------------

- Now that container is gone. So, let's look at the running containers. It's
definitely not here. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- Now, how can we see the stop containers? docker ps dash all.
Now, even though we have a bunch of containers here, that container, c1
is not in this list. 
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS                   PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours               3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours               3000/tcp   jolly_dewdney
7d0af46635b3   react-app   "docker-entrypoint.s…"   2 hours ago   Exited (0) 2 hours ago              cranky_bardeen
-------------------code----------------------

- Now, let see cool trick. Let's say we have so many containers here and we only want to look at c1. Here we can use piping.
We talked about piping Linux commands
earlier in the course. So, we can say docker ps dash a
here we type a pipe and then use grep to filter by c1.
Of course, this only works on Linux.
So, let's go with that. Look, we don't have a stop container
called c1.
-------------------code----------------------
$ docker ps -a | grep c1
-------------------code----------------------



- Now, here we also have the prune command. So, docker
container prune and with this we can get rid of all the stop containers
in one go. Take a look.
-------------------code----------------------
$ docker container prune
WARNING! This will remove all stopped containers.
Are You sure You want to continue? [y/N] y
Deleted Containers:
7d0af46635b34a19cea76ec2b638527e50e931db7cbefed4a0693293dbeddb04

Total reclaimed space: 4.558MB
-------------------code----------------------

- So, let's look at the running containers
one more time.
Two containers here 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- and all containers, two containers.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------


*** 8- Containers File System ***

- Earlier in the course we told we that each container has its own file system
that is invisible to other containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- So let's do a quick experiment. First, we look at the running containers. So
on this machine we'm running two containers.

- Then, we want we to start a shell session on the first container
and write something to a file in the application directory. Then start
a new shell session on the second container and see if that file is there or not.


- We're going to run docker exec
in the interactive mode. The container id is 300
and we're going to run shell. Now here in the app directory we'm going to
echo data to data.txt.
-------------------code----------------------
$ docker exec -it 300 sh
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public 
/app $ echo data > data.txt
/app $ ls
Dockerfile         data.txt          package-lock.json  public             yarn.lock
README.md          node_modules       package.json       src            yarn.lock
-------------------code----------------------

- Now we'm going to terminate this session
and start a new shell session on the second container. by checking 
the ls command, we can see data.txt is not here
because each container has its own file system that is invisible
to other containers. 
-------------------code----------------------
$ docker exec -it 912 sh
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public             yarn.lock
-------------------code----------------------

- And that means if we delete this container, its file system will also go with it
and we'll lose our data. So we should never store our data in a container's file system.
That's what volumes are for.
