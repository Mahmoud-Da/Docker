*** 1- Introduction ***
- In this section we're going to explore containers in more detail. 

- We'll talk about starting and stopping containers,
publishing ports, viewing container logs, executing commands in running containers,
removing containers, persisting data using volumes, and sharing source code with containers
so we don't have to rebuild our image every time we make a change in our code.
-------------------code----------------------
• Starting & stopping containers
• Publishing ports
• Viewing logs
• Executing commands in containers
• Removing containers
• Persisting data using volumes
• Sharing source code
-------------------code----------------------

*** 2- Starting Containers ***

- Alright, we briefly talked about container commands throughout the course, so we're
already familiar with many of them.  

- In this section we're going to review them one more time,
but we're also going to give us some extra tips along the way. For starters, let's look at our images.
So we've cleaned up some of the images that we created in the previous section,
now we only have react app with the latest tag.
We also have ubuntu and alpine which we're not going to use in this section.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    0211703e719b   22 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- how can we see the running containers? Using docker what?
Docker ps, short for processes. Because a container is just a process,
but it's a special kind of process, because it has its own file system
which is provided by the image. Okay, currently there are no running
containers here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

-so we want to run a new container using the react
app image. This is going to start a development web server.
our web server is ready.
-------------------code----------------------
$ docker run react-app

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.2/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.2:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now there's a problem. we cannot type in additional commands
on the terminal window. If we press control and c to get out of this, our container stops.
Let's verify that. So docker ps, look, no container is running.there is a cool technique.
Let's bring up the run command one more time. Now this time we're going to use an option,
dash d, that is short for detached. With this, we can run this container in the detached mode,
which means in the background. 
-------------------code----------------------
$ docker run -d react-app
912a9f10ea9610b8ba341e5b434be9441f24b7cb571b8149f6d6f32ac6160d0a
-------------------code----------------------

- Now the terminal window is free, and we can do whatever we want. Of course,
the container is going to take a few seconds to start,
because that's the time we need for the web server to start.

- So that's one option. Now, let's look at the running processes.
So, here we have one container.
Here's my container ID. Now, if we look
on the far right column,  In the last column, we can see the names column.
So docker automatically associates each container with a random name.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 seconds ago   Up 22 seconds   3000/tcp   jolly_dewdney
-------------------code----------------------

- So in the future, when we want to reference a container,
we can either use its ID or its name. But we can also give our container a name when starting them.
So, let's start another container in detached mode.
This time we're going to use dash dash name to give it a name.
we're going to call this blue dash sky.
It's easier to work with than a randomly generated name by docker.
And we're going to use the react app image.
-------------------code----------------------
$ docker run -d --name blue-sky react-app
300b6cd7fa2d8a7ac2dbd4c9034b786a5dc19054df097e0875d05f78c138f59e
-------------------code----------------------

- So, let's look at the running containers.
Now we have two containers, and one of them is called blue sky.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------


*** 3- Viewing the Logs ***

- So now we have two containers running in the background, but there's a problem.
We don't know what is going on inside these containers. What if something goes wrong?
What if our server generates an error? That's where we need to use the log command.

- But first, let's bring up our running containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------

- So now we're going to look at the logs for this container. We type docker
logs and then the container id. Of course on our machine
the container id is different. So whatever it is, just type the first few letters.
Okay, so here we can see the output of our web server.
This is exactly the same output that we saw when we started this container in the foreground.
-------------------code----------------------
$ docker logs 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, this logs command has some additional
options. So as we told before, whenever we want to play with the docker command
always use dash dash help to learn about various options.
So one of the options here that is useful is dash dash f or follow. This is useful if our container is
continuously producing output. 
-------------------code----------------------
$ docker logs --help

Usage:  docker logs [OPTIONS] CONTAINER

Fetch the logs of a container

Aliases:
  docker container logs, docker logs

Options:
      --details        Show extra details provided to logs
  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
  -n, --tail string    Number of lines to show from the end of the logs (default "all")
  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
-------------------code----------------------

- So instead of running
docker logs, some container id multiple times, we can just
use dash f to follow the log. Then, whatever it is
written to the log, we can see it in real time on the terminal. Of course, we have to
press control and c to get out of that. 
-------------------code----------------------
$ docker logs -f 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Let's look at the other options. Another option
is dash n or tail and with this we can specify
the number of lines to show. This is useful
if we have a really long log. so we're going to use dash n
5 to look at the last 5 lines.
-------------------code----------------------
$ docker logs -n 5 300
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, what if we want to see time stamps? We can
use dash t. So, dash t
and now we see the time stamp in front of each message. 
-------------------code----------------------
$ docker logs -n 5 -t 300
2025-03-21T03:36:58.554288887Z   On Your Network:  http://172.17.0.3:3000
2025-03-21T03:36:58.554335720Z
2025-03-21T03:36:58.554337512Z Note that the development build is not optimized.
2025-03-21T03:36:58.554417887Z To create a production build, use yarn build.
2025-03-21T03:36:58.554419262Z
-------------------code----------------------

- So, if we encounter any issues when running our
applications inside docker, the first thing we want to look at is the logs.

*** 4- Publishing Ports ***

- So currently we have two containers running our react application. But if we go to local host, port
3000, we cannot access this application. why?
Because as we told earlier, port 3000 is published on the container,
not on the host. So on the same machine we have multiple containers,
each of these containers is listening on port 3000, but the host itself
is not listening on this port. So this port is currently closed.
There is no way to send traffic into local host at this port.
This is where we need to publish a port. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- So first of all, let's look at our running containers. Now here we have a column called
ports. Here's the ports column. In this column, we can see the ports and their mapping.
As we can see, both these containers are listening to port
3000. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   18 minutes ago   Up 18 minutes   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   19 minutes ago   Up 19 minutes   3000/tcp   jolly_dewdney
-------------------code----------------------

- Now we're going to start a new container and publish a port
at the same time. So just like before, we run docker run dash d for detached.
Here we're going to use another option called
p that is for port. We're going to publish a port
on the host. Let's say port 3000 to port 3000 of the container.
-------------------code----------------------
$ docker run -d -p 3000:3000
-------------------code----------------------

- And of course, these numbers don't have to be the same.
So we can publish port 80 of the host to port 3000 of this container.
-------------------code----------------------
$ docker run -d -p 80:3000
-------------------code----------------------

- Now we can give this container a name so we can identify it. we're going to call this
C1. Now,  react-app, So this is going to take a few seconds
until our web server is ready.
-------------------code----------------------
$ docker run -d -p 80:3000 --name c1 react-app
ae66a7d9157e0b8fcc49aa02d30981a74ac585df544cffc85cc80a20a228372c
-------------------code----------------------

- Now if we go to local host, port 80, we can see our react application.
-------------------code----------------------
localhost:80
-------------------code----------------------

- Now, let's look at the running containers one more time.
Now look at the port mapping for our C1 container.
You can see port 80 of the host is mapped to port 3000
of the container. We do not have this notation for other containers.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS                  NAMES
ae66a7d9157e   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:80->3000/tcp   c1
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   20 minutes ago       Up 20 minutes       3000/tcp               blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 minutes ago       Up 22 minutes       3000/tcp               jolly_dewdney
-------------------code----------------------


*** 5- Executing Commands in Running Containers ***

- So we'll learn that when we start a container, it executes the
default command that we specified in our docker file. Now what if we want to
execute a command in a running container later on. Let's say we want to troubleshoot
something and we want to look at the file system of that container.

- how to do that. So, we have docker exec or
execute and with this we can execute a command in a running container.
-------------------code----------------------
docker exec
-------------------code----------------------

- Now some people say, what is the difference between docker exec and
docker run. With docker run we start a new container
and run a command, whereas with docker exec we execute a command
in a running container.
-------------------code----------------------
docker exec -->  execute a command in a running container
docker run  --> start a new container
-------------------code----------------------

- Now for this we're going to use my C1 container, this is the benefit of using friendly names.
Now what do we want to execute here? We can type any commands, any operating system
commands. So this can be Linux commands or Windows commands. Let's
run ls here. Now we can see the content of our app directory.
But why the app directory? Here's the answer. Because
earlier in our docker file we set the working directory to the app directory. So
when we run ls, we see the content of this directory.
-------------------code----------------------
$ docker exec c1 ls
Dockerfile
README.md
node_modules
package-lock.json
package.json
public
src
yarn.lock
-------------------code----------------------

- Now using the same command, we can open up a shell session. So we can
say docker exec. We want to do this in the interactive mode
so we can interact with it. Our container
is C1 and the shell we want to run is sh.
-------------------code----------------------
$ docker exec -it c1 sh
/app $
-------------------code----------------------
- So now we have a shell session inside this container. We can
run ls, we can run print working directory. We can do anything
we want. Now when we are done, we type exit and this doesn't
impact the state of our container.
-------------------code----------------------
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public             yarn.lock
/app $ pwd
/app
/app $ exit
-------------------code----------------------

- Our container is still running. Let's verify it.
Docker ps. So, our C1 container is the first item we see here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS                  NAMES
ae66a7d9157e   react-app   "docker-entrypoint.s…"   11 minutes ago   Up 11 minutes   0.0.0.0:80->3000/tcp   c1
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   30 minutes ago   Up 30 minutes   3000/tcp               blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   31 minutes ago   Up 31 minutes   3000/tcp               jolly_dewdney
-------------------code----------------------

- So using the exec command, we can execute any commands in a running container.


*** 6- Stopping and Starting Containers ***

- Earlier in the course we told we that a container is like a lightweight
virtual machine. So it can be stopped and then restarted.

- Let's see this in action. So we're going to stop our C1 container.
-------------------code----------------------
$ docker stop c1
c1
-------------------code----------------------

- Now let's verify that it's not running. It's not running anymore. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   37 minutes ago   Up 37 minutes   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   38 minutes ago   Up 38 minutes   3000/tcp   jolly_dewdney
-------------------code----------------------

- So now if we go back to our browser and refresh this page, look, our application is not available.
Because that container that was serving this application is no longer running.
It's stopped.


- So we need to bring it back up. And that is very easy.
We just type docker start C1. 
-------------------code----------------------
$ docker start c1
c1
-------------------code----------------------

- Now what is the difference between docker start
and docker run? With docker run we start a new container
whereas with docker start, we start a stopped container.
-------------------code----------------------
docker start -->  start an stopped container
docker run   -->  start a new container
-------------------code----------------------

*** 7- Removing Containers ***

- There are two ways to remove a container. We can type docker container remove
and then specify the name.
-------------------code----------------------
$ docker container rm c1
-------------------code----------------------

- or we can use the shortcut docker remove.
-------------------code----------------------
$ docker rm c1
-------------------code----------------------

- So, let's go with that. We get an error saying we cannot remove a
running container.
-------------------code----------------------
$ docker rm c1
Error response from daemon: cannot remove container "/c1": container is running: stop the container before removing or force remove
-------------------code----------------------

- So here we have two options. One option is to stop the
container and then remove it. The other option is to use the force option.
So, if we want to force the removal, we bring up the last command
and add dash f.
-------------------code----------------------
$ docker rm -f c1
c1
-------------------code----------------------

- Now that container is gone. So, let's look at the running containers. It's
definitely not here. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- Now, how can we see the stop containers? docker ps dash all.
Now, even though we have a bunch of containers here, that container, c1
is not in this list. 
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS                   PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours               3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours               3000/tcp   jolly_dewdney
7d0af46635b3   react-app   "docker-entrypoint.s…"   2 hours ago   Exited (0) 2 hours ago              cranky_bardeen
-------------------code----------------------

- Now, let see cool trick. Let's say we have so many containers here and we only want to look at c1. Here we can use piping.
We talked about piping Linux commands
earlier in the course. So, we can say docker ps dash a
here we type a pipe and then use grep to filter by c1.
Of course, this only works on Linux.
So, let's go with that. Look, we don't have a stop container
called c1.
-------------------code----------------------
$ docker ps -a | grep c1
-------------------code----------------------



- Now, here we also have the prune command. So, docker
container prune and with this we can get rid of all the stop containers
in one go. Take a look.
-------------------code----------------------
$ docker container prune
WARNING! This will remove all stopped containers.
Are You sure You want to continue? [y/N] y
Deleted Containers:
7d0af46635b34a19cea76ec2b638527e50e931db7cbefed4a0693293dbeddb04

Total reclaimed space: 4.558MB
-------------------code----------------------

- So, let's look at the running containers
one more time.
Two containers here 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- and all containers, two containers.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------


*** 8- Containers File System ***

- Earlier in the course we told we that each container has its own file system
that is invisible to other containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED       STATUS       PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   2 hours ago   Up 2 hours   3000/tcp   jolly_dewdney
-------------------code----------------------

- So let's do a quick experiment. First, we look at the running containers. So
on this machine we'm running two containers.

- Then, we want we to start a shell session on the first container
and write something to a file in the application directory. Then start
a new shell session on the second container and see if that file is there or not.


- We're going to run docker exec
in the interactive mode. The container id is 300
and we're going to run shell. Now here in the app directory we'm going to
echo data to data.txt.
-------------------code----------------------
$ docker exec -it 300 sh
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public 
/app $ echo data > data.txt
/app $ ls
Dockerfile         data.txt          package-lock.json  public             yarn.lock
README.md          node_modules       package.json       src            yarn.lock
-------------------code----------------------

- Now we'm going to terminate this session
and start a new shell session on the second container. by checking 
the ls command, we can see data.txt is not here
because each container has its own file system that is invisible
to other containers. 
-------------------code----------------------
$ docker exec -it 912 sh
/app $ ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public             yarn.lock
-------------------code----------------------

- And that means if we delete this container, its file system will also go with it
and we'll lose our data. So we should never store our data in a container's file system.
That's what volumes are for.


*** 9- Persisting Data using Volumes *** 


- Let's talk about volumes. A volume is a storage outside of containers.
It can be a directory on the host or somewhere in the cloud.

- So let's see how we can work with volumes. We have this command
docker volume that has a bunch of subcommands. So we can create volumes,
we can inspect them, we can list them, we can also prune and remove them. 
-------------------code----------------------
$ docker volume

Usage:  docker volume COMMAND

Manage volumes

Commands:
  create      Create a volume
  inspect     Display detailed information on one or more volumes
  ls          List volumes
  prune       Remove unused local volumes
  rm          Remove one or more volumes

Run 'docker volume COMMAND --help' for more information on a command.
-------------------code----------------------

- So let's create a new volume
called app data. And of course we can call it anything, it doesn't really matter.
Now let's inspect this volume. So docker volume inspect app data. Here we have
a bunch of properties, we can see when this volume was created,
we can see the driver which is local by default, that means this is a
directory on the host. 
-------------------code----------------------
$ docker volume create app-data
app-data
-------------------code----------------------

- we also have drivers for creating volumes in the
cloud. So if we use a cloud platform, we need to do our own research and
find a driver for creating a volume in that cloud platform.
-------------------code----------------------
$ docker volume inspect app-data
[
    {
        "CreatedAt": "2025-03-21T06:24:19Z",
        "Driver": "local",
        "Labels": null,
        "Mountpoint": "/var/lib/docker/volumes/app-data/_data",
        "Name": "app-data",
        "Options": null,
        "Scope": "local"
    }
]
-------------------code----------------------

Now look at mount point. This is where that
directory is created on the host. So this is a Linux path.
If we're on Windows, we would probably see something like C drive backslash
program files, whatever. Now a note for my Mac users,
earlier in the course we told hat docker on Mac runs inside a lightweight
Linux virtual machine. So this path that we see here is a path inside that virtual machine.
It doesn't exist on our Mac. So if we try to go to this directory, we're not
going to find anything.
-------------------code----------------------
"/var/lib/docker/volumes/app-data/_data"
-------------------code----------------------

- So now we have a volume. Let's see how we can
start a container and give it this volume for persisting data. So
docker run, we're going to run it in detached mode. we're going to map, let's say port
4000 of the host to port 3000 of the container. Now we're going to use a new option,
dash v for volume. We're going to map app data to a directory
in the file system of the container. So here we type a colon
followed by an absolute path in the file system of the container.
So we can go to slash app slash data.
-------------------code----------------------
$ docker run -d -p 4000:3000 -v app-data:/app/data
-------------------code----------------------

- Now we don't have to explicitly create this volume
before running this command. So if we type
a new volume here, docker will automatically create it.
-------------------code----------------------
docker run -d -p 4000:3000 -v app-data2:/app/data
-------------------code----------------------

- The same is true for this directory. Currently we don't have a data directory
inside our app directory. So docker will automatically create this.
But there is a problem with this, we'll talk about it in a second.
So we give it a volume and then the image, react app.
-------------------code----------------------
$ docker run -d -p 4000:3000 -v app-data:/app/data react-app
e138b68920de354756867ac2c4be2a9e79edbbff663329bb93c0e1040f2ad364
-------------------code----------------------

- So here's our container ID. Let's start a shell session.
So docker exec interactive, e13 shell.Now, let's go to the data directory and write
something to a file. So data to data.txt. We get a permission error.
-------------------code----------------------
$ docker exec -it e13 sh
/app $ cd data/
/app/data $ echo data > data.txt
sh: can't create data.txt: Permission denied
-------------------code----------------------

- why this is happening? 
Let's go out of this directory and get a long listing.
So, here's our data directory. Now look at the owner
of this directory. It's the root user. And over here,
as we can see, the owner is the only user that has
write permission. So the app user, which is the user that
runs our app, belongs to the others group, and in this group we don't
have a write permission.
-------------------code----------------------
/app/data $ cd ..
/app $ ls -l
total 1304
-rw-r--r--    1 root     root           207 Mar 20 04:31 Dockerfile
-rw-r--r--    1 root     root          3366 Mar 20 05:56 README.md
drwxr-xr-x    2 root     root          4096 Mar 21 06:24 data
drwxr-xr-x    1 app      app           4096 Mar 21 06:27 node_modules
-rw-r--r--    1 root     root        819126 Mar 20 04:07 package-lock.json
-rw-r--r--    1 root     root           813 Mar 20 04:07 package.json
drwxr-xr-x    2 root     root          4096 Mar 20 04:12 public
drwxr-xr-x    2 root     root          4096 Mar 20 04:12 src
-rw-r--r--    1 root     root        485703 Mar 20 04:07 yarn.lock
-------------------code----------------------

- The reason we're facing this issue is because we let
docker automatically create this directory
for us. So to prevent this from happening, we have to go to our
docker file. So back to our docker file, after
we create the app directory, we're going to run, make their
data. We're going to create this directory using the
app user that we said earlier in this file. With this,
this directory will be owned by this user and it will automatically have
the right permission.
-------------------code----------------------
USER app
WORKDIR /app
RUN mkdir data
-------------------code----------------------

- But now we have
to rebuild our image because we have modified our docker file.
-------------------code----------------------
app +[master] $ docker build -t react-app .
[+] Building 33.6s (12/12) FINISHED                                                                                                docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 299B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         0.8s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/7] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 1.79kB                                                                                                                0.0s
 => CACHED [2/7] RUN addgroup app && adduser -S -G app app                                                                                         0.0s
 => CACHED [3/7] WORKDIR /app                                                                                                                      0.0s
 => [4/7] RUN mkdir data                                                                                                                           0.1s
 => [5/7] COPY package*.json .                                                                                                                     0.0s
 => [6/7] RUN npm install                                                                                                                         28.2s
 => [7/7] COPY . .                                                                                                                                 0.0s
 => exporting to image                                                                                                                             4.4s
 => => exporting layers                                                                                                                            4.4s
 => => writing image sha256:d63e19272668b1d5fe42f33e1bef69b77f1ee11d565f5d324cf4ce4b33c2468e                                                       0.0s
 => => naming to docker.io/library/react-app                                                                                                       0.0s
-------------------code----------------------

- now let's start a new container. docker run dash t,
this time we're going to use a different port mapping, let's say port
5000 of the host to 3000 of the container. And for volume,
we're going to map app data to slash app slash data.
But this time, the data directory already exists
inside the file system of this container and the app user owns
this directory.
-------------------code----------------------
$ docker run -d -p 5000:3000 -v app-data:/app/data react-app
e1c9962056ab49f47218f03e26d4c321efa6fcc3b17a33d816da739c5f994613
docker: Error response from daemon: Ports are not available: 
exposing port TCP 0.0.0.0:5000 -> 127.0.0.1:0: listen tcp 0.0.0.0:5000: bind: 
address already in use.
-------------------code----------------------

- we have error cause other application using the 5000 port 
to check of ports is busy
-------------------code----------------------
$ lsof -i :5000
-------------------code----------------------

- so we another port in this case 5001 
-------------------code----------------------
$ docker run -d -p 5001:3000 -v app-data:/app/data react-app
3bf2e3622fb5a9fbd330ec4499b83402fc9c44d7e74be4cb9715ede89a48fade
-------------------code----------------------

- Now let's run a shell session inside this container. So
docker exec interactive 3bf shell. and we check the permission of the data directory 
-------------------code----------------------
$ docker exec -it 3bf sh
/app $ cd data
/app/data $ cd ..
/app $ ls -l
total 1244
-rw-r--r--    1 root     root           223 Mar 21 06:43 Dockerfile
-rw-r--r--    1 root     root          3367 Mar 21 03:28 README.md
drwxr-xr-x    2 app      app           4096 Mar 21 06:43 data
drwxr-xr-x    1 app      app           4096 Mar 21 06:44 node_modules
-rw-r--r--    1 root     root        778804 Mar 21 03:44 package-lock.json
-rw-r--r--    1 root     root           813 Mar 21 03:28 package.json
drwxr-xr-x    2 root     root          4096 Mar 21 06:31 public
drwxr-xr-x    2 root     root          4096 Mar 21 06:31 src
-rw-r--r--    1 root     root        462014 Mar 21 03:44 yarn.lock
-------------------code----------------------

- Now let's go to the data directory and write something using echo.
-------------------code----------------------
/app/data $ echo data > data.txt
/app/data $ cat data.txt
data
-------------------code----------------------

-  Now here's the beauty of volumes.
If we delete this container, this file will still exist.
Because this directory is stored outside of this container. It's actually
a directory on the host.

- Let's see that in action. So,
we're going to exit and remove this container. So remove
dash force, we have to force it because this container is still running.
-------------------code----------------------
$ docker rm -f 3bf
3bf
-------------------code----------------------

- Now let's start a new container with the same
volume mapping. So this is a brand new container.
-------------------code----------------------
$ docker run -d -p 5001:3000 -v app-data:/app/data react-app
1f0feff2e67310995bcfccf7e8693bb2a1a77165284cb9d9c000a3f845076077
-------------------code----------------------

Now we're going to run a shell session here. So docker exec interactive
1f0 shell. Let's go to the data directory
and list. Look, our data file is here.
-------------------code----------------------
$ docker exec -it 1f0 sh
/app $ cd data
/app/data $ ls
data.txt
-------------------code----------------------

- So volumes are the right way to persist data in dockerize applications
because they have different life cycles from containers. If we delete a container
the associated volume is not deleted. It still exists.
Also, we can share a volume amongst multiple containers.

**** 10- Copying Files between the Host and Containers ***

- Sometimes we need to copy files between the host and a container.
For example, let's say we have this log file in our container and we want to bring it
to the host and analyze it.

- So, let's look at the running containers. Alright, we're going to go to this first container and create a
log file in the application directory. Then we're going to copy that file
from the container to the host. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE          COMMAND                   CREATED          STATUS          PORTS                    NAMES
1f0feff2e673   react-app      "docker-entrypoint.s…"   21 minutes ago   Up 21 minutes   0.0.0.0:5001->3000/tcp   goofy_turing
300b6cd7fa2d   0211703e719b   "docker-entrypoint.s…"   4 hours ago      Up 4 hours      3000/tcp                 blue-sky
912a9f10ea96   0211703e719b   "docker-entrypoint.s…"   4 hours ago      Up 4 hours      3000/tcp                 jolly_dewdney
-------------------code----------------------

- So, let's run docker exec interactive shell.
Now here in the app directory, we're going to echo hello to log.txt.
-------------------code----------------------
$ docker exec -it 1f0 sh
/app $ echo hello > log.txt
/app $ ls
Dockerfile         data               node_modules       package.json       src
README.md          log.txt            package-lock.json  public             yarn.lock
-------------------code----------------------

- So we have this log file inside the app directory, inside the container, and we want to copy it to the host. Let me show we how
to do this. First, let's get out of here. Now docker
has a copy command for this. Here we need to specify a source
and a destination. In this case, our source is the container.
Now here we add a colon and then type the full path to a file or directory. So, we're going to go to our
app directory and copy log.txt to where we use a period to reference the current directory in the
host, which is our project directory.
-------------------code----------------------
$ docker cp 1f0:app/log.txt .
Successfully copied 2.05kB to Docker/The-Ultimate-Docker/5-Working_with_Containers/app/.
-------------------code----------------------

- now, let's list the files. So, here's our log file.
-------------------code----------------------
$ ls
Dockerfile		log.txt			package-lock.json	public			yarn.lock
README.md		node_modules		package.json		src
-------------------code----------------------

-  Now we can also copy a file from the host to a container.
So, let's create a secret file here and copy it to the container.
And of course, this only works on Linux to the best of my knowledge.
If we're on Windows, we can just create a file using our favorite text editor.
Now we have a file in our project directory in the host,
and this file is not part of our version control system. It's not part of our
Git repository.
-------------------code----------------------
$ echo hello > secret.txt
$ ls
Dockerfile		log.txt			package-lock.json	public			src
README.md		node_modules		package.json		secret.txt		yarn.lock
-------------------code----------------------

- So we want to manually copy this file into the container.
So, we're going to copy the container name one more time.
So one more time, docker copy. Now this time the source
is secret.txt and the destination is the container followed by a colon and the path, slash
app.
-------------------code----------------------
$ docker cp secret.txt 1f0:app/
Successfully copied 2.05kB to 1f0:app/
-------------------code----------------------

- Now, let's run a shell session
and list all the files. So, here's our secret
file inside the container's file system.
-------------------code----------------------
$ docker exec -it 1f0 sh
/app $ ls | grep secret.txt
secret.txt
-------------------code----------------------

*** 11- Sharing the Source Code with a Container ***

- So we have this react application available at local host port
5000. Now let's see how we can publish our application changes.
So, back to VS code, we're going to go to the public directory
and open index.html. Here we're going to update the title
of this app to dockerized react app.
- /app/public/index.html
-------------------code----------------------
<title>Dockerized React App</title>
-------------------code----------------------

- This title is what we see in the browser window. So let's save the changes.
Now back in the browser, if we refresh, we don't see anything. We still
see the old title.

- So what should we do here? Well, for production machines, we should always build a new image, tag it properly
and then deploy it. We'll talk about that later when we get to the deployment section.
But what about development machines? We don't want to rebuild the image every time
we make a tiny change in our code. That's just too time consuming. Now we might
say, what about copying? Well, that's a pain in the butt as well. We don't
want to manually copy files from our development machine into a container
every time we change our code. 
-------------------code----------------------
• For production: build a new image
• For development
    Build a new image -> not good practice
    Copy files X      -> not good practice
-------------------code----------------------

- So there is a cool trick. We can create
a mapping or a binding between a directory on the host and a directory
inside the container. So this way, any changes we make to any files
in this directory are immediately visible inside the container.

- So back to the terminal, we're going to start a new container.
docker run dash d this time we're going to use a different port so we can distinguish it.
We're going to map this port to port 3000. Now earlier we used
a volume mapping, so we mapped the app data volume to slash app slash data directory inside
the container.
-------------------code----------------------
docker run -d -p 5002:3000 -v app-data:/app/data
-------------------code----------------------

- Now using the same syntax, we can map a directory on the host to a directory inside the container. So
instead of using a named volume which is a directory that docker manages
we're going to use the current directory, the directory that
holds our application. So we don't want to type the full path here
this is where we use the pwd command, print working directory.
Now if we execute this command as is, docker thinks
this is a named volume. We don't want that, we want a full path.
-------------------code----------------------
docker run -d -p 5002:3000 -v pwd:/app/data
-------------------code----------------------

- So we're going to wrap this with a dollar sign and put it in parenthesis.
-------------------code----------------------
docker run -d -p 5002:3000 -v $(pwd):/app
-------------------code----------------------

- Now when we execute this command, this
part of the command will be evaluated first and the result will be a full path
to the current working directory. Then we're going to map this to, not the data
directory, we're going to map it to the app directory inside the container.


- Now what about a named volume? Well we can still add
another option and use a named volume here if we want to, but this react
application doesn't really store anything on the
disk, it doesn't have a database, it's just a basic frontend application. So
we don't need a named volume here.

- So, our web server is ready, so let's go to localhost
port 5002. Alright. We can certainly see the updated title.
Now, let's make one more change to the application's code.
So we're going to add an exclamation mark at the end. Save the changes.
-------------------code----------------------
<title>Dockerized App!</title>
-------------------code----------------------

- Now back in the browser, we didn't even
have to refresh. Look, we've got the exclamation mark here. Because in
React we have this feature called hot reloading, so whenever we change any of our files,
our application gets automatically
reloaded in the browser.

- So, to share our source code with the container, once again we use the
volume option to map the project directory to a directory in the
containers file system. 

- Now we might say, running applications
with docker is a pain in the ass. We have to remember all these options
and type them every time we want to run an application. No, we don't.
In the next section, we're going to talk about docker compose and we will see how
easy it is to bring up an application with multiple components.
we had to cover all these commands and options so when we get to the next section,
we know exactly how docker compose works under the hood. 
