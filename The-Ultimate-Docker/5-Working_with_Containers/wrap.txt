*** 1- Introduction ***
- In this section we're going to explore containers in more detail. 

- We'll talk about starting and stopping containers,
publishing ports, viewing container logs, executing commands in running containers,
removing containers, persisting data using volumes, and sharing source code with containers
so we don't have to rebuild our image every time we make a change in our code.
-------------------code----------------------
• Starting & stopping containers
• Publishing ports
• Viewing logs
• Executing commands in containers
• Removing containers
• Persisting data using volumes
• Sharing source code
-------------------code----------------------

*** 2- Starting Containers ***

- Alright, we briefly talked about container commands throughout the course, so we're
already familiar with many of them.  

- In this section we're going to review them one more time,
but we're also going to give us some extra tips along the way. For starters, let's look at our images.
So we've cleaned up some of the images that we created in the previous section,
now we only have react app with the latest tag.
We also have ubuntu and alpine which we're not going to use in this section.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED        SIZE
react-app    latest    0211703e719b   22 hours ago   482MB
alpine       latest    8d591b0b7dea   5 weeks ago    8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago    101MB
-------------------code----------------------

- how can we see the running containers? Using docker what?
Docker ps, short for processes. Because a container is just a process,
but it's a special kind of process, because it has its own file system
which is provided by the image. Okay, currently there are no running
containers here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

-so we want to run a new container using the react
app image. This is going to start a development web server.
our web server is ready.
-------------------code----------------------
$ docker run react-app

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.2/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.2:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now there's a problem. we cannot type in additional commands
on the terminal window. If we press control and c to get out of this, our container stops.
Let's verify that. So docker ps, look, no container is running.there is a cool technique.
Let's bring up the run command one more time. Now this time we're going to use an option,
dash d, that is short for detached. With this, we can run this container in the detached mode,
which means in the background. 
-------------------code----------------------
$ docker run -d react-app
912a9f10ea9610b8ba341e5b434be9441f24b7cb571b8149f6d6f32ac6160d0a
-------------------code----------------------

- Now the terminal window is free, and we can do whatever we want. Of course,
the container is going to take a few seconds to start,
because that's the time we need for the web server to start.

- So that's one option. Now, let's look at the running processes.
So, here we have one container.
Here's my container ID. Now, if we look
on the far right column,  In the last column, we can see the names column.
So docker automatically associates each container with a random name.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 seconds ago   Up 22 seconds   3000/tcp   jolly_dewdney
-------------------code----------------------

- So in the future, when we want to reference a container,
we can either use its ID or its name. But we can also give our container a name when starting them.
So, let's start another container in detached mode.
This time we're going to use dash dash name to give it a name.
we're going to call this blue dash sky.
It's easier to work with than a randomly generated name by docker.
And we're going to use the react app image.
-------------------code----------------------
$ docker run -d --name blue-sky react-app
300b6cd7fa2d8a7ac2dbd4c9034b786a5dc19054df097e0875d05f78c138f59e
-------------------code----------------------

- So, let's look at the running containers.
Now we have two containers, and one of them is called blue sky.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------


*** 3- Viewing the Logs ***

- So now we have two containers running in the background, but there's a problem.
We don't know what is going on inside these containers. What if something goes wrong?
What if our server generates an error? That's where we need to use the log command.

- But first, let's bring up our running containers. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   1 second ago         Up 1 second         3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   3000/tcp   jolly_dewdney
-------------------code----------------------

- So now we're going to look at the logs for this container. We type docker
logs and then the container id. Of course on our machine
the container id is different. So whatever it is, just type the first few letters.
Okay, so here we can see the output of our web server.
This is exactly the same output that we saw when we started this container in the foreground.
-------------------code----------------------
$ docker logs 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, this logs command has some additional
options. So as we told before, whenever we want to play with the docker command
always use dash dash help to learn about various options.
So one of the options here that is useful is dash dash f or follow. This is useful if our container is
continuously producing output. 
-------------------code----------------------
$ docker logs --help

Usage:  docker logs [OPTIONS] CONTAINER

Fetch the logs of a container

Aliases:
  docker container logs, docker logs

Options:
      --details        Show extra details provided to logs
  -f, --follow         Follow log output
      --since string   Show logs since timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
  -n, --tail string    Number of lines to show from the end of the logs (default "all")
  -t, --timestamps     Show timestamps
      --until string   Show logs before a timestamp (e.g. "2013-01-02T13:23:37Z") or relative (e.g. "42m" for 42 minutes)
-------------------code----------------------

- So instead of running
docker logs, some container id multiple times, we can just
use dash f to follow the log. Then, whatever it is
written to the log, we can see it in real time on the terminal. Of course, we have to
press control and c to get out of that. 
-------------------code----------------------
$ docker logs -f 300

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.3/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Let's look at the other options. Another option
is dash n or tail and with this we can specify
the number of lines to show. This is useful
if we have a really long log. so we're going to use dash n
5 to look at the last 5 lines.
-------------------code----------------------
$ docker logs -n 5 300
  On Your Network:  http://172.17.0.3:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- Now, what if we want to see time stamps? We can
use dash t. So, dash t
and now we see the time stamp in front of each message. 
-------------------code----------------------
$ docker logs -n 5 -t 300
2025-03-21T03:36:58.554288887Z   On Your Network:  http://172.17.0.3:3000
2025-03-21T03:36:58.554335720Z
2025-03-21T03:36:58.554337512Z Note that the development build is not optimized.
2025-03-21T03:36:58.554417887Z To create a production build, use yarn build.
2025-03-21T03:36:58.554419262Z
-------------------code----------------------

- So, if we encounter any issues when running our
applications inside docker, the first thing we want to look at is the logs.

*** 4- Publishing Ports ***

- So currently we have two containers running our react application. But if we go to local host, port
3000, we cannot access this application. why?
Because as we told earlier, port 3000 is published on the container,
not on the host. So on the same machine we have multiple containers,
each of these containers is listening on port 3000, but the host itself
is not listening on this port. So this port is currently closed.
There is no way to send traffic into local host at this port.
This is where we need to publish a port. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- So first of all, let's look at our running containers. Now here we have a column called
ports. Here's the ports column. In this column, we can see the ports and their mapping.
As we can see, both these containers are listening to port
3000. 
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED          STATUS          PORTS      NAMES
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   18 minutes ago   Up 18 minutes   3000/tcp   blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   19 minutes ago   Up 19 minutes   3000/tcp   jolly_dewdney
-------------------code----------------------

- Now we're going to start a new container and publish a port
at the same time. So just like before, we run docker run dash d for detached.
Here we're going to use another option called
p that is for port. We're going to publish a port
on the host. Let's say port 3000 to port 3000 of the container.
-------------------code----------------------
$ docker run -d -p 3000:3000
-------------------code----------------------

- And of course, these numbers don't have to be the same.
So we can publish port 80 of the host to port 3000 of this container.
-------------------code----------------------
$ docker run -d -p 80:3000
-------------------code----------------------

- Now we can give this container a name so we can identify it. we're going to call this
C1. Now,  react-app, So this is going to take a few seconds
until our web server is ready.
-------------------code----------------------
$ docker run -d -p 80:3000 --name c1 react-app
ae66a7d9157e0b8fcc49aa02d30981a74ac585df544cffc85cc80a20a228372c
-------------------code----------------------

- Now if we go to local host, port 80, we can see our react application.
-------------------code----------------------
localhost:80
-------------------code----------------------

- Now, let's look at the running containers one more time.
Now look at the port mapping for our C1 container.
You can see port 80 of the host is mapped to port 3000
of the container. We do not have this notation for other containers.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE       COMMAND                   CREATED              STATUS              PORTS                  NAMES
ae66a7d9157e   react-app   "docker-entrypoint.s…"   About a minute ago   Up About a minute   0.0.0.0:80->3000/tcp   c1
300b6cd7fa2d   react-app   "docker-entrypoint.s…"   20 minutes ago       Up 20 minutes       3000/tcp               blue-sky
912a9f10ea96   react-app   "docker-entrypoint.s…"   22 minutes ago       Up 22 minutes       3000/tcp               jolly_dewdney
-------------------code----------------------
