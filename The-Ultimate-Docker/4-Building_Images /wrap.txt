*** 1- Introduction ***
The first step in using Docker to build and deploy applications is creating images. 
So having a solid understanding of Docker images is crucial for us. And that's what this section is all about.

- We'll be talking about creating Docker files, versioning images, sharing them, saving and
loading them, and a few optimization techniques for reducing the image size and speeding up builds.

In this section:
-------------------code----------------------
• Creating Docker files
• Versioning images
• Sharing images
• Saving and loading images
• Reducing the image size
• Speeding up builds
-------------------code----------------------

*** 2- Images and Containers ***

Alright, before we get started, let's make sure we have the right understanding of
images and containers. 
- Can we define what an image is, and how it's different from a container? 
An image includes everything
an application needs to run. So, it contains a cut down
operating system, like Linux or Windows. It also contains third party libraries,
application files, environment variables and so on. So, an image
contains all the files and configuration settings needed to run
an application. Once we have an image, we can start a container from it.
-------------------code----------------------
IMAGE
• A cut-down OS
• Third-party libraries
• Application files
• Environment variables
-------------------code----------------------

- A container is kind of like a virtual machine in the sense that it provides
an isolated environment for executing an application. And similar
to virtual machines, we can stop and restart containers. Now
technically, a container is just an operating system process, but it's a
special kind of process because it has its own file system which is provided
by the image.
-------------------code----------------------
CONTAINER
• Provides an isolated environment
• Can be stopped & restarted
• Is just a process!
-------------------code----------------------

-  Now, In the previous section we started a container from the Ubuntu image. Now we're going to
open up another terminal window. 
-------------------code----------------------
~  $ docker start -i 8a6
root@8a65a7f2dd58:/#
-------------------code----------------------

- Let's run docker ps to see the running processes or running containers.
So here's the container that we started in the previous section.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED        STATUS          PORTS     NAMES
8a65a7f2dd58   ubuntu    "/bin/bash"   14 hours ago   Up 45 seconds             eloquent_lichterman
-------------------code----------------------
PS: start command to start and exist container

- Now we're going to start a new container from the same image.
We type docker run, we want to run this in the interactive mode so we can work with it. And then we type
the name of the image, so Ubuntu.
-------------------code----------------------
~  $ docker run -it ubuntu
root@17e332c0bbd7:/#
-------------------code----------------------
PS: to create new container and start it

- here's the container ID and as we can see, this is different from
this other container. Now, back to our first container, we're currently
inside the home directory. So in the previous section we created
a bunch of directories and this deployment file.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
c315081d7859   ubuntu    "/bin/bash"   2 seconds ago    Up 1 second               charming_mccarthy
17e332c0bbd7   ubuntu    "/bin/bash"   24 seconds ago   Up 23 seconds             blissful_albattani
-------------------code----------------------

- Now, back to our new container, let's go to the home directory
and see what is here. There's nothing here. Here's the reason. A container gets its file system
from the image, but each container has its own write layer. So what we write in a given container
is invisible from other containers.
-------------------code----------------------
root@17e332c0bbd7:/# cd home/
root@17e332c0bbd7:/home# ls
ubuntu
-------------------code----------------------

- Of course, there is a way to share data between containers and we'll talk about that later in the course.
But what we want to understand here
is that each container is an isolated environment for executing an application.
It's an isolated universe. So whatever happens inside that universe
is invisible to other containers.

*** 3- Sample Web Application ***

- So over the next few lessons, we're going to take a front-end application built with
React and package it into a docker image. 

- To run this project on a new machine, first we have to
install node, then using npm we have to install third party dependencies
and finally, to start the project we have to type npm start. 
-------------------code----------------------
STEPS
• Install Node
• npm install
• npm start
-------------------code----------------------

- We have the same concept in other development stacks. So
whether we use C sharp or java or python or ruby, we have some tool to manage
the dependencies of our application and then we have a way to start our application.

- Here we have to use npm start. So, let's go ahead. This started at development server
listening on port 3000. So if we go to localhost port
3000, we can see our react application. This is just a basic react application
like a brand new project. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- we haven't done anything here and it doesn't really matter.
Later in the course, we're going to show we a real project that we have built using react
and node. So now that we understand what this project is and how we can
run it on a new machine, let's see how we can
use docker so we don't have to repeat all these steps every time we want to deploy
this on a new machine.

*** 4- Dockerfile Instructions ***
- The first step to dockerize an application is adding a docker file to it.

- what is a docker file?
It contains instructions for building an image.
we saw a few of these instructions before, but let's go through the complete list so we know what is available.
We have from for specifying the base image, so we take that base image
which contains a bunch of files and directories and then we build on top of it.
Then we have workdir for specifying the working directory. Once we use this command,
all the following commands will be executed in the current working directory.
We have copy and add for copying files and directories.
We have run for executing operating system commands. So all the Linux commands
that we talked about in the previous section, we can execute them using run.
Now, if we're on Windows, we can execute Windows commands using run as well.
We have env for setting environment variables, expose for text.
for telling docker that our container is starting on a given port.
User for specifying the user that should run the application.
Typically, we want to run our application using a user with limited privileges.
And we have command and entry point for specifying the command that should be executed
when we start a container. So that's the big picture.
-------------------code----------------------
DOCKERFILE
• FROM                 • ENV
• WORKDIR              • EXPOSE
• COPY                 • USER
• ADD                  • CMD
• RUN                  • ENTRYPOINT
-------------------code----------------------

Now, over the next few lessons, we're going to explore each of these commands in detail.
Pull our basic commands in detail.

*** 5- Choosing the Right Base Image ***

- Alright, let's start off by adding a dockerfile to this project. So,
here in the root of this project, we're going to add a new file called dockerfile.
Now the first instruction we're going to use is from, which we use for specifying the base image. The base image can be an
operating system like Linux or Windows or it can be an operating system
plus a runtime environment. 

- For example, if we're a C sharp developer, we want to start from a dotnet image. If we're a python developer,
we want to start from a python image. If we're a javascript developer, we want to start
from a node image. Now if we google docker samples, we can find
this page.
-------------------code----------------------
docs.docker.com/samples/
-------------------code----------------------

- in the left menu, we can see various examples of docker files for different technology
stacks. For example, for an aspen.net core application,
we can see a docker file. Now look at the from instruction. Over here, we have a full url
instead of an image. Because microsoft images are not hosted on docker
hub. They're hosted in microsoft container registry. That's why we have
MCR, which is short for microsoft container registry.
So an image can be in any registries. The default registry that docker
uses is docker hub. For any images, in other registries,
we have to type the full url. 
-------------------code----------------------
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build-env
-------------------code----------------------

- Now, don't just blindly take this url. Because the url can change, or the version
can change. So always do our own research. So that's one example.
If we're a Django developer, we want to start from
python 3. Or in the future, we might want to use
python 4. Now what about this project? Well, for this project,
we need node. Because as we saw, we need
npm to install the application dependencies and start the application. 

- So let's go to hub.docker.com and search for node.
-------------------code----------------------
hub.docker.com
-------------------code----------------------

- Now this is where things get a little bit interesting.
Because node repository on docker hub has hundreds of node images.
And this can be a little bit confusing. So, let's go to the tags.
Here we can see various node images. So if we scroll down, we can see there are
tons of node images for different versions built on
different versions of Linux.
For example, we have node version 14.16.0
on top of buster which, if we're not wrong, is
Debian Linux version 10.

- So we have different versions of node on different
versions of Linux. The image we should choose really depends on our application.
What version of node do we want to target? We can go to our docker file
and say, we want to start from node and by default, docker
assumes the latest tag. Do not ever use this.
Because if we build our application against the latest version of node, next time there is
a new version of node, if we rebuild our application's image, our application will
be built with a different version of node
and things can get unpredictable. So always use a specific version.
-------------------code----------------------
FROM node:latest
-------------------code----------------------

- So, back to docker hub. Let's say we want to build this application
against node version 14. So here we search for 14. Now once again we have
tens or maybe hundreds of node images for version 14.
Here's one we just talked about. There is more.
We have version 14 on top of buster. So this one doesn't have
the minor build number. It's just a major version number.
Now look at the size of this image. It's around 300 megabytes.
And why do we have multiple items in this list? Well, this image is built
for different operating system and CPU architectures.
So, there's two more here. As we can see, all of these
are built on top of Linux. So as far as we know, we don't have a node image
built on top of Windows. we could be wrong. But if we want to run on top of Windows,
we have to start from a Windows image and then install node on top of it.
There's no reason we want to do this
because Windows images are really large. we think they're over 2 gigabytes.

- So, back to the story. Depending on our CPU architecture,
when we pull an image, docker will automatically download the right docker image
for our CPU architecture, Now, we don't want to use any of these images
because these are way too large. And this is the compressed size.
When this is uncompressed, it's going to be around 1 gigabyte.
we want to go for a smaller image and deployments faster.

- So, on this page, let's search for Alpine.
Earlier we told we that, Alpine images are really small.
Look at this. The compressed size is around 40 megabytes.
This image is almost 10 times smaller than the other image we saw.
Now look at the image tag. It's very specific.
Version 14.16.0 of node, built on top of
Alpine 3.13. we're happy with this version, so we're going to copy this.
And then paste it after the FROM.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
-------------------code----------------------

- So that was the first step.
Now, back to our terminal window, here in the project directory, we're going to build an image.
So, we run docker build dash t for tagging the image.
We're going to call this image react app
and we type a period to tell docker where it can find a docker file.
That means in the current directory.
-------------------code----------------------
docker build -t react-app .
-------------------code----------------------

- Let's go ahead. Okay, the image was built.
So now, we're going to look at all the images
we have on this machine using docker images or docker image ls.
So currently we have three images.
Here's the image that we just built.
-------------------code----------------------
REPOSITORY     TAG       IMAGE ID       CREATED        SIZE
hello-docker   latest    817ba4c523a5   27 hours ago   160MB
<none>         <none>    8af7922e7fd1   27 hours ago   160MB
ubuntu         latest    c3d1a3432580   7 weeks ago    101MB
react-app      latest    322425dfa4aa   3 years ago    116MB
-------------------code----------------------


- Now let's start a container with this image
and see what happens. So docker run, we want to run this in the interactive mode
so we can play with it and the image is react app.
-------------------code----------------------
~  $ docker run -it react-app
Welcome to Node.js v14.16.0.
Type ".help" for more information.
>
-------------------code----------------------

- What's going on here? We're inside a node environment.
So here we can write javascript code and node will execute it.
For example, we can define a constant and then log the constant.
-------------------code----------------------
> const x = 1
undefined
> console.log(x)
1
-------------------code----------------------

- So we're inside a node environment.
We don't want this. We want to run bash
so we can look at the file system. So we press control and see.
Now it says to exit, press control and see one more time.
So the container is stopped. Let's run it one more time.
So docker run interactive react app. Now at the end,
we can specify the command to run
when starting this container. We want to run bash.
Now look. We get an error saying
this module is not found. Why is that?
Because alpine Linux doesn't come with bash. That's why it's a very small
Linux distribution. So it doesn't have many of the utilities
we're familiar with. 
-------------------code----------------------
~  $ docker run -it react-app bash
internal/modules/cjs/loader.js:883
  throw err;
  ^

Error: Cannot find module '/bash'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15)
    at Function.Module._load (internal/modules/cjs/loader.js:725:27)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
    at internal/main/run_main_module.js:17:47 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
-------------------code----------------------

- Instead of bash, it comes with shell. The original shell program.
So one more time. Docker run interactive
react app. Instead of bash, we're going to use shell.
-------------------code----------------------
~  $ docker run -it react-app sh
/ # ls
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
-------------------code----------------------

- Now we're doing a shell session inside this container.
So let's look around. We have all these directors we're familiar with.
So this is alpine Linux and in this image we also have node.
So if we type node dash dash version, we can see the version of node
which is 14.16.0.

- Now in this image we don't have our application files.
We only have alpine Linux and node. So in the next lesson we're going to show we
how to copy application files into this image.
-------------------code----------------------
/ # node --version
v14.16.0
-------------------code----------------------

