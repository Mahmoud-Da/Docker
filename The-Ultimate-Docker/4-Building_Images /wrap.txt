*** 1- Introduction ***
The first step in using Docker to build and deploy applications is creating images. 
So having a solid understanding of Docker images is crucial for us. And that's what this section is all about.

- We'll be talking about creating Docker files, versioning images, sharing them, saving and
loading them, and a few optimization techniques for reducing the image size and speeding up builds.

In this section:
-------------------code----------------------
• Creating Docker files
• Versioning images
• Sharing images
• Saving and loading images
• Reducing the image size
• Speeding up builds
-------------------code----------------------

*** 2- Images and Containers ***

Alright, before we get started, let's make sure we have the right understanding of
images and containers. 
- Can we define what an image is, and how it's different from a container? 
An image includes everything
an application needs to run. So, it contains a cut down
operating system, like Linux or Windows. It also contains third party libraries,
application files, environment variables and so on. So, an image
contains all the files and configuration settings needed to run
an application. Once we have an image, we can start a container from it.
-------------------code----------------------
IMAGE
• A cut-down OS
• Third-party libraries
• Application files
• Environment variables
-------------------code----------------------

- A container is kind of like a virtual machine in the sense that it provides
an isolated environment for executing an application. And similar
to virtual machines, we can stop and restart containers. Now
technically, a container is just an operating system process, but it's a
special kind of process because it has its own file system which is provided
by the image.
-------------------code----------------------
CONTAINER
• Provides an isolated environment
• Can be stopped & restarted
• Is just a process!
-------------------code----------------------

-  Now, In the previous section we started a container from the Ubuntu image. Now we're going to
open up another terminal window. 
-------------------code----------------------
~  $ docker start -i 8a6
root@8a65a7f2dd58:/#
-------------------code----------------------

- Let's run docker ps to see the running processes or running containers.
So here's the container that we started in the previous section.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED        STATUS          PORTS     NAMES
8a65a7f2dd58   ubuntu    "/bin/bash"   14 hours ago   Up 45 seconds             eloquent_lichterman
-------------------code----------------------
PS: start command to start and exist container

- Now we're going to start a new container from the same image.
We type docker run, we want to run this in the interactive mode so we can work with it. And then we type
the name of the image, so Ubuntu.
-------------------code----------------------
~  $ docker run -it ubuntu
root@17e332c0bbd7:/#
-------------------code----------------------
PS: to create new container and start it

- here's the container ID and as we can see, this is different from
this other container. Now, back to our first container, we're currently
inside the home directory. So in the previous section we created
a bunch of directories and this deployment file.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
c315081d7859   ubuntu    "/bin/bash"   2 seconds ago    Up 1 second               charming_mccarthy
17e332c0bbd7   ubuntu    "/bin/bash"   24 seconds ago   Up 23 seconds             blissful_albattani
-------------------code----------------------

- Now, back to our new container, let's go to the home directory
and see what is here. There's nothing here. Here's the reason. A container gets its file system
from the image, but each container has its own write layer. So what we write in a given container
is invisible from other containers.
-------------------code----------------------
root@17e332c0bbd7:/# cd home/
root@17e332c0bbd7:/home# ls
ubuntu
-------------------code----------------------

- Of course, there is a way to share data between containers and we'll talk about that later in the course.
But what we want to understand here
is that each container is an isolated environment for executing an application.
It's an isolated universe. So whatever happens inside that universe
is invisible to other containers.

*** 3- Sample Web Application ***

- So over the next few lessons, we're going to take a front-end application built with
React and package it into a docker image. 

- To run this project on a new machine, first we have to
install node, then using npm we have to install third party dependencies
and finally, to start the project we have to type npm start. 
-------------------code----------------------
STEPS
• Install Node
• npm install
• npm start
-------------------code----------------------

- We have the same concept in other development stacks. So
whether we use C sharp or java or python or ruby, we have some tool to manage
the dependencies of our application and then we have a way to start our application.

- Here we have to use npm start. So, let's go ahead. This started at development server
listening on port 3000. So if we go to localhost port
3000, we can see our react application. This is just a basic react application
like a brand new project. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- we haven't done anything here and it doesn't really matter.
Later in the course, we're going to show we a real project that we have built using react
and node. So now that we understand what this project is and how we can
run it on a new machine, let's see how we can
use docker so we don't have to repeat all these steps every time we want to deploy
this on a new machine.

*** 4- Dockerfile Instructions ***
- The first step to dockerize an application is adding a docker file to it.

- what is a docker file?
It contains instructions for building an image.
we saw a few of these instructions before, but let's go through the complete list so we know what is available.
We have from for specifying the base image, so we take that base image
which contains a bunch of files and directories and then we build on top of it.
Then we have workdir for specifying the working directory. Once we use this command,
all the following commands will be executed in the current working directory.
We have copy and add for copying files and directories.
We have run for executing operating system commands. So all the Linux commands
that we talked about in the previous section, we can execute them using run.
Now, if we're on Windows, we can execute Windows commands using run as well.
We have env for setting environment variables, expose for text.
for telling docker that our container is starting on a given port.
User for specifying the user that should run the application.
Typically, we want to run our application using a user with limited privileges.
And we have command and entry point for specifying the command that should be executed
when we start a container. So that's the big picture.
-------------------code----------------------
DOCKERFILE
• FROM                 • ENV
• WORKDIR              • EXPOSE
• COPY                 • USER
• ADD                  • CMD
• RUN                  • ENTRYPOINT
-------------------code----------------------

Now, over the next few lessons, we're going to explore each of these commands in detail.
Pull our basic commands in detail.
