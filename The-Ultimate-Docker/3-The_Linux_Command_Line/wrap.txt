*** 1- Introduction ***
All right, the next stop in our journey is the Linux command line.

- But why Linux? What if we're a Windows user?
Well, we still need to know a bit of Linux for a number of reasons.
For starters, Docker has its foundations built on top of basic Linux concepts.
So if we want to be productive and troubleshoot issues easily,
we need to know some of the basic Linux commands.

- Also, most tutorials online are based on Linux commands.
So if we don't understand these basic commands, we're not going to get far.
learning Linux is like learning English.
so everybody should know some English these days.
we don't need to speak it or write a book in it, but we need to understand it.
So unless we're a power Linux user, do not skip this section.
It's going to be super easy and extremely useful.
So let's jump in and get started.

*** 2- Linux Distributions ***

- Let's start off this section by talking about Linux distributions, 
also called Linux distros.

- So, as we probably know, Linux is open source software.
And for this reason, many individuals and communities
have created their own version of Linux called Linux distributions.

- Each of these distributions is made to fit specialized needs
like running servers, desktop computers, mobile phones and so on.

- So we have Ubuntu, which is one of the most popular Linux distributions.
We also have Debian, Alpine, which we briefly talked about, it's a very small Linux distribution.

- We also have Fedora, CentOS and so on.

- Believe it or not, there are more than a thousand Linux distributions out there.

- Now, most of these distributions support pretty much the same set of commands,
but sometimes we might discover differences along the way. So be aware of that.

- In this section, we're going to use Ubuntu Linux because it's one of the most popular distributions.
But if we have a preference for another distribution, that's totally fine.

*** 3- Running Linux ***
Alright, let's see how we can run Ubuntu on this machine.

- So, we go to hub.docker.com 
-------------------code----------------------
https://hub.docker.com/
-------------------code----------------------


- and search for Ubuntu. Over here we can see the official Ubuntu image
that's been downloaded more than 10 million times. 


- Let's have a quick look here.
So, for each image, we can see the command to pull
that image onto our machine.
-------------------code----------------------
$ docker pull ubuntu
-------------------code----------------------

- Now in this lesson, we're not going to use the pull command,
we're going to show we a shortcut. So, here in the terminal, instead of
running docker pull Ubuntu, we're going to run docker run Ubuntu.
-------------------code----------------------
$ docker run ubuntu
-------------------code----------------------

- Now, if we have this image
locally, docker is going to store the container with this image, otherwise
it's going to pull this image behind the scene and then store the container. 

- see, docker is unable to find this image locally, and now it's pulling it from docker hop.
-------------------code----------------------
$ docker run ubuntu
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
5b17151e9710: Pull complete
Digest: sha256:72297848456d5d37d1262630108ab308d3e9ec7ed1c3286a32fe09856619a782
Status: Downloaded newer image for ubuntu:latest
-------------------code----------------------

- Now, what happened? Well, docker started a container,
but because we didn't interact with this container, the container stopped.

- to prove this. So, if we run docker ps, we can see the list of running processes
or running containers. Look, we don't have any containers running here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- but if we type docker ps dash a for all, we can see the stopped containers
as well. So we have two stopped containers. The first one is
using the Ubuntu image, this is the one that we just started.
And the second one is hello docker, which we started
earlier in the course.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                   CREATED              STATUS                          PORTS     NAMES
cc3ce42ddbf2   ubuntu         "/bin/bash"               About a minute ago   Exited (0) About a minute ago             fervent_golick
8ee68b73826f   hello-docker   "docker-entrypoint.sâ€¦"   2 hours ago          Exited (0) 2 hours ago                    busy_brown
-------------------code----------------------

- So, to start a container and interact with it, we have to type docker run dash
it, that is short for interactive. We're going to start a container
in the interactive mode. And in this container
we're going to load the Ubuntu image which we have locally.
-------------------code----------------------
$ docker run -it ubuntu
root@ee871cc6ca5f:/#
-------------------code----------------------

- Now, what we have here is called
the shell. A shell is a program that takes our commands
and passes them to the operating system for execution.
Now, what we have here is called the shell prompt.

- the first part root represents the currently logged in user,
so by default we're logged in as the root user which has the highest privileges.
Then after the add sign, we have the name of the machine. So, this container has this
ID which is automatically generated by docker and in this case, it's like the name of a machine.
Okay? Then after the colon, we can see forward slash, that represents where we are in the file system.
A forward slash represents the root directory. That is the highest directory in the file system.
Then we have a pound "#" and this means we have the highest privileges because we've logged in as the root user.
If we logged in as a normal user, instead of a pound we would see a dollar sign "$".
-------------------code----------------------
root@ee871cc6ca5f:/#
-------------------code----------------------

- So, in this shell, we can execute a bunch of commands
for example, we can say echo, hello and this prints hello on the terminal.
-------------------code----------------------
root@ee871cc6ca5f:/# echo hello
hello
-------------------code----------------------

We can also say "whoami", This shows the current user.
-------------------code----------------------
root@ee871cc6ca5f:/# whoami
root
-------------------code----------------------

- So these commands that we're running here, this shell program that we told we about
takes these commands and passes them to the kernel for execution.
If we type echo dollar sign zero, we can see the location of this shell program.
Take a look. So, that is forward slash bin slash bash.
-------------------code----------------------
root@ee871cc6ca5f:/# echo $0
/bin/bash
-------------------code----------------------

- So bin is a folder or a directory and inside this directory, we have a program called bash
which is short for born again shell.
So apparently, Steve Bourne is the first person
who created a shell program. Bash or born again shell
is a reference to Steve Bourne.

- So bash is an enhanced version of the original shell program.
Now one thing we probably notice is that in Linux
we use a forward slash to separate files and directories.
But in Windows, we use a backslash.

- So that's one of the first differences.
The other difference is that Linux is a case sensitive operating system.
So if we type echo with a capital E,
it's not going to work.

- Bash tells us echo command not found.
So lowercase and uppercase letters are different.
And this is not limited to commands, it's applicable everywhere.
-------------------code----------------------
Echo $0
bash: Echo: command not found
-------------------code----------------------

- If we want to reference a file or a directory or a user,
pretty much anything, we should always spell it properly
with the right uppercase and lowercase letters.


- Using the up and down arrows,
we can go through the commands we have executed so far.
So this is a pretty useful shortcut we need to know
because we don't want to type these commands manually all the time.


- Also, using the history command,
we can see all the commands we have executed lately.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
-------------------code----------------------


- So, take a look.
So earlier we used whoami,
we also used echo and so on.
Now we can replay any of these commands
by typing an exclamation mark,
followed by the command number.
So if we type 2,
this is exactly like running whoami.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
root@ee871cc6ca5f:/# !2
whoami
root
-------------------code----------------------

*** 4- Managing Packages ***

- These days, most operating systems
and development platforms come with a package manager. we've probably
worked with tools like npm, yarn, pip, and so on.

- Here in Ubuntu, we also have a package manager called apt, which is short
for advanced package tool. So let's execute this command.
Look, this command has a bunch of subcommands.
-------------------code----------------------
root@ee871cc6ca5f:/# apt
apt 2.7.14 (arm64)
Usage: apt [options] command

apt is a commandline package manager and provides commands for
searching and managing as well as querying information about packages.
It provides the same functionality as the specialized APT tools,
like apt-get and apt-cache, but enables options more suitable for
interactive use by default.

Most used commands:
  list - list packages based on package names
  search - search in package descriptions
  show - show package details
  install - install packages
  reinstall - reinstall packages
  remove - remove packages
  autoremove - automatically remove all unused packages
  update - update list of available packages
  upgrade - upgrade the system by installing/upgrading packages
  full-upgrade - upgrade the system by removing/installing/upgrading packages
  edit-sources - edit the source information file
  satisfy - satisfy dependency strings

See apt(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- So using list, we can see the list of packages, we can also search
for them, we can show details about the package, we can install, reinstall
and remove a package and so on. Now technically, apt is the
newer package manager. We also have apt-get, which we see a lot
in online tutorials.
-------------------code----------------------
root@ee871cc6ca5f:/# apt-get
apt 2.7.14 (arm64)
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a command line interface for retrieval of packages
and information about them from authenticated sources and
for installation, upgrade and removal of packages together
with their dependencies.

Most used commands:
  update - Retrieve new lists of packages
  upgrade - Perform an upgrade
  install - Install new packages (pkg is libc6 not libc6.deb)
  reinstall - Reinstall packages (pkg is libc6 not libc6.deb)
  remove - Remove packages
  purge - Remove packages and config files
  autoremove - Remove automatically all unused packages
  dist-upgrade - Distribution upgrade, see apt-get(8)
  dselect-upgrade - Follow dselect selections
  build-dep - Configure build-dependencies for source packages
  satisfy - Satisfy dependency strings
  clean - Erase downloaded archive files
  autoclean - Erase old downloaded archive files
  check - Verify that there are no broken dependencies
  source - Download source archives
  download - Download the binary package into the current directory
  changelog - Download and display the changelog for the given package

See apt-get(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- Going forward, we're going to use apt because it's
easier to work with. So let's say we want to install a package called
nano. Nano is a basic text editor for Linux. Now if we press enter here,
we get an error because this image, this ubuntu image we are running
does not have nano. 
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: nano: command not found
-------------------code----------------------

- So this is where we use apt to install this package.
So if we type apt install nano, we get an error saying, unable to locate package nano.
-------------------code----------------------
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
E: Unable to locate package nano
-------------------code----------------------

- Why is this happening? Well, here in Linux, we have a package database
and this database might contain hundreds of packages, but not all these packages
are installed. So if we want to see all the packages in this database,
we type apt list. Look, these are all the packages. Now in front of these packages,
we can see some of them are installed. But not all packages in this database
are installed. 
-------------------code----------------------
root@ee871cc6ca5f:/# apt list
Listing... Done
apt/now 2.7.14build2 arm64 [installed,local]
base-files/now 13ubuntu10.1 arm64 [installed,local]
base-passwd/now 3.6.3build1 arm64 [installed,local]
bash/now 5.2.21-2ubuntu4 arm64 [installed,local]
bsdutils/now 1:2.39.3-9ubuntu6.2 arm64 [installed,local]
coreutils/now 9.4-3ubuntu6 arm64 [installed,local]
dash/now 0.5.12-6ubuntu5 arm64 [installed,local]
debconf/now 1.5.86ubuntu1 all [installed,local]
debianutils/now 5.17build1 arm64 [installed,local]
diffutils/now 1:3.10-1build1 arm64 [installed,local]
dpkg/now 1.22.6ubuntu6.1 arm64 [installed,local]
e2fsprogs/now 1.47.0-2.4~exp1ubuntu4.1 arm64 [installed,local]
.....
.....
-------------------code----------------------

- When we type apt install nano, this command looks at the package database
and in this database, it cannot find a package called nano.
So this is where we use the update command to update the package database.
Now, when we press enter, the next is going to all these sources,
like security.ubuntu.com and all these other websites
to download the list of packages. So now our package database is updated.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
...........
-------------------code----------------------

- So if we run apt list, we see far more packages. And as we can see,
most of these packages are not installed, because we don't have
installed in front of them. So now we can run apt install nano, and
nano is installed. So here's what we need to take away.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
Get:5 http://ports.ubuntu.com/ubuntu-ports noble/main arm64 Packages [1776 kB]
Get:6 http://ports.ubuntu.com/ubuntu-ports noble/universe arm64 Packages [19.0 MB]
Get:7 http://ports.ubuntu.com/ubuntu-ports noble/multiverse arm64 Packages [274 kB]
Get:8 http://ports.ubuntu.com/ubuntu-ports noble/restricted arm64 Packages [113 kB]
Get:9 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 Packages [1164 kB]
Get:10 http://ports.ubuntu.com/ubuntu-ports noble-updates/multiverse arm64 Packages [32.7 kB]
Get:11 http://ports.ubuntu.com/ubuntu-ports noble-updates/restricted arm64 Packages [1090 kB]
Get:12 http://ports.ubuntu.com/ubuntu-ports noble-updates/universe arm64 Packages [1311 kB]
Get:13 http://ports.ubuntu.com/ubuntu-ports noble-backports/universe arm64 Packages [16.1 kB]
Get:14 http://ports.ubuntu.com/ubuntu-ports noble-security/universe arm64 Packages [1028 kB]
Get:15 http://ports.ubuntu.com/ubuntu-ports noble-security/multiverse arm64 Packages [30.8 kB]
Get:16 http://ports.ubuntu.com/ubuntu-ports noble-security/main arm64 Packages [843 kB]
Get:17 http://ports.ubuntu.com/ubuntu-ports noble-security/restricted arm64 Packages [1041 kB]
Fetched 28.4 MB in 16s (1826 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
18 packages can be upgraded. Run 'apt list --upgradable' to see them.
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  hunspell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 18 not upgraded.
-------------------code----------------------

- Before installing a package, we should always run apt update
to update our package database. And then we can install a package like nano.
-------------------code----------------------
apt update
apt update nano
-------------------code----------------------

- Now we'll talk about nano later in this section. But before going forward, let's make sure
that this package is installed properly.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
-------------------code----------------------


- So we have installed nano.
Now let's say we want to remove it.
So we type apt remove nano. It's asking for confirmation.
So nano is gone.
-------------------code----------------------
root@ee871cc6ca5f:/# apt remove nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  nano
0 upgraded, 0 newly installed, 1 to remove and 18 not upgraded.
After this operation, 909 kB disk space will be freed.
Do we want to continue? [Y/n] y
(Reading database ... 4451 files and directories currently installed.)
Removing nano (7.2-2ubuntu0.1) ...
-------------------code----------------------

- If we type nano,
we get this error saying no such file or directory.
Now here's a little exercise for we.
In this image we don't have python.
So we get an error.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: /usr/bin/nano: No such file or directory
-------------------code----------------------

- Homework: use apt to install python in this image.
Make sure it works and then remove it.

*** 5- Linux File System ***

- So, in Linux, just like Windows,
our files and directories are organized in a tree,
in a hierarchical structure. So, in Windows
we have a structure like this, with C drive on top
of the hierarchy, then below that we have directories like
program files, windows and so on. 
-------------------code----------------------
C:\
  Program Files
  Windows
-------------------code----------------------

- In Linux we have the root directory on top of the hierarchy.
Below that we have a bunch of standard directories, for example
we have bin, which includes binaries or programs. We have boot, which includes all the
files related to booting. Then we have dev, the first time we saw this, we thought this is short for development.
It's not. It's short for devices. So, in Linux
everything is a file, including devices,
directories, network sockets, pipes and so on.

-------------------code----------------------
- /
  bin
  boot
  dev
  etc
  home
  root
  lib
  var
  proc
-------------------code----------------------



- So, the files that are needed to access devices are
stored in this directory. Then we have etsy,
there are different opinions what is this short for, but one common
opinion is, this is short for editable text configuration.
So, this is where we have configuration files.

- We also have home, this is where home directories
for users are stored. So, on a machine with multiple users,
each user is going to have a home directory here.
We also have root, which is the home directory of the root user.
Only the root user can access this directory.
Then we have lib, which is used for keeping library files
like software library dependencies. We have var,
which is short for variable, and this is where we have files
that are updated frequently, like log files,
application data and so on. And finally, we have proc,
which includes files that represent running processes.

- So, once again, in Linux, everything is a file.
Processes, devices, even directories are files.
Now, we don't need to memorize any of these directories.
we just listed them here, so as we go through the course,
these directories look familiar to us.

*** 6- Navigating the File System ***

- Let's see how we can navigate the Linux file system. So the first command we're going to talk about is pwd
which is short for print working directory. With this we can see
where we are in the file system. So a forward slash
represents the root directory. 
-------------------code----------------------
root@8a65a7f2dd58:/# pwd
/
-------------------code----------------------

- Now to see the files and directories here, we type ls which is short for list. So we have
bin which we talked about earlier, that is short for binaries, this is where we have binary
files and programs, we have dev which includes files for devices,
we have boot which includes boot files, etsy which includes configuration
files and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, by default ls lists these items on multiple lines. If we don't like this layout and want to show
one item per line, we need to pass an option, that is dash
one. we might prefer this layout.
-------------------code----------------------
root@8a65a7f2dd58:/# ls -1
bin
boot
dev
etc
home
lib
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
-------------------code----------------------

- We have another option, dash l, for seeing a long listing.
This listing includes more details. So in the first column we have the permissions of this file or directory.
The first time we see this, it might look really scary,
We'll talk about that later in this section. Over here, we can see
the user that owns this file or directory, we can see the size, we can see
the date and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls -l
total 48
lrwxrwxrwx   1 root root    7 Apr 22  2024 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 22  2024 boot
drwxr-xr-x   5 root root  360 Mar 17 15:46 dev
drwxr-xr-x   1 root root 4096 Mar 17 15:46 etc
drwxr-xr-x   3 root root 4096 Jan 27 02:19 home
lrwxrwxrwx   1 root root    7 Apr 22  2024 lib -> usr/lib
drwxr-xr-x   2 root root 4096 Jan 27 02:12 media
drwxr-xr-x   2 root root 4096 Jan 27 02:12 mnt
drwxr-xr-x   2 root root 4096 Jan 27 02:12 opt
dr-xr-xr-x 168 root root    0 Mar 17 15:46 proc
drwx------   2 root root 4096 Jan 27 02:19 root
drwxr-xr-x   4 root root 4096 Jan 27 02:19 run
lrwxrwxrwx   1 root root    8 Apr 22  2024 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Jan 27 02:12 srv
dr-xr-xr-x  11 root root    0 Mar 17 15:46 sys
drwxrwxrwt   2 root root 4096 Jan 27 02:19 tmp
drwxr-xr-x  11 root root 4096 Jan 27 02:12 usr
drwxr-xr-x  11 root root 4096 Jan 27 02:19 var
-------------------code----------------------

- Now to change the current directory, we use
the cd command, we have the same command in windows. Now here we can
type a relative or an absolute path. A relative path
is relative to where we are. So in this root directory, we have directories like bin, boot and so on. So this is a relative
path. Now in contrast, an absolute path
always starts from the root directory. So, let's go to a directory starting with
e. Now we can press tab to get autocompletion, beautiful.
Now let's go to a directory starting with a. Now if we press tab,
nothing happens because we have multiple directories starting with a.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/a
alternatives/ apt/
-------------------code----------------------

- So we have to press tab one more time, great. So, we have
three entries, three directories, add user.conf, alternatives
and apt. So, let's type the second letter, p and then press tab.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/apt/
-------------------code----------------------

- Now let's see what we have in this directory. So,
these blue items are directories and sources that list is a file.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# ls
apt.conf.d  auth.conf.d  keyrings  preferences.d  sources.list  sources.list.d  trusted.gpg.d
-------------------code----------------------v

- Now to get out of this directory we can go one level up by typing two periods.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# cd ..
-------------------code----------------------

- Again, to get to the etsy directory or two levels up to get to the root directory.
Look, we're currently in the root directory.
-------------------code----------------------
root@8a65a7f2dd58:/etc# cd ../..
-------------------code----------------------

-  Now, when using ls, we can optionally specify a path. Let's say we're somewhere in the file system, but we want to
look at the content of another directory. we don't want to navigate to that directory.
So, we're currently in the root directory, we want to know what files and directories
we have inside the bin directory. So once again, we can type a
relative path or an absolute path starting from the root directory.
So, here are the binaries in this directory. Look at pwd. That's the command
that we just executed. So, pwd is a program in this directory. Here's another example.
Look at echo. So, most of the commands we have been exploring so far are programs
or binaries in the bin directory.
-------------------code----------------------
root@8a65a7f2dd58:/# ls bin
'['              cut                       expiry      join               mount           readlink            skill       uncompress
 addpart         dash                      expr        kill               mountpoint      realpath            slabtop     unexpand
 apt             date                      factor      last               mv              rename.ul           sleep       uniq
 apt-cache       dd                        faillog     lastb              namei           renice              snice       unlink
 apt-cdrom       deb-systemd-helper        fallocate   lastlog            nawk            reset               sort        unminimize
 apt-config      deb-systemd-invoke        false       ld.so              newgrp          resizepart          split       unshare
 apt-get         debconf                   fgrep       ldd                nice            rev                 stat        update-alternatives
 apt-key         debconf-apt-progress      find        link               nisdomainname   rgrep               stdbuf      uptime
 apt-mark        debconf-communicate       findmnt     linux32            nl              rm                  stty        users
 arch            debconf-copydb            flock       linux64            nohup           rmdir               su          utmpdump
 awk             debconf-escape            fmt         ln                 nproc           run-parts           sum         vdir
 b2sum           debconf-set-selections    fold        locale             nsenter         runcon              sync        vmstat
 base32          debconf-show              free        locale-check       numfmt          savelog             tabs        w
 base64          delpart                   getconf     localedef          od              script              tac         wall
 basename        df                        getent      logger             pager           scriptlive          tail        watch
 basenc          diff                      getopt      login              partx           scriptreplay        tar         wc
 bash            diff3                     gpasswd     logname            passwd          sdiff               taskset     wdctl
 bashbug         dir                       gpgv        ls                 paste           sed                 tee         whereis
 captoinfo       dircolors                 grep        lsattr             pathchk         select-editor       tempfile    which
 cat             dirname                   groups      lsblk              perl            sensible-browser    test        which.debianutils
 chage           dmesg                     gunzip      lscpu              perl5.38.2      sensible-editor     tic         who
 chattr          dnsdomainname             gzexe       lsipc              pgrep           sensible-pager      timeout     whoami
 chcon           domainname                gzip        lslocks            pidof           sensible-terminal   tload       xargs
 chfn            dpkg                      hardlink    lslogins           pidwait         seq                 toe         yes
 chgrp           dpkg-deb                  head        lsmem              pinky           setarch             top         ypdomainname
 chmod           dpkg-divert               hostid      lsns               pkill           setpriv             touch       zcat
 choom           dpkg-maintscript-helper   hostname    man                pldd            setsid              tput        zcmp
 chown           dpkg-query                iconv       mawk               pmap            setterm             tr          zdiff
 chrt            dpkg-realpath             id          mcookie            pr              sg                  true        zdump
 chsh            dpkg-split                infocmp     md5sum             printenv        sh                  truncate    zegrep
 cksum           dpkg-statoverride         infotocap   md5sum.textutils   printf          sha1sum             tset        zfgrep
 clear           dpkg-trigger              install     mesg               prlimit         sha224sum           tsort       zforce
 clear_console   du                        ionice      mkdir              ps              sha256sum           tty         zgrep
 cmp             echo                      ipcmk       mkfifo             ptx             sha384sum           tzselect    zless
 comm            egrep                     ipcrm       mknod              pwd             sha512sum           uclampset   zmore
 cp              env                       ipcs        mktemp             pwdx            shred               umount      znew
 csplit          expand                    ischroot    more               rbash           shuf                uname
-------------------code----------------------

 
- Now, let me show we a shortcut. Earlier we
told we that, here we have this home directory where each user
has a home directory. But the root user has a special home directory called root.
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, to get here, there are two options.
We can type an absolute or relative path and go to root.
-------------------code----------------------
cd root/
-------------------code----------------------

- But there is a shortcut. So, we're currently in the root directory. To get to my
home directory, we can type a tilde. And this applies to all
users, not just the root user. Whenever we type cd
tilde, we go to our home directory. 

-------------------code----------------------
root@8a65a7f2dd58:/# cd ~
root@8a65a7f2dd58:~#
-------------------code----------------------

*** 7- Manipulating Files and Directories ***

- Let's see how we can manipulate files and directories. So, we're currently in the root
directory and we want to go to my home directory. How can we do that? Do we remember? We type
cd tilde. Great.
-------------------code----------------------
root@8a65a7f2dd58:/# cd ~
-------------------code----------------------

- Now, in this directory we want to create a directory called test. So
we type mkdir test, let's verify, it's right here. As we told before, blue represents
a directory. 
-------------------code----------------------
root@8a65a7f2dd58:~# mkdir test
root@8a65a7f2dd58:~# ls
test
-------------------code----------------------

- Now, let's say we want to rename this directory. How do we do that? We use
the move command. With this we can rename files and folders or move them somewhere else. So,
we can move or rename test to docker. Alright, beautiful.
-------------------code----------------------
root@8a65a7f2dd58:~# mv test docker
root@8a65a7f2dd58:~# ls
docker
-------------------code----------------------

- Now, let's go in this directory. Now, to create a new file, we use the touch command. So we can create hello.txt. Look,
we have this new file here. This is a new empty file. 
-------------------code----------------------
root@8a65a7f2dd58:~# cd docker/
root@8a65a7f2dd58:~/docker# touch hello.txt
root@8a65a7f2dd58:~/docker# ls
hello.txt
-------------------code----------------------

- Also, using the touch command, we can
create multiple files in one go. So we can create file 1, file 2, and file 3.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# touch file1.txt file2.txt file3.txt
root@8a65a7f2dd58:~/docker# ls
file1.txt  file2.txt  file3.txt  hello.txt
-------------------code----------------------

- let's say we want to rename hello.txt to something else. Once again, we can use the move command. So we type h, press tab to get
autocompletion. We can rename this to hello-docker.txt. Or, we can move it to a different directory.
For example, we can move it to the etc directory. And here we're using an absolute path, because
my path has started from the root directory. Now, in this lesson, we don't want to move
this anywhere. So, we just want to rename this to hello-docker.txt.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# mv hello.txt hello-docker.txt
root@8a65a7f2dd58:~/docker# ls
file1.txt  file2.txt  file3.txt  hello-docker.txt
-------------------code----------------------

- Ahow we removed this entire word in one go, we pressed cmd and w. 

- back, hello-docker.txt. Now, let's see how we can remove one or more
files. To do that, use the rm command. Now, here we can type one or more files, so we can
say file 1.txt, file 2.txt.
-------------------code----------------------
root@8a65a7f2dd58:rm file1.txt file2.txt
-------------------code----------------------

- or we can use a pattern. For example, we can say, we want to
remove all files that start with file. Let's verify it. Beautiful, we only have hello-docker.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# rm file*
root@8a65a7f2dd58:~/docker# ls
hello-docker.txt
-------------------code----------------------

Now, let's get out of this directory and remove the directory itself. So, we type rm docker.
Now, we get an error saying docker is a directory.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# cd ../
root@8a65a7f2dd58:~# rm docker/
rm: cannot remove 'docker/': Is a directory
-------------------code----------------------

- So, to remove directories, we have to use
the r option, which is short for recursive. So, we want to remove this directory and all
its content recursively.
-------------------code----------------------
root@8a65a7f2dd58:~# rm -r docker/
root@8a65a7f2dd58:~# ls
root@8a65a7f2dd58:~#
-------------------code----------------------

*** 8- Editing and Viewing Files ***

- Alright, let's see how we can edit and
view files. So earlier we briefly talked about nano.
Nano is a basic text editor for Linux. Now, on this image that we are running,
we don't have nano, so we have to install it. Do we remember the command for installing nano?
That is apt install nano.
- first we update apt
-------------------code----------------------
root@8a65a7f2dd58:~# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
Get:5 http://ports.ubuntu.com/ubuntu-ports noble/multiverse arm64 Packages [274 kB]
Get:6 http://ports.ubuntu.com/ubuntu-ports noble/restricted arm64 Packages [113 kB]
Get:7 http://ports.ubuntu.com/ubuntu-ports noble/universe arm64 Packages [19.0 MB]
Get:8 http://ports.ubuntu.com/ubuntu-ports noble/main arm64 Packages [1776 kB]
Get:9 http://ports.ubuntu.com/ubuntu-ports noble-updates/restricted arm64 Packages [1090 kB]
Get:10 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 Packages [1167 kB]
Get:11 http://ports.ubuntu.com/ubuntu-ports noble-updates/multiverse arm64 Packages [32.7 kB]
Get:12 http://ports.ubuntu.com/ubuntu-ports noble-updates/universe arm64 Packages [1315 kB]
Get:13 http://ports.ubuntu.com/ubuntu-ports noble-backports/universe arm64 Packages [16.1 kB]
Get:14 http://ports.ubuntu.com/ubuntu-ports noble-security/multiverse arm64 Packages [30.8 kB]
Get:15 http://ports.ubuntu.com/ubuntu-ports noble-security/universe arm64 Packages [1028 kB]
Get:16 http://ports.ubuntu.com/ubuntu-ports noble-security/restricted arm64 Packages [1041 kB]
Get:17 http://ports.ubuntu.com/ubuntu-ports noble-security/main arm64 Packages [843 kB]
Fetched 28.4 MB in 16s (1754 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
18 packages can be upgraded. Run 'apt list --upgradable' to see them.
-------------------code----------------------

- next install nano
-------------------code----------------------
root@8a65a7f2dd58:~# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  hunspell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 18 not upgraded.
Need to get 281 kB of archives.
After this operation, 909 kB of additional disk space will be used.
Get:1 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 nano arm64 7.2-2ubuntu0.1 [281 kB]
Fetched 281 kB in 2s (154 kB/s)
debconf: delaying package configuration, since apt-utils is not installed
Selecting previously unselected package nano.
(Reading database ... 4378 files and directories currently installed.)
Preparing to unpack .../nano_7.2-2ubuntu0.1_arm64.deb ...
Unpacking nano (7.2-2ubuntu0.1) ...
Setting up nano (7.2-2ubuntu0.1) ...
update-alternatives: using /bin/nano to provide /usr/bin/editor (editor) in auto mode
update-alternatives: warning: skip creation of /usr/share/man/man1/editor.1.gz because associated file /usr/share/man/man1/nano.1.gz (of link group editor) doesn't exist
update-alternatives: using /bin/nano to provide /usr/bin/pico (pico) in auto mode
update-alternatives: warning: skip creation of /usr/share/man/man1/pico.1.gz because associated file /usr/share/man/man1/nano.1.gz (of link group pico) doesn't exist
-------------------code----------------------


- Alright, now we have nano, so we can launch it,
and optionally supply a file name, let's say file1.txt.
So here we have a basic text editor, we can type
whatever we want, and when we are done, look down below,
the shortcut for exiting is control and x, so we're going to press that.
Now it's asking if we want to save the changes, so we press yes.
And here we confirm the file name, we can keep the same file, or change the file name.
Let's go ahead. So now, in this directory we have
file1.txt, beautiful. 
-------------------code----------------------
root@8a65a7f2dd58:~# nano file1.txt
root@8a65a7f2dd58:~# ls
file1.txt
-------------------code----------------------


- Now, to see the content of this file,
we have a few different commands. The simplest one is cat,
and this has nothing to do with cat, it's short for concatenate.
So later we will show we how we can use this command to concatenate or combine multiple files.
But with cat we can also see the content of a file, so if we say
cat file1.txt, we can see the content of this file.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt
hello
world
-------------------code----------------------


- Now, cat is useful if our file is short and
fits on one page, but if we're dealing with a long file, it's better to use
the more command. Let me give we an example, so
we're going to use cat to show the content of this file.
This is a really long file, so if we scroll up, look, we have a lot of text.
Now, sometimes we don't want to see all the content in one go,
we want to scroll down.
-------------------code----------------------
root@8a65a7f2dd58:/# cat /etc/debconf.conf
# This is the main config file for debconf. It tells debconf where to
# store data. The format of this file is a set of stanzas. Each stanza
# except the first sets up a database for debconf to use. For details, see
# debconf.conf(5) (in the debconf-doc package).
#
# So first things first. This first stanza gives the names of two databases.

# Debconf will use this database to store the data we enter into it,
# and some other dynamic data.
Config: configdb
# Debconf will use this database to store static template data.
Templates: templatedb

# World-readable, and accepts everything but passwords.
Name: config
Driver: File
Mode: 644
Reject-Type: password
Filename: /var/cache/debconf/config.dat
.....
-------------------code----------------------

-if we want to go page by page. This is where
we use the more command.  Now, down below, look, we can see
more 15%, so we are seeing 15% of this file. Now, if we press space, we can go to the next
page, so now we are at the position 33%. Alternatively, we can press enter
to go one line at a time.
-------------------code----------------------
root@8a65a7f2dd58:~# more /etc/debconf.conf
# Set up the configdb database. By default, it consists of a stack of two
# databases, one to hold passwords and one for everything else.
Name: configdb
Driver: Stack
Stack: config, passwords

# Set up the templatedb database, which is a single flat text file
--More--(39%)
-------------------code----------------------

-  Now, the problem with more is that we can only scroll down, we cannot
scroll up. So, to do that, we have to use a different command called less. So, to exit
here, we press q, good. Now, in this image we don't have less, so once again we have to manually
install it. So, apt install less.
-------------------code----------------------
root@8a65a7f2dd58:~# apt install less
-------------------code----------------------

- So, less is a newer command that is supposed to replace more. Let's go ahead.
Great. So, let's look at the same file using the less command.
So, now using the up and down arrows we can scroll down or up.
So, just by pressing up and down arrows. We also have space, we can go to the next page
and enter, just like the more command. And when we are done, we can press q.
-------------------code----------------------
root@8a65a7f2dd58:~# less /etc/debconf.conf
-------------------code----------------------

- Now, we have a couple more commands for viewing the content of a file.
We have head, which we can use to display the first
few lines. So, here we can supply an option and say, the number of lines we want to see is five.
Let's look at the same file. So, this shows the first five lines of this file.
-------------------code----------------------
root@8a65a7f2dd58:~# head -n 5 /etc/debconf.conf
# This is the main config file for debconf. It tells debconf where to
# store data. The format of this file is a set of stanzas. Each stanza
# except the first sets up a database for debconf to use. For details, see
# debconf.conf(5) (in the debconf-doc package).
#
-------------------code----------------------

- Similarly, we have tail, which shows the last few lines. So, we supply an option and say we want to look at the last five files.
-------------------code----------------------
root@8a65a7f2dd58:~# tail -n 5 /etc/debconf.conf
# In this example, we'd use Config: fulldb at the top of the file
# to make it use the combination of the databases.
#
# Even more complex and interesting setups are possible, see the
# debconf.conf(5) page for details.
-------------------code----------------------

*** 9- Redirection ***

- One of the important concepts in Linux is the concept of standard input
and output. So standard input represents the keyboard and standard
output represents the screen. But we can always change the source
of the input or the output. This is called redirection.


- a few examples. So we talked about the cat command to see the content
of a file. Let's say file1.txt. When we execute
this command, this command or this program reads data from this file
and prints it on the standard output which is the screen.
That is why we see the content.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt
hello
world
-------------------code----------------------


- But using the redirection operator
which is the greater than sign, we can redirect the output
from the screen to, let's say, a different file.
So now cat will read the content from this file and write it to this file.
Take a look. So we have file2.txt if we view it, we see
the exact same content as file1.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt > file2.txt
root@8a65a7f2dd58:~# ls
file1.txt  file2.txt
root@8a65a7f2dd58:~# cat file2.txt
hello
world
-------------------code----------------------

- Okay, now what is the point of this?
Well, earlier we told we that we can use the cat command to concatenate
or combine multiple files. So here we can say cat file1.txt
and file2.txt. If we press enter, cat is going to read the data
from both these files and print it on the terminal which is the standard
output. 
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt  file2.txt
hello
world
hello
world
-------------------code----------------------

- But once again, using the redirection operator we can write the result to a different file.
Combine.txt So this is how we can use this command to combine multiple files.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt  file2.txt  > combined.txt
root@8a65a7f2dd58:~# cat combined.txt
hello
world
hello
world
-------------------code----------------------

- Now, the redirection operator is not
limited to the cat command, we can use it pretty much anywhere. For example,
earlier we talked about the echo command. If we say echo hello,
we see the result on the terminal. 
-------------------code----------------------
root@8a65a7f2dd58:~# echo hello.txt
hello.txt
-------------------code----------------------

- But if we say echo hello to
hello.txt Now we have a new file here, hello.txt which contains hello.
-------------------code----------------------
root@8a65a7f2dd58:~# echo "hello" > hello.txt
root@8a65a7f2dd58:~# cat hello.txt
hello
-------------------code----------------------

- So if we want to write a single line to a file, we don't have to use nano,
we can use the echo command. So echo whatever to
whatever file.txt. Okay? 

- another example we want we to get a long listing
of the files in the etsy directory and write the output to a file.
so To get a long listing, we type ls-l, then we specify the path, the etsy directory, now
instead of printing the result on the terminal we're going to write it to a file called
etc_list.txt.
-------------------code----------------------
root@8a65a7f2dd58:~# ls -l /etc/ > etc_files.tsxt
root@8a65a7f2dd58:~# cat etc_files.tsxt
total 300
drwxr-xr-x 1 root root    4096 Mar 17 16:30 alternatives
drwxr-xr-x 8 root root    4096 Jan 27 02:13 apt
-rw-r--r-- 1 root root    2319 Mar 31  2024 bash.bashrc
-rw-r--r-- 1 root root     367 Aug  2  2022 bindresvport.blacklist
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cloud
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cron.d
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cron.daily
-rw-r--r-- 1 root root    2967 Apr 12  2024 debconf.conf
-rw-r--r-- 1 root root      11 Apr 22  2024 debian_version
drwxr-xr-x 2 root root    4096 Jan 27 02:19 default
drwxr-xr-x 4 root root    4096 Jan 27 02:19 dpkg
-rw-r--r-- 1 root root     685 Apr  8  2024 e2scrub.conf
-rw-r--r-- 1 root root     106 Jan 27 02:12 environment
-rw-r--r-- 1 root root      37 Jan 27 02:12 fstab
-rw-r--r-- 1 root root    2584 Jan 31  2024 gai.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 gnutls
-rw-r--r-- 1 root root     503 Jan 27 02:19 group
-rw-r--r-- 1 root root     434 Jan 27 02:12 group-
-rw-r----- 1 root shadow   429 Jan 27 02:19 gshadow
-rw-r----- 1 root shadow   364 Jan 27 02:12 gshadow-
-rw-r--r-- 1 root root      92 Apr 22  2024 host.conf
-rw-r--r-- 1 root root      13 Mar 17 15:46 hostname
-rw-r--r-- 1 root root     174 Mar 17 15:46 hosts
drwxr-xr-x 2 root root    4096 Jan 27 02:19 init.d
-rw-r--r-- 1 root root      26 Aug 23  2024 issue
-rw-r--r-- 1 root root      19 Aug 23  2024 issue.net
drwxr-xr-x 3 root root    4096 Jan 27 02:13 kernel
-rw-r--r-- 1 root root    5199 Jan 27 02:19 ld.so.cache
-rw-r--r-- 1 root root      34 Aug  2  2022 ld.so.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 ld.so.conf.d
-rw-r--r-- 1 root root     267 Apr 22  2024 legal
-rw-r--r-- 1 root root     191 Mar 31  2024 libaudit.conf
-rw-r--r-- 1 root root   12345 Feb 22  2024 login.defs
drwxr-xr-x 2 root root    4096 Jan 27 02:19 logrotate.d
-rw-r--r-- 1 root root     104 Aug 23  2024 lsb-release
-rw-r--r-- 1 root root       0 Jan 27 02:19 machine-id
-rw-r--r-- 1 root root     744 Apr  8  2024 mke2fs.conf
lrwxrwxrwx 1 root root      12 Mar 17 15:46 mtab -> /proc/mounts
-rw-r--r-- 1 root root   11424 May 23  2023 nanorc
-rw-r--r-- 1 root root      91 Apr 22  2024 networks
-rw-r--r-- 1 root root     494 Aug  2  2022 nsswitch.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:12 opt
lrwxrwxrwx 1 root root      21 Aug 23  2024 os-release -> ../usr/lib/os-release
-rw-r--r-- 1 root root     552 Oct 13  2022 pam.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 pam.d
-rw-r--r-- 1 root root     888 Jan 27 02:19 passwd
-rw-r--r-- 1 root root     839 Jan 27 02:12 passwd-
-rw-r--r-- 1 root root     582 Apr 22  2024 profile
drwxr-xr-x 2 root root    4096 Jan 27 02:19 profile.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc0.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc1.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc2.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc3.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc4.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc5.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc6.d
drwxr-xr-x 2 root root    4096 Jan 27 02:12 rcS.d
-rw-r--r-- 1 root root     222 Mar 17 15:46 resolv.conf
lrwxrwxrwx 1 root root      13 Apr  8  2024 rmt -> /usr/sbin/rmt
drwxr-xr-x 4 root root    4096 Jan 27 02:19 security
drwxr-xr-x 2 root root    4096 Jan 27 02:17 selinux
-rw-r----- 1 root shadow   502 Jan 27 02:19 shadow
-rw-r----- 1 root shadow   474 Jan 27 02:12 shadow-
-rw-r--r-- 1 root root     118 Jan 27 02:13 shells
drwxr-xr-x 2 root root    4096 Jan 27 02:13 skel
-rw-r--r-- 1 root root      20 Jan 27 02:19 subgid
-rw-r--r-- 1 root root       0 Jan 27 02:13 subgid-
-rw-r--r-- 1 root root      20 Jan 27 02:19 subuid
-rw-r--r-- 1 root root       0 Jan 27 02:13 subuid-
-rw-r--r-- 1 root root    2209 Mar 24  2024 sysctl.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 sysctl.d
drwxr-xr-x 4 root root    4096 Dec  6  2023 systemd
drwxr-xr-x 2 root root    4096 Jan 27 02:18 terminfo
drwxr-xr-x 2 root root    4096 Jan 27 02:19 update-motd.d
-rw-r--r-- 1 root root     681 Apr  8  2024 xattr.conf
-------------------code----------------------


- Using the greater than sign we can redirect the standard output
but we also have the less than sign to redirect the standard input.
we personally haven't found many use cases for this so we didn't cover it
in this lesson. 
-------------------code----------------------
root@8a65a7f2dd58:~# >
-------------------code----------------------


*** 10- Searching for Text ***

- Let's see how we can search for a string in a file.
So we have this grep command which is short for global regular
expression print. 


- let's say we want to search for the word hello in file1.txt.
What happened? Didn't we write hello to file1.txt?
Yes we did, but this search is case sensitive just like
everything else in Linux. 
-------------------code----------------------
root@8a65a7f2dd58:~# grep Hello file1.txt
-------------------code----------------------

- we research with case sensitive
-------------------code----------------------
root@8a65a7f2dd58:~# grep hello file1.txt
hello
-------------------code----------------------

- If we want to remove case sensitivity,
we have to use an option. That is
dash i. So case insensitive. Now we see the word hello highlighted in red. 
-------------------code----------------------
root@8a65a7f2dd58:~# grep -i Hello file1.txt
hello
-------------------code----------------------

- Let's look at another example. This time
we want to search for the word root in slash etsy slash password.
This file contains the list of user accounts on this machine. Not their
passwords, just their accounts.
On this line, which we think is the first line in this file,
we have three occurrences of root and that's why they're displayed in red.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i root /etc/passwd
root:x:0:0:root:/root:/bin/bash
-------------------code---------------------

- Now we can also search in multiple files. So let's search for hello
in file1.txt and file2.txt. That's one way. 
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello file1.txt file2.txt
file1.txt:hello
file2.txt:hello
-------------------code---------------------

- We can also use a pattern. So we can say we want to search in all files whose name starts with file.
So we use a wild card here.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello file*
file1.txt:hello
file2.txt:hello
-------------------code---------------------

- Now we can see in file1.txt we have hello and the same is true in file2.txt.
Now we can also search in a directory. So instead of typing a file name, we can type a directory name or we can use a period to refer to the current directory.
Now we get an error saying period is a directory. 


- So here we have to use an additional option
dash r which is short for recursive. So with this we can search this directory and all its subdirectories recursively.
Now look, in all these files we have references to hello. We have references to hello. 
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello .
grep: .: Is a directory
-------------------code---------------------

- Now one last thing. In Linux we can combine multiple options.
So instead of having two different options, dash i and dash r,
we can combine them into one option. This gives us the exact same result.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -ir hello .
./hello.txt:hello
./file1.txt:hello
./combined.txt:hello
./combined.txt:hello
./file2.txt:hello
-------------------code---------------------

- So using the grep command, we can search for a string in one or more files.

*** 11- Finding Files and Directories ***

- Let's talk about finding files and directories. So we're currently in my home directory
as we can tell from the tilde. Let's run ls so here we have combined file1, file2, files and hello.txt
Now of course on our machine we might have different files, it doesn't matter.
-------------------code---------------------
root@8a65a7f2dd58:~# ls
combined.txt  etc_files.tsxt  file1.txt  file2.txt  hello.txt
-------------------code---------------------

- Now in Linux we have the find command for finding files
and directories. If we execute this command without any arguments
we see all the files and directories in the current directory
recursively. So this command is going to go through every directory
in this directory and list their files. So on the top we have
.bashrc and .profile, these are two hidden files in the
current directory. we didn't see this earlier when we executed ls,
because by default ls doesn't show the hidden files and directories.
-------------------code---------------------
root@8a65a7f2dd58:~# find
.
./.bashrc
./.profile
./hello.txt
./file1.txt
./.local
./.local/share
./.local/share/nano
./etc_files.tsxt
./combined.txt
./file2.txt
./.lesshst
-------------------code---------------------

- Now, what option should we use to see the hidden files and directories?
Do we remember, dash a which is short for all. So now
we can see bashrc, profile, and local which is
a directory because it's blue. 
-------------------code---------------------
root@8a65a7f2dd58:~# ls -a
.  ..  .bashrc  .lesshst  .local  .profile  combined.txt  etc_files.tsxt  file1.txt  file2.txt  hello.txt
-------------------code---------------------

- So back to the find command, here we can see all the files and directories in the current directory.
Now, if we want to look somewhere else, we can supply a path.
So, we can search in the etsy directory. Now we can see all the files and directories starting from etsy.
-------------------code---------------------
root@8a65a7f2dd58:~# find /etc/
/etc/
/etc/dpkg
/etc/dpkg/dpkg.cfg
/etc/dpkg/origins
/etc/dpkg/origins/debian
/etc/dpkg/origins/default
/etc/dpkg/origins/ubuntu
/etc/dpkg/dpkg.cfg.d
/etc/dpkg/dpkg.cfg.d/docker-apt-speedup
/etc/dpkg/dpkg.cfg.d/excludes
/etc/group-
/etc/passwd-
.....
.....
....
-------------------code---------------------

- Okay? Now, let's get back to the current directory.
a various ways to filter the result. If we want to see only the directories,
we pass an option called type with the value of d.
Now we can see only the directories in the current directory.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type d
.
./.local
./.local/share
./.local/share/nano
-------------------code---------------------

- Alternatively, we can search for files. 
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f
./.bashrc
./.profile
./hello.txt
./file1.txt
./etc_files.tsxt
./combined.txt
./file2.txt
./.lesshst
-------------------code---------------------
- We can also filter by name. So, let's say we want to find
all the files whose name start with, let's say F.
Here in double quotes, we can type a pattern, we can say F star.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -name "f*"
./file1.txt
./file2.txt
-------------------code---------------------

- Now just remember that this search is case sensitive just like everything else in Linux.
So if we type a capital F here, we don't find anything.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -name "F*"
-------------------code---------------------

- Now, to make the search case insensitive, instead of name,
we use a different option that is iname.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -iname "F*"
./file1.txt
./file2.txt
-------------------code---------------------

Alright, beautiful. Now here's a little exercise for we.
Using the find command, we want we to find all the python files in this image
and then write the result to a file called pythonfiles.txt.
-------------------code---------------------
root@8a65a7f2dd58:~# find / -type f -name "*.py"
/usr/share/apport/package-hooks/source_shadow.py
/usr/share/gdb/auto-load/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.33-gdb.py
/usr/share/gcc/python/libstdcxx/v6/__init__.py
/usr/share/gcc/python/libstdcxx/v6/printers.py
/usr/share/gcc/python/libstdcxx/v6/xmethods.py
/usr/share/gcc/python/libstdcxx/__init__.py
-------------------code---------------------

- Now, to write the result to a file, we're going to use the redirection operator.
So, we can write it to a file called pythonfiles.txt.
-------------------code---------------------
root@8a65a7f2dd58:~# find / -type f -name "*.py" > python-files.txt
root@8a65a7f2dd58:~# cat python-files.txt
/usr/share/apport/package-hooks/source_shadow.py
/usr/share/gdb/auto-load/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.33-gdb.py
/usr/share/gcc/python/libstdcxx/v6/__init__.py
/usr/share/gcc/python/libstdcxx/v6/printers.py
/usr/share/gcc/python/libstdcxx/v6/xmethods.py
/usr/share/gcc/python/libstdcxx/__init__.py
-------------------code---------------------

*** 12- Chaining Commands ***

- In Linux, we have a few different ways for chaining or combining multiple commands. 

- So once again we're in my home directory. Let's say we want to create a directory called test
and right after this we want to go into this directory and echo something to the terminal.
Now we don't want to press enter here and then type the second command.
we want to type multiple commands and execute them in one go.
So here we type a semicolon and then type the second command which is cd test. Now once again
we type a semicolon and type the third command. So echo, done. Now if we press enter
all these commands will get executed one after another.
-------------------code---------------------
root@8a65a7f2dd58:~# mkdir test;cd test;echo done
done
-------------------code---------------------

- Now, some people prefer to add a space
around these semicolons to make their
command sequence more clear, more readable. That's optional,
it's entirely up to us. So look, we see
the done message and we're currently inside the
test directory.
-------------------code---------------------
mkdir test ; cd test ; echo done
-------------------code---------------------

- Now, if we go one level up and execute the last command, we're going to get an error
because we already have the test directory.
But the other two commands will get executed. Take a look.
So, look, here's the error saying
the test directory exists, but we also see the done message
and we're currently inside the test directory.
-------------------code---------------------
root@8a65a7f2dd58:~/test# cd ..
root@8a65a7f2dd58:~# mkdir test;cd test;echo done
mkdir: cannot create directory 'test': File exists
done
-------------------code---------------------

- Now, what if we want to stop execution? So, if one command
fails, the other commands are not going to get executed.
Well, this is where we use the and operator.
Now, instead of a semicolon, we're going to use
double ampersands. That is the and operator.
So, if this command fails, the other commands will not get executed.
Take a look. Alright, we saw an error
saying the directory exists, but we're still inside the home directory.
We didn't go inside the test directory.
-------------------code---------------------
root@8a65a7f2dd58:~# mkdir test && cd test && echo done
mkdir: cannot create directory 'test': File exists
root@8a65a7f2dd58:~#
-------------------code---------------------

- Now, we also have the or operator. So, if we say
create the test directory or echo
directory exists. If this command gets executed,
this command will not get executed. But if this command fails,
this command gets executed. Make sense?
So, essentially it's saying create this directory
or print directory exists. Let's try it.
So, we got this message because the directory already exists.
-------------------code---------------------
root@8a65a7f2dd58:~# mkdir test || echo "directory exists"
mkdir: cannot create directory 'test': File exists
directory exists
-------------------code---------------------

- But if we bring up this command and change the directory name to test2,
this time we are not going to see this message
because we can successfully create this directory.
-------------------code---------------------
root@8a65a7f2dd58:~# mkdir test2 || echo "directory exists"
-------------------code---------------------

- So, these techniques are very powerful.
we use them a lot when it comes to deploying our applications using docker.
we'll see more examples in the future.

- Now, another way to chain commands is piping.
And this is extremely powerful. So, let's look at the content of
the bin directory. So, here we have a long list of files,
but what if we want to look at this list using the less command. So, remember
earlier we talked about the less command. With this we can look at the content of a file
and then we have the ability to scroll up and down or go line by line and then quit.
This is where we can use piping.
So, we use the ls command, get the content of the bin directory
and then create a pipe. So, we get the output of this command
and then send it to the less command.
to the less command. So, essentially we're creating a pipe.
What comes out of this command
goes into the second command. So, now less doesn't need a file name
because it gets the input from the first command.
So, now we're seeing the output of the less command using the up and down arrows
we can scroll using space we can go to the next page
and then we can exit using q.
-------------------code---------------------
root@8a65a7f2dd58:~# ls /bin | less
-------------------code---------------------

- We can also use the head and tail commands here.
Pretty much any commands. So, if we use head
by default we can see the first ten lines
-------------------code---------------------
root@8a65a7f2dd58:~# ls /bin | head
[
addpart
apt
apt-cache
apt-cdrom
apt-config
apt-get
apt-key
apt-mark
arch
-------------------code---------------------

- we can supply an option and see the first five lines.
Pretty useful.
-------------------code---------------------
root@8a65a7f2dd58:~# ls /bin | head -n 5
[
addpart
apt
apt-cache
apt-cdrom
-------------------code---------------------


- Now, one last thing before we finish this lesson.
Sometimes when dealing with a long command
our command sequence might look a little bit hard to read.
how we can split it into multiple lines. So, we're going to create a directory called
hello, then we're going to go into this directory and echo
done. Now, this is a fairly short command
but imagine this was really long and we had to scroll horizontally.
We don't want to do that. So, we create a directory
and then terminate this command using a semicolon. Now, if we type a backslash
and press enter, we go to the second line and the command prompt changes
so we can type the rest of the command here. Now, we're going to go to the hello directory
and terminate this command
and add a backslash so on the third line
we can echo done. And of course,
we can keep going as much as we want.
So, this is how we can break up a long command
into multiple lines by using a backslash.

-------------------code---------------------
root@8a65a7f2dd58:~# mkdir hello;\
> cd hello;\
> echo done
done
-------------------code---------------------

*** 13- Environment Variables ***

- Let's talk about environment variables. This is one of the areas that a lot
of people are confused about. So just like we have variables in our programming languages
in Linux, we have environment variables which we can set
for storing configuration settings for our applications. So our
applications can read configuration settings from these environment variables.
In this lesson, we're going to show we a few different commands for viewing all these environment
variables and setting them.

- So the first command is print
env, with this we can see all the environment variables in this machine.
Take a look. So, let me scroll up.
Alright, so here we have a bunch of key value pairs separated by an equal
sign. The first variable is host name which is set to the
idea of our container. And as we know, this is generated by docker automatically.
Then we have pwd, home, ls callers and so on. Now down below
we have a very important environment variable called path.
-------------------code---------------------
root@8a65a7f2dd58:~# printenv
HOSTNAME=8a65a7f2dd58
PWD=/root
HOME=/root
LS_COLORS=rs=0:di=01;34:ln=01;36:mh=00:pi=40;33:so=01;35:do=01;35:bd=40;33;01:cd=40;33;01:or=40;31;01:mi=00:su=37;41:sg=30;43:ca=00:tw=30;42:ow=34;42:st=37;44:ex=01;32:*.tar=01;31:*.tgz=01;31:*.arc=01;31:*.arj=01;31:*.taz=01;31:*.lha=01;31:*.lz4=01;31:*.lzh=01;31:*.lzma=01;31:*.tlz=01;31:*.txz=01;31:*.tzo=01;31:*.t7z=01;31:*.zip=01;31:*.z=01;31:*.dz=01;31:*.gz=01;31:*.lrz=01;31:*.lz=01;31:*.lzo=01;31:*.xz=01;31:*.zst=01;31:*.tzst=01;31:*.bz2=01;31:*.bz=01;31:*.tbz=01;31:*.tbz2=01;31:*.tz=01;31:*.deb=01;31:*.rpm=01;31:*.jar=01;31:*.war=01;31:*.ear=01;31:*.sar=01;31:*.rar=01;31:*.alz=01;31:*.ace=01;31:*.zoo=01;31:*.cpio=01;31:*.7z=01;31:*.rz=01;31:*.cab=01;31:*.wim=01;31:*.swm=01;31:*.dwm=01;31:*.esd=01;31:*.avif=01;35:*.jpg=01;35:*.jpeg=01;35:*.mjpg=01;35:*.mjpeg=01;35:*.gif=01;35:*.bmp=01;35:*.pbm=01;35:*.pgm=01;35:*.ppm=01;35:*.tga=01;35:*.xbm=01;35:*.xpm=01;35:*.tif=01;35:*.tiff=01;35:*.png=01;35:*.svg=01;35:*.svgz=01;35:*.mng=01;35:*.pcx=01;35:*.mov=01;35:*.mpg=01;35:*.mpeg=01;35:*.m2v=01;35:*.mkv=01;35:*.webm=01;35:*.webp=01;35:*.ogm=01;35:*.mp4=01;35:*.m4v=01;35:*.mp4v=01;35:*.vob=01;35:*.qt=01;35:*.nuv=01;35:*.wmv=01;35:*.asf=01;35:*.rm=01;35:*.rmvb=01;35:*.flc=01;35:*.avi=01;35:*.fli=01;35:*.flv=01;35:*.gl=01;35:*.dl=01;35:*.xcf=01;35:*.xwd=01;35:*.yuv=01;35:*.cgm=01;35:*.emf=01;35:*.ogv=01;35:*.ogx=01;35:*.aac=00;36:*.au=00;36:*.flac=00;36:*.m4a=00;36:*.mid=00;36:*.midi=00;36:*.mka=00;36:*.mp3=00;36:*.mpc=00;36:*.ogg=00;36:*.ra=00;36:*.wav=00;36:*.oga=00;36:*.opus=00;36:*.spx=00;36:*.xspf=00;36:*~=00;90:*#=00;90:*.bak=00;90:*.crdownload=00;90:*.dpkg-dist=00;90:*.dpkg-new=00;90:*.dpkg-old=00;90:*.dpkg-tmp=00;90:*.old=00;90:*.orig=00;90:*.part=00;90:*.rej=00;90:*.rpmnew=00;90:*.rpmorig=00;90:*.rpmsave=00;90:*.swp=00;90:*.tmp=00;90:*.ucf-dist=00;90:*.ucf-new=00;90:*.ucf-old=00;90:
TERM=xterm
SHLVL=1
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
_=/usr/bin/printenv
OLDPWD=/root/hello
-------------------code---------------------

- Have we noticed that sometimes when we run a program from the command line
we get an error saying the program or the command was not found. Even though
we have installed that program. Quite often that happens because our operating
system, whether it's Linux or Windows cannot find that program. Now,
here's the interesting part. To find a program, our operating system is
not going to go through our entire hard drive, it's only going to look at specific
directories. And those directories are specified using the
pass variable. So this is set to a list of directories separated by colon. So, here's the
first directory, then we have a colon,
here's the second directory and so on. These are the directories that Linux
or Windows searches for to find a program or a command.
-------------------code---------------------
PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
-------------------code---------------------

- Now, what if we want to see the value of a particular variable?
We can type printenv and then path. That's another
way. Now, once again everything is case sensitive here,
so if we type path in lowercase, we're not going to see anything. Okay?
-------------------code---------------------
root@8a65a7f2dd58:~# printenv PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
root@8a65a7f2dd58:~# printenv pATH
root@8a65a7f2dd58:~#
-------------------code---------------------

- Now there's another way to see the value of an environment variable.
Instead of printenv, we can use echo, but here we have to
prefix the variable with a dollar sign. So Linux knows that, we're
referring to an environment variable like path. 
-------------------code---------------------
root@8a65a7f2dd58:~# echo $PATH
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
-------------------code---------------------

- Now, how can we set a variable? Using the
export command. So let's define a variable called db
underline user, and we're going to set that to Moody. Now this variable is stored
in the current session, in the current terminal session. So we can
read it using the echo command, db user. We can also read it using printenv.
-------------------code---------------------
root@8a65a7f2dd58:~# export DB_USER=Moody
root@8a65a7f2dd58:~# echo $DB_USER
Moody
root@8a65a7f2dd58:~# printenv DB_USER
Moody
-------------------code---------------------

- However,this variable is only available in the current terminal session. So
if we close this terminal session, and open a new terminal session, this
variable will not exist.So, we can terminate this session
by typing exit.
-------------------code---------------------
root@8a65a7f2dd58:~# exit
exit
-------------------code---------------------

- Now we're outside of our container environment, so we're back on my Mac
terminal. Now, let's run docker ps to see all the docker processes or containers.
There's nothing here, our container is stopped. Now, to see all the containers, including
stopped containers, we type docker ps dash a, that is short for all.
So we have two stopped containers, one was running our ubuntu image,
and the other was running hello docker. This container was the one
that we have been working with throughout this section.
-------------------code---------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
~  $ docker ps -a
CONTAINER ID   IMAGE          COMMAND                   CREATED        STATUS                      PORTS     NAMES
8a65a7f2dd58   ubuntu         "/bin/bash"               2 hours ago    Exited (0) 24 seconds ago             eloquent_lichterman
ee871cc6ca5f   ubuntu         "/bin/bash"               14 hours ago   Exited (129) 11 hours ago             naughty_mclean
cc3ce42ddbf2   ubuntu         "/bin/bash"               14 hours ago   Exited (0) 14 hours ago               fervent_golick
8ee68b73826f   hello-docker   "docker-entrypoint.sâ€¦"   15 hours ago   Exited (0) 15 hours ago               busy_brown
-------------------code---------------------

- Now we want to start this container so we can work with it again.
So, just like virtual machines, we can stop or start a container.
Okay? So, look at this container id,  "8a6 "whatever.
we're going to grab the first few letters 8a6. So,
to start this container we type docker start, we use dash i so we can interact with it,
and then type the container id. Quite often we can type only the first
two or three letters, unless there is another container whose id
starts with the same sequence of characters. Then we have to type more characters.
Okay? So, let's start it again, we are back in the same Linux machine.
-------------------code---------------------
docker start -i 8a6
-------------------code---------------------

- now if we type echo db underline user, we don't see anything. Because that 
variable does not exist anymore, it was only available in that terminal session.
-------------------code---------------------
root@8a65a7f2dd58:/# printenv DB_USER
-------------------code---------------------


- Now, to make it persistent we have to write it to a special file.
So, we go to our home directory, now we list all the files, including hidden files.
Earlier we saw this file, bashrc. This file is a user's
personal startup file. So, every time a user logs in, Linux
loads this command from the user's home directory. So, this is where we
have to write permanent environment variables.
-------------------code---------------------
root@8a65a7f2dd58:/# cd ~
root@8a65a7f2dd58:~# ls -a
.   .bash_history  .lesshst  .profile      etc_files.tsxt  file2.txt  hello.txt         test
..  .bashrc        .local    combined.txt  file1.txt       hello      python-files.txt  test2
-------------------code---------------------

- Now, we can edit this using nano, so nano.bashrc.
-------------------code---------------------
root@8a65a7f2dd58:~# nano .bashrc
-------------------code---------------------

- or another technique. Earlier we talked about
redirection. So, using echo, we want to write something
to this file. we want to set db underline user to mosh, and then we want to redirect
the result to .bashrc. Don't execute this yet.
Because if we do this, we will overwrite the entire bash rc file. We don't want to
overwrite it here, we want to append something to it.
-------------------code---------------------
root@8a65a7f2dd58:~# echo DB_USER=Moody > .bashrc
-------------------code---------------------


- So, we add another greater than sign,
and this will append db user to bashrc.
-------------------code---------------------
root@8a65a7f2dd58:~# echo DB_USER=Moody >> .bashrc
-------------------code---------------------

- Now to verify our work, let's look at bash c. So,
take a look. The last line contains our permanent environment variable.
-------------------code---------------------
root@8a65a7f2dd58:~# tail .bashrc
    . ~/.bash_aliases
fi

# enable programmable completion features (we don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
#if [ -f /etc/bash_completion ] && ! shopt -oq posix; then
#    . /etc/bash_completion
#fi
DB_USER=Moody
-------------------code---------------------

- And of course, we can always come back and
change this value. Now, one thing we want to emphasize here is that we should never
store sensitive information in environment variables. Because at the end of the day,
these variables are stored in plain text files.
So, we don't want to store db password here, because anyone who has
access to this machine can read the db password. So, just be aware of
this, we think most software engineers have made this mistake at least once in
their career, and we're no exception.

- So, we have set db user permanently in this file. Now,
if we exit, and open a new terminal session, we can still
read the value of that variable. So,
let's look at all the stop containers.
-------------------code---------------------
root@8a65a7f2dd58:~# exit
exit
~  $ docker start -i 8a6
root@8a65a7f2dd58:/# echo $DB_USER
Moody
-------------------code---------------------

- one last thing before we finish
this lesson. The changes we make to bashrc file are only effective
in the next terminal session. So, if we write another environment variable
here, that variable is not going to be available until we open
another terminal session. 


- now that variable is not there
even though we wrote it to this file.
Because this file is loaded only once
when we start a terminal session.
-------------------code---------------------
root@8a65a7f2dd58:/# cd ~
root@8a65a7f2dd58:~# echo COLOR=blue >> .bashrc
root@8a65a7f2dd58:~# echo $COLOR

root@8a65a7f2dd58:~#
-------------------code---------------------

- So, now we have two solutions. We can terminate the session and come back in.
Or, we can use the source command to reload the bashrc file.
And we have to execute this from our home directory.
-------------------code---------------------
root@8a65a7f2dd58:~# source .bashrc
root@8a65a7f2dd58:~# echo $COLOR
blue
-------------------code---------------------

- If we're not in our home directory, we can type
source home directory
-------------------code---------------------
root@8a65a7f2dd58:~# source ~/.bashrc
-------------------code---------------------

*** 14- Managing Processes ***

- Let's talk about processes. A process
is an instance of a running program. To see all the running programs
or all the running processes, we can use the ps command.


- So, we have two processes, one is running bash, the other
is running ps. Now technically ps was a very short
lived process, it only exists that while this command
was producing this output. So now it doesn't exist anymore.
-------------------code---------------------
root@8a65a7f2dd58:~# ps
  PID TTY          TIME CMD
    1 pts/0    00:00:00 bash
   24 pts/0    00:00:00 ps
-------------------code---------------------

- However, if we run ps one more time, we see ps again, because
once again, while ps was preparing this command, it was being executed.
-------------------code---------------------
root@8a65a7f2dd58:~# ps
  PID TTY          TIME CMD
    1 pts/0    00:00:00 bash
   25 pts/0    00:00:00 ps
-------------------code---------------------

- So, technically the only process that is running right now
is bash. Bash is short for born again shell. It's the program that we're interacting with here.
The program that takes our commands and sends them to Linux for execution.
That's bash. Now as we can see, each process has a unique identifier that is generated by the operating system.
Now what is TTY? That is short for teletype. And over here we can see the type of terminal
the user is logged into. So, PTS is short for pseudo terminal. Don't worry about
what it really means, there is some long history. But a short explanation is that this kind of terminal window that we are using,
this is called a pseudo terminal.


- So, PTS slash zero, that represents
the first terminal window. So, if we open another terminal window
and start this container and then execute the same command, we're going to see
PTS slash one. So, in this column, we can see
which terminal the user is logged into.

- Now, time is the amount of CPU time each
process consumed. So, both these processes are very lightweight, they're not
taking much of CPU time. 

- But sometimes we notice our system getting slow,
that's because some process is taking
so much of CPU time. In that case, we want to kill that process.
Let me show we how to do that. First, we want to create a process and put it in the background.
So, in Linux we have the sleep command. If we
type sleep 3, now the prompt sleeps for 3
seconds and then wakes up.
-------------------code---------------------
root@8a65a7f2dd58:~# sleep 3
-------------------code---------------------

- Now, what if we want to put this in the background
so we can execute other commands? We append an ampersand.
-------------------code---------------------
root@8a65a7f2dd58:~# sleep 3 &
[1] 27
-------------------code---------------------

- Now, this is in the background
and we can execute other commands.
So, let's run sleep with a longer wait, let's say 100 seconds
and we want to put this in the background.
-------------------code---------------------
root@8a65a7f2dd58:~# sleep 100 &
[2] 28
-------------------code---------------------

- Now, if we run PS, we can see the sleep
command. As we can see, this command is not taking much of CPU time, so it's a light process.
-------------------code---------------------
root@8a65a7f2dd58:~# ps
  PID TTY          TIME CMD
    1 pts/0    00:00:00 bash
   28 pts/0    00:00:00 sleep
   29 pts/0    00:00:00 ps
-------------------code---------------------

- But let's say we want to kill this. This is
where we use the kill command and here we specify the
process ID for the bad boy.
So, that is 28. Now, that is gone. So, let's run PS one more time.
That process is terminated.
-------------------code---------------------
root@8a65a7f2dd58:~# kill 28
[2]+  Terminated              sleep 100
root@8a65a7f2dd58:~# ps
  PID TTY          TIME CMD
    1 pts/0    00:00:00 bash
   30 pts/0    00:00:00 ps
-------------------code---------------------

*** 15- Managing Users ***

- Alright, let's talk about managing users.
So in this lesson, we're going to show we how to create a new user and then login
as that user.

- So in Linux we have this command
user add for adding a new user. We also have user
mod for modifying a user and user del
for deleting a user. 
-------------------code---------------------
useradd
usermod
userdel
-------------------code---------------------

- So we're going to call user add.
Now let's look at the options. Here we have a bunch of options and none of them are managed.
We can use them based on our needs. In this lesson
we're going to use an option. This one.
Each option as we can see has two forms. The short form
with one hyphen and the long
descriptive form with two hyphens. Different people have
different preferences. So with this option
we can create the home directory for this user.
-------------------code---------------------
root@8a65a7f2dd58:/# useradd
Usage: useradd [options] LOGIN
       useradd -D
       useradd -D [options]

Options:
      --badname                 do not check for bad names
  -b, --base-dir BASE_DIR       base directory for the home directory of the
                                new account
      --btrfs-subvolume-home    use BTRFS subvolume for home directory
  -c, --comment COMMENT         GECOS field of the new account
  -d, --home-dir HOME_DIR       home directory of the new account
  -D, --defaults                print or change default useradd configuration
  -e, --expiredate EXPIRE_DATE  expiration date of the new account
  -f, --inactive INACTIVE       password inactivity period of the new account
  -F, --add-subids-for-system   add entries to sub[ud]id even when adding a system user
  -g, --gid GROUP               name or ID of the primary group of the new
                                account
  -G, --groups GROUPS           list of supplementary groups of the new
                                account
  -h, --help                    display this help message and exit
  -k, --skel SKEL_DIR           use this alternative skeleton directory
  -K, --key KEY=VALUE           override /etc/login.defs defaults
  -l, --no-log-init             do not add the user to the lastlog and
                                faillog databases
  -m, --create-home             create the user's home directory
  -M, --no-create-home          do not create the user's home directory
  -N, --no-user-group           do not create a group with the same name as
                                the user
  -o, --non-unique              allow to create users with duplicate
                                (non-unique) UID
  -p, --password PASSWORD       encrypted password of the new account
  -r, --system                  create a system account
  -R, --root CHROOT_DIR         directory to chroot into
  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
  -s, --shell SHELL             login shell of the new account
  -u, --uid UID                 user ID of the new account
  -U, --user-group              create a group with the same name as the user
  -Z, --selinux-user SEUSER     use a specific SEUSER for the SELinux user mapping
      --extrausers              Use the extra users database
-------------------code---------------------

- So we're going to say user add and the name of the user is John.
-------------------code---------------------
root@8a65a7f2dd58:/# useradd -m john 
-------------------code---------------------

Where is this user? Well, this user is stored
in a configuration file in the etsy directory.
So using cat we can look at that
cat slash etsy slash password.
Now the name is misleading. Passwords are not stored here.
We only have user account information. So take a look.
So down below. We have John. So we have multiple fields
separated by a colon. First we have the user name.
Then we have a colon as a separator.
X means the password is stored somewhere else.
we'll show we that in a second. Then we have this field.
That's the user ID. Now on our machine we're probably going to see
So John's ID is 1001. Then we have the group ID. We'll talk about this in the next lesson.
Over here we have the home directory of this user.
So slash home slash John. And then we have the shell program used
when this user logs in. So slash bin slash shell represents
the old original shell program.
-------------------code---------------------
root@8a65a7f2dd58:/# cat /etc/passwd
root:x:0:0:root:/root:/bin/bash
daemon:x:1:1:daemon:/usr/sbin:/usr/sbin/nologin
bin:x:2:2:bin:/bin:/usr/sbin/nologin
sys:x:3:3:sys:/dev:/usr/sbin/nologin
sync:x:4:65534:sync:/bin:/bin/sync
games:x:5:60:games:/usr/games:/usr/sbin/nologin
man:x:6:12:man:/var/cache/man:/usr/sbin/nologin
lp:x:7:7:lp:/var/spool/lpd:/usr/sbin/nologin
mail:x:8:8:mail:/var/mail:/usr/sbin/nologin
news:x:9:9:news:/var/spool/news:/usr/sbin/nologin
uucp:x:10:10:uucp:/var/spool/uucp:/usr/sbin/nologin
proxy:x:13:13:proxy:/bin:/usr/sbin/nologin
www-data:x:33:33:www-data:/var/www:/usr/sbin/nologin
backup:x:34:34:backup:/var/backups:/usr/sbin/nologin
list:x:38:38:Mailing List Manager:/var/list:/usr/sbin/nologin
irc:x:39:39:ircd:/run/ircd:/usr/sbin/nologin
_apt:x:42:65534::/nonexistent:/usr/sbin/nologin
nobody:x:65534:65534:nobody:/nonexistent:/usr/sbin/nologin
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash
john:x:1001:1001::/home/john:/bin/sh
-------------------code---------------------

- But we also have bash which is born again shell
which is the enhanced version of this program.
Okay? Now let's say when we log in
instead of using shell, we want to use bash.
So we're going to use user mod to modify this record.
So, let's look at user mod. The option that we're going to use in this lesson is
dash s or shell. This is for setting the shell for this user.
-------------------code---------------------
root@8a65a7f2dd58:/# usermod
Usage: usermod [options] LOGIN

Options:
  -a, --append                  append the user to the supplemental GROUPS
                                mentioned by the -G option without removing
                                the user from other groups
  -b, --badname                 allow bad names
  -c, --comment COMMENT         new value of the GECOS field
  -d, --home HOME_DIR           new home directory for the user account
  -e, --expiredate EXPIRE_DATE  set account expiration date to EXPIRE_DATE
  -f, --inactive INACTIVE       set password inactive after expiration
                                to INACTIVE
  -g, --gid GROUP               force use GROUP as new primary group
  -G, --groups GROUPS           new list of supplementary GROUPS
  -h, --help                    display this help message and exit
  -l, --login NEW_LOGIN         new value of the login name
  -L, --lock                    lock the user account
  -m, --move-home               move contents of the home directory to the
                                new location (use only with -d)
  -o, --non-unique              allow using duplicate (non-unique) UID
  -p, --password PASSWORD       use encrypted password for the new password
  -P, --prefix PREFIX_DIR       prefix directory where are located the /etc/* files
  -r, --remove                  remove the user from only the supplemental GROUPS
                                mentioned by the -G option without removing
                                the user from other groups
  -R, --root CHROOT_DIR         directory to chroot into
  -s, --shell SHELL             new login shell for the user account
  -u, --uid UID                 new UID for the user account
  -U, --unlock                  unlock the user account
  -v, --add-subuids FIRST-LAST  add range of subordinate uids
  -V, --del-subuids FIRST-LAST  remove range of subordinate uids
  -w, --add-subgids FIRST-LAST  add range of subordinate gids
  -W, --del-subgids FIRST-LAST  remove range of subordinate gids
  -Z, --selinux-user SEUSER     new SELinux user mapping for the user account
-------------------code---------------------


- So, we're going to say to modify the shell for the user jhon to /bin/bash
-------------------code---------------------
root@8a65a7f2dd58:/# usermod -s /bin/bash john
-------------------code---------------------

-  now to check that it's changed
-------------------code---------------------
root@8a65a7f2dd58:/# tail -n 2 /etc/passwd
ubuntu:x:1000:1000:Ubuntu:/home/ubuntu:/bin/bash
john:x:1001:1001::/home/john:/bin/bash
-------------------code---------------------

- Now where are the passwords?
Well, in the same directory we have another file
that is shadow. So, this is where
passwords are stored in encrypted format. we don't know how this really works.
But just be aware of this file, this file is only accessible to the root user.
-------------------code---------------------
root@8a65a7f2dd58:/# tail -n 2 /etc/shadow
ubuntu:!:20115:0:99999:7:::
john:!:20165:0:99999:7:::
-------------------code---------------------

- Now let's say we want to log in as John.
How do we do that? So, we open up a new terminal window
to log into our container as John. First we run docker ps
to see the running containers.
-------------------code---------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED        STATUS         PORTS     NAMES
8a65a7f2dd58   ubuntu    "/bin/bash"   11 hours ago   Up 6 minutes             eloquent_lichterman
-------------------code---------------------

- So, here's our container id.
Now we're going to execute a bash session
inside this container. So, we type docker
execute then we paste the container id
or we can type the first few letters.

- Now, we want to run a bash session here.
Now if we press enter, nothing happens
because we didn't interact with bash. so, we have to specify
dash it interactive.

- Now if we run this,
we'll log in as root. So now we have
two bash sessions, one is in this window,
the other is in this other window.
-------------------code---------------------
~  $ docker exec 8a65a7f2dd58 bash
~  $ docker exec -it 8a65a7f2dd58 bash
root@8a65a7f2dd58:/#
-------------------code---------------------

- Now, we don't want to log in as root, we want to log in as John.
So, let's terminate this session one more time.
You're going to execute a bash session in this container,
but before the container name, we're going to supply another option
for specifying the user.
-------------------code---------------------
~  $ docker exec -it -u john 8a65a7f2dd58 bash
john@8a65a7f2dd58:/$
-------------------code---------------------

Now, we've logged in as John, we can see that.
So, John at, and here's the container id which acts like the host name.

- Now, look at the prompt. Here we have a dollar sign,
which means, we're not a root user.
we're just a regular user. In contrast,
in this other window, where we logged in as root,
we have a pound.
-------------------code---------------------
root@8a65a7f2dd58:/#
john@8a65a7f2dd58:/$
-------------------code---------------------


- So, here we have extra privileges. So,
back to John's window,
let's see what happens if we try to access the shadow file.
We get a permission denied error.
So, this verifies that we're not a root user.
-------------------code---------------------
john@8a65a7f2dd58:/$ cat /etc/shadow
cat: /etc/shadow: Permission denied
-------------------code---------------------

- Also, John has a home directory,
so, if we type
cd tilde, we go to John's home directory.
Let's look at the path for this directory.
So, that is home slash John.
So, in this directory, we can store John's files.
-------------------code---------------------
john@8a65a7f2dd58:/$ cd ~
john@8a65a7f2dd58:~$ pwd
/home/john
-------------------code---------------------

- And when we are done, we can remove John by typing user del John.
Now, we're not going to delete John,
because in the next lesson, we're going to add John to a group.
So, we're going to keep him for now.

-------------------code---------------------
john@8a65a7f2dd58:~$ userdel john
-------------------code---------------------

