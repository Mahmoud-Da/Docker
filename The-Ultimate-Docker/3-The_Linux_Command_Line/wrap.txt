*** 1- Introduction ***
All right, the next stop in our journey is the Linux command line.

- But why Linux? What if we're a Windows user?
Well, we still need to know a bit of Linux for a number of reasons.
For starters, Docker has its foundations built on top of basic Linux concepts.
So if we want to be productive and troubleshoot issues easily,
we need to know some of the basic Linux commands.

- Also, most tutorials online are based on Linux commands.
So if we don't understand these basic commands, we're not going to get far.
learning Linux is like learning English.
so everybody should know some English these days.
we don't need to speak it or write a book in it, but we need to understand it.
So unless we're a power Linux user, do not skip this section.
It's going to be super easy and extremely useful.
So let's jump in and get started.

*** 2- Linux Distributions ***

- Let's start off this section by talking about Linux distributions, 
also called Linux distros.

- So, as we probably know, Linux is open source software.
And for this reason, many individuals and communities
have created their own version of Linux called Linux distributions.

- Each of these distributions is made to fit specialized needs
like running servers, desktop computers, mobile phones and so on.

- So we have Ubuntu, which is one of the most popular Linux distributions.
We also have Debian, Alpine, which we briefly talked about, it's a very small Linux distribution.

- We also have Fedora, CentOS and so on.

- Believe it or not, there are more than a thousand Linux distributions out there.

- Now, most of these distributions support pretty much the same set of commands,
but sometimes we might discover differences along the way. So be aware of that.

- In this section, we're going to use Ubuntu Linux because it's one of the most popular distributions.
But if we have a preference for another distribution, that's totally fine.

*** 3- Running Linux ***
Alright, let's see how we can run Ubuntu on this machine.

- So, we go to hub.docker.com 
-------------------code----------------------
https://hub.docker.com/
-------------------code----------------------


- and search for Ubuntu. Over here we can see the official Ubuntu image
that's been downloaded more than 10 million times. 


- Let's have a quick look here.
So, for each image, we can see the command to pull
that image onto our machine.
-------------------code----------------------
$ docker pull ubuntu
-------------------code----------------------

- Now in this lesson, we're not going to use the pull command,
we're going to show we a shortcut. So, here in the terminal, instead of
running docker pull Ubuntu, we're going to run docker run Ubuntu.
-------------------code----------------------
$ docker run ubuntu
-------------------code----------------------

- Now, if we have this image
locally, docker is going to store the container with this image, otherwise
it's going to pull this image behind the scene and then store the container. 

- see, docker is unable to find this image locally, and now it's pulling it from docker hop.
-------------------code----------------------
$ docker run ubuntu
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
5b17151e9710: Pull complete
Digest: sha256:72297848456d5d37d1262630108ab308d3e9ec7ed1c3286a32fe09856619a782
Status: Downloaded newer image for ubuntu:latest
-------------------code----------------------

- Now, what happened? Well, docker started a container,
but because we didn't interact with this container, the container stopped.

- to prove this. So, if we run docker ps, we can see the list of running processes
or running containers. Look, we don't have any containers running here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- but if we type docker ps dash a for all, we can see the stopped containers
as well. So we have two stopped containers. The first one is
using the Ubuntu image, this is the one that we just started.
And the second one is hello docker, which we started
earlier in the course.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                   CREATED              STATUS                          PORTS     NAMES
cc3ce42ddbf2   ubuntu         "/bin/bash"               About a minute ago   Exited (0) About a minute ago             fervent_golick
8ee68b73826f   hello-docker   "docker-entrypoint.sâ€¦"   2 hours ago          Exited (0) 2 hours ago                    busy_brown
-------------------code----------------------

- So, to start a container and interact with it, we have to type docker run dash
it, that is short for interactive. We're going to start a container
in the interactive mode. And in this container
we're going to load the Ubuntu image which we have locally.
-------------------code----------------------
$ docker run -it ubuntu
root@ee871cc6ca5f:/#
-------------------code----------------------

- Now, what we have here is called
the shell. A shell is a program that takes our commands
and passes them to the operating system for execution.
Now, what we have here is called the shell prompt.

- the first part root represents the currently logged in user,
so by default we're logged in as the root user which has the highest privileges.
Then after the add sign, we have the name of the machine. So, this container has this
ID which is automatically generated by docker and in this case, it's like the name of a machine.
Okay? Then after the colon, we can see forward slash, that represents where we are in the file system.
A forward slash represents the root directory. That is the highest directory in the file system.
Then we have a pound "#" and this means we have the highest privileges because we've logged in as the root user.
If we logged in as a normal user, instead of a pound we would see a dollar sign "$".
-------------------code----------------------
root@ee871cc6ca5f:/#
-------------------code----------------------

- So, in this shell, we can execute a bunch of commands
for example, we can say echo, hello and this prints hello on the terminal.
-------------------code----------------------
root@ee871cc6ca5f:/# echo hello
hello
-------------------code----------------------

We can also say "whoami", This shows the current user.
-------------------code----------------------
root@ee871cc6ca5f:/# whoami
root
-------------------code----------------------

- So these commands that we're running here, this shell program that we told we about
takes these commands and passes them to the kernel for execution.
If we type echo dollar sign zero, we can see the location of this shell program.
Take a look. So, that is forward slash bin slash bash.
-------------------code----------------------
root@ee871cc6ca5f:/# echo $0
/bin/bash
-------------------code----------------------

- So bin is a folder or a directory and inside this directory, we have a program called bash
which is short for born again shell.
So apparently, Steve Bourne is the first person
who created a shell program. Bash or born again shell
is a reference to Steve Bourne.

- So bash is an enhanced version of the original shell program.
Now one thing we probably notice is that in Linux
we use a forward slash to separate files and directories.
But in Windows, we use a backslash.

- So that's one of the first differences.
The other difference is that Linux is a case sensitive operating system.
So if we type echo with a capital E,
it's not going to work.

- Bash tells us echo command not found.
So lowercase and uppercase letters are different.
And this is not limited to commands, it's applicable everywhere.
-------------------code----------------------
Echo $0
bash: Echo: command not found
-------------------code----------------------

- If we want to reference a file or a directory or a user,
pretty much anything, we should always spell it properly
with the right uppercase and lowercase letters.


- Using the up and down arrows,
we can go through the commands we have executed so far.
So this is a pretty useful shortcut we need to know
because we don't want to type these commands manually all the time.


- Also, using the history command,
we can see all the commands we have executed lately.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
-------------------code----------------------


- So, take a look.
So earlier we used whoami,
we also used echo and so on.
Now we can replay any of these commands
by typing an exclamation mark,
followed by the command number.
So if we type 2,
this is exactly like running whoami.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
root@ee871cc6ca5f:/# !2
whoami
root
-------------------code----------------------

*** 4- Managing Packages ***

- These days, most operating systems
and development platforms come with a package manager. we've probably
worked with tools like npm, yarn, pip, and so on.

- Here in Ubuntu, we also have a package manager called apt, which is short
for advanced package tool. So let's execute this command.
Look, this command has a bunch of subcommands.
-------------------code----------------------
root@ee871cc6ca5f:/# apt
apt 2.7.14 (arm64)
Usage: apt [options] command

apt is a commandline package manager and provides commands for
searching and managing as well as querying information about packages.
It provides the same functionality as the specialized APT tools,
like apt-get and apt-cache, but enables options more suitable for
interactive use by default.

Most used commands:
  list - list packages based on package names
  search - search in package descriptions
  show - show package details
  install - install packages
  reinstall - reinstall packages
  remove - remove packages
  autoremove - automatically remove all unused packages
  update - update list of available packages
  upgrade - upgrade the system by installing/upgrading packages
  full-upgrade - upgrade the system by removing/installing/upgrading packages
  edit-sources - edit the source information file
  satisfy - satisfy dependency strings

See apt(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- So using list, we can see the list of packages, we can also search
for them, we can show details about the package, we can install, reinstall
and remove a package and so on. Now technically, apt is the
newer package manager. We also have apt-get, which we see a lot
in online tutorials.
-------------------code----------------------
root@ee871cc6ca5f:/# apt-get
apt 2.7.14 (arm64)
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a command line interface for retrieval of packages
and information about them from authenticated sources and
for installation, upgrade and removal of packages together
with their dependencies.

Most used commands:
  update - Retrieve new lists of packages
  upgrade - Perform an upgrade
  install - Install new packages (pkg is libc6 not libc6.deb)
  reinstall - Reinstall packages (pkg is libc6 not libc6.deb)
  remove - Remove packages
  purge - Remove packages and config files
  autoremove - Remove automatically all unused packages
  dist-upgrade - Distribution upgrade, see apt-get(8)
  dselect-upgrade - Follow dselect selections
  build-dep - Configure build-dependencies for source packages
  satisfy - Satisfy dependency strings
  clean - Erase downloaded archive files
  autoclean - Erase old downloaded archive files
  check - Verify that there are no broken dependencies
  source - Download source archives
  download - Download the binary package into the current directory
  changelog - Download and display the changelog for the given package

See apt-get(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- Going forward, we're going to use apt because it's
easier to work with. So let's say we want to install a package called
nano. Nano is a basic text editor for Linux. Now if we press enter here,
we get an error because this image, this ubuntu image we are running
does not have nano. 
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: nano: command not found
-------------------code----------------------

- So this is where we use apt to install this package.
So if we type apt install nano, we get an error saying, unable to locate package nano.
-------------------code----------------------
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
E: Unable to locate package nano
-------------------code----------------------

- Why is this happening? Well, here in Linux, we have a package database
and this database might contain hundreds of packages, but not all these packages
are installed. So if we want to see all the packages in this database,
we type apt list. Look, these are all the packages. Now in front of these packages,
we can see some of them are installed. But not all packages in this database
are installed. 
-------------------code----------------------
root@ee871cc6ca5f:/# apt list
Listing... Done
apt/now 2.7.14build2 arm64 [installed,local]
base-files/now 13ubuntu10.1 arm64 [installed,local]
base-passwd/now 3.6.3build1 arm64 [installed,local]
bash/now 5.2.21-2ubuntu4 arm64 [installed,local]
bsdutils/now 1:2.39.3-9ubuntu6.2 arm64 [installed,local]
coreutils/now 9.4-3ubuntu6 arm64 [installed,local]
dash/now 0.5.12-6ubuntu5 arm64 [installed,local]
debconf/now 1.5.86ubuntu1 all [installed,local]
debianutils/now 5.17build1 arm64 [installed,local]
diffutils/now 1:3.10-1build1 arm64 [installed,local]
dpkg/now 1.22.6ubuntu6.1 arm64 [installed,local]
e2fsprogs/now 1.47.0-2.4~exp1ubuntu4.1 arm64 [installed,local]
.....
.....
-------------------code----------------------

- When we type apt install nano, this command looks at the package database
and in this database, it cannot find a package called nano.
So this is where we use the update command to update the package database.
Now, when we press enter, the next is going to all these sources,
like security.ubuntu.com and all these other websites
to download the list of packages. So now our package database is updated.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
...........
-------------------code----------------------

- So if we run apt list, we see far more packages. And as we can see,
most of these packages are not installed, because we don't have
installed in front of them. So now we can run apt install nano, and
nano is installed. So here's what we need to take away.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
Get:5 http://ports.ubuntu.com/ubuntu-ports noble/main arm64 Packages [1776 kB]
Get:6 http://ports.ubuntu.com/ubuntu-ports noble/universe arm64 Packages [19.0 MB]
Get:7 http://ports.ubuntu.com/ubuntu-ports noble/multiverse arm64 Packages [274 kB]
Get:8 http://ports.ubuntu.com/ubuntu-ports noble/restricted arm64 Packages [113 kB]
Get:9 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 Packages [1164 kB]
Get:10 http://ports.ubuntu.com/ubuntu-ports noble-updates/multiverse arm64 Packages [32.7 kB]
Get:11 http://ports.ubuntu.com/ubuntu-ports noble-updates/restricted arm64 Packages [1090 kB]
Get:12 http://ports.ubuntu.com/ubuntu-ports noble-updates/universe arm64 Packages [1311 kB]
Get:13 http://ports.ubuntu.com/ubuntu-ports noble-backports/universe arm64 Packages [16.1 kB]
Get:14 http://ports.ubuntu.com/ubuntu-ports noble-security/universe arm64 Packages [1028 kB]
Get:15 http://ports.ubuntu.com/ubuntu-ports noble-security/multiverse arm64 Packages [30.8 kB]
Get:16 http://ports.ubuntu.com/ubuntu-ports noble-security/main arm64 Packages [843 kB]
Get:17 http://ports.ubuntu.com/ubuntu-ports noble-security/restricted arm64 Packages [1041 kB]
Fetched 28.4 MB in 16s (1826 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
18 packages can be upgraded. Run 'apt list --upgradable' to see them.
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  hunspell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 18 not upgraded.
-------------------code----------------------

- Before installing a package, we should always run apt update
to update our package database. And then we can install a package like nano.
-------------------code----------------------
apt update
apt update nano
-------------------code----------------------

- Now we'll talk about nano later in this section. But before going forward, let's make sure
that this package is installed properly.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
-------------------code----------------------


- So we have installed nano.
Now let's say we want to remove it.
So we type apt remove nano. It's asking for confirmation.
So nano is gone.
-------------------code----------------------
root@ee871cc6ca5f:/# apt remove nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  nano
0 upgraded, 0 newly installed, 1 to remove and 18 not upgraded.
After this operation, 909 kB disk space will be freed.
Do we want to continue? [Y/n] y
(Reading database ... 4451 files and directories currently installed.)
Removing nano (7.2-2ubuntu0.1) ...
-------------------code----------------------

- If we type nano,
we get this error saying no such file or directory.
Now here's a little exercise for we.
In this image we don't have python.
So we get an error.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: /usr/bin/nano: No such file or directory
-------------------code----------------------

- Homework: use apt to install python in this image.
Make sure it works and then remove it.

*** 5- Linux File System ***

- So, in Linux, just like Windows,
our files and directories are organized in a tree,
in a hierarchical structure. So, in Windows
we have a structure like this, with C drive on top
of the hierarchy, then below that we have directories like
program files, windows and so on. 
-------------------code----------------------
C:\
  Program Files
  Windows
-------------------code----------------------

- In Linux we have the root directory on top of the hierarchy.
Below that we have a bunch of standard directories, for example
we have bin, which includes binaries or programs. We have boot, which includes all the
files related to booting. Then we have dev, the first time we saw this, we thought this is short for development.
It's not. It's short for devices. So, in Linux
everything is a file, including devices,
directories, network sockets, pipes and so on.

-------------------code----------------------
- /
  bin
  boot
  dev
  etc
  home
  root
  lib
  var
  proc
-------------------code----------------------



- So, the files that are needed to access devices are
stored in this directory. Then we have etsy,
there are different opinions what is this short for, but one common
opinion is, this is short for editable text configuration.
So, this is where we have configuration files.

- We also have home, this is where home directories
for users are stored. So, on a machine with multiple users,
each user is going to have a home directory here.
We also have root, which is the home directory of the root user.
Only the root user can access this directory.
Then we have lib, which is used for keeping library files
like software library dependencies. We have var,
which is short for variable, and this is where we have files
that are updated frequently, like log files,
application data and so on. And finally, we have proc,
which includes files that represent running processes.

- So, once again, in Linux, everything is a file.
Processes, devices, even directories are files.
Now, we don't need to memorize any of these directories.
we just listed them here, so as we go through the course,
these directories look familiar to us.

*** 6- Navigating the File System ***

- Let's see how we can navigate the Linux file system. So the first command we're going to talk about is pwd
which is short for print working directory. With this we can see
where we are in the file system. So a forward slash
represents the root directory. 
-------------------code----------------------
root@8a65a7f2dd58:/# pwd
/
-------------------code----------------------

- Now to see the files and directories here, we type ls which is short for list. So we have
bin which we talked about earlier, that is short for binaries, this is where we have binary
files and programs, we have dev which includes files for devices,
we have boot which includes boot files, etsy which includes configuration
files and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, by default ls lists these items on multiple lines. If we don't like this layout and want to show
one item per line, we need to pass an option, that is dash
one. we might prefer this layout.
-------------------code----------------------
root@8a65a7f2dd58:/# ls -1
bin
boot
dev
etc
home
lib
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
-------------------code----------------------

- We have another option, dash l, for seeing a long listing.
This listing includes more details. So in the first column we have the permissions of this file or directory.
The first time we see this, it might look really scary,
We'll talk about that later in this section. Over here, we can see
the user that owns this file or directory, we can see the size, we can see
the date and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls -l
total 48
lrwxrwxrwx   1 root root    7 Apr 22  2024 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 22  2024 boot
drwxr-xr-x   5 root root  360 Mar 17 15:46 dev
drwxr-xr-x   1 root root 4096 Mar 17 15:46 etc
drwxr-xr-x   3 root root 4096 Jan 27 02:19 home
lrwxrwxrwx   1 root root    7 Apr 22  2024 lib -> usr/lib
drwxr-xr-x   2 root root 4096 Jan 27 02:12 media
drwxr-xr-x   2 root root 4096 Jan 27 02:12 mnt
drwxr-xr-x   2 root root 4096 Jan 27 02:12 opt
dr-xr-xr-x 168 root root    0 Mar 17 15:46 proc
drwx------   2 root root 4096 Jan 27 02:19 root
drwxr-xr-x   4 root root 4096 Jan 27 02:19 run
lrwxrwxrwx   1 root root    8 Apr 22  2024 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Jan 27 02:12 srv
dr-xr-xr-x  11 root root    0 Mar 17 15:46 sys
drwxrwxrwt   2 root root 4096 Jan 27 02:19 tmp
drwxr-xr-x  11 root root 4096 Jan 27 02:12 usr
drwxr-xr-x  11 root root 4096 Jan 27 02:19 var
-------------------code----------------------

- Now to change the current directory, we use
the cd command, we have the same command in windows. Now here we can
type a relative or an absolute path. A relative path
is relative to where we are. So in this root directory, we have directories like bin, boot and so on. So this is a relative
path. Now in contrast, an absolute path
always starts from the root directory. So, let's go to a directory starting with
e. Now we can press tab to get autocompletion, beautiful.
Now let's go to a directory starting with a. Now if we press tab,
nothing happens because we have multiple directories starting with a.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/a
alternatives/ apt/
-------------------code----------------------

- So we have to press tab one more time, great. So, we have
three entries, three directories, add user.conf, alternatives
and apt. So, let's type the second letter, p and then press tab.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/apt/
-------------------code----------------------

- Now let's see what we have in this directory. So,
these blue items are directories and sources that list is a file.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# ls
apt.conf.d  auth.conf.d  keyrings  preferences.d  sources.list  sources.list.d  trusted.gpg.d
-------------------code----------------------v

- Now to get out of this directory we can go one level up by typing two periods.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# cd ..
-------------------code----------------------

- Again, to get to the etsy directory or two levels up to get to the root directory.
Look, we're currently in the root directory.
-------------------code----------------------
root@8a65a7f2dd58:/etc# cd ../..
-------------------code----------------------

-  Now, when using ls, we can optionally specify a path. Let's say we're somewhere in the file system, but we want to
look at the content of another directory. we don't want to navigate to that directory.
So, we're currently in the root directory, we want to know what files and directories
we have inside the bin directory. So once again, we can type a
relative path or an absolute path starting from the root directory.
So, here are the binaries in this directory. Look at pwd. That's the command
that we just executed. So, pwd is a program in this directory. Here's another example.
Look at echo. So, most of the commands we have been exploring so far are programs
or binaries in the bin directory.
-------------------code----------------------
root@8a65a7f2dd58:/# ls bin
'['              cut                       expiry      join               mount           readlink            skill       uncompress
 addpart         dash                      expr        kill               mountpoint      realpath            slabtop     unexpand
 apt             date                      factor      last               mv              rename.ul           sleep       uniq
 apt-cache       dd                        faillog     lastb              namei           renice              snice       unlink
 apt-cdrom       deb-systemd-helper        fallocate   lastlog            nawk            reset               sort        unminimize
 apt-config      deb-systemd-invoke        false       ld.so              newgrp          resizepart          split       unshare
 apt-get         debconf                   fgrep       ldd                nice            rev                 stat        update-alternatives
 apt-key         debconf-apt-progress      find        link               nisdomainname   rgrep               stdbuf      uptime
 apt-mark        debconf-communicate       findmnt     linux32            nl              rm                  stty        users
 arch            debconf-copydb            flock       linux64            nohup           rmdir               su          utmpdump
 awk             debconf-escape            fmt         ln                 nproc           run-parts           sum         vdir
 b2sum           debconf-set-selections    fold        locale             nsenter         runcon              sync        vmstat
 base32          debconf-show              free        locale-check       numfmt          savelog             tabs        w
 base64          delpart                   getconf     localedef          od              script              tac         wall
 basename        df                        getent      logger             pager           scriptlive          tail        watch
 basenc          diff                      getopt      login              partx           scriptreplay        tar         wc
 bash            diff3                     gpasswd     logname            passwd          sdiff               taskset     wdctl
 bashbug         dir                       gpgv        ls                 paste           sed                 tee         whereis
 captoinfo       dircolors                 grep        lsattr             pathchk         select-editor       tempfile    which
 cat             dirname                   groups      lsblk              perl            sensible-browser    test        which.debianutils
 chage           dmesg                     gunzip      lscpu              perl5.38.2      sensible-editor     tic         who
 chattr          dnsdomainname             gzexe       lsipc              pgrep           sensible-pager      timeout     whoami
 chcon           domainname                gzip        lslocks            pidof           sensible-terminal   tload       xargs
 chfn            dpkg                      hardlink    lslogins           pidwait         seq                 toe         yes
 chgrp           dpkg-deb                  head        lsmem              pinky           setarch             top         ypdomainname
 chmod           dpkg-divert               hostid      lsns               pkill           setpriv             touch       zcat
 choom           dpkg-maintscript-helper   hostname    man                pldd            setsid              tput        zcmp
 chown           dpkg-query                iconv       mawk               pmap            setterm             tr          zdiff
 chrt            dpkg-realpath             id          mcookie            pr              sg                  true        zdump
 chsh            dpkg-split                infocmp     md5sum             printenv        sh                  truncate    zegrep
 cksum           dpkg-statoverride         infotocap   md5sum.textutils   printf          sha1sum             tset        zfgrep
 clear           dpkg-trigger              install     mesg               prlimit         sha224sum           tsort       zforce
 clear_console   du                        ionice      mkdir              ps              sha256sum           tty         zgrep
 cmp             echo                      ipcmk       mkfifo             ptx             sha384sum           tzselect    zless
 comm            egrep                     ipcrm       mknod              pwd             sha512sum           uclampset   zmore
 cp              env                       ipcs        mktemp             pwdx            shred               umount      znew
 csplit          expand                    ischroot    more               rbash           shuf                uname
-------------------code----------------------

 
- Now, let me show we a shortcut. Earlier we
told we that, here we have this home directory where each user
has a home directory. But the root user has a special home directory called root.
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, to get here, there are two options.
We can type an absolute or relative path and go to root.
-------------------code----------------------
cd root/
-------------------code----------------------

- But there is a shortcut. So, we're currently in the root directory. To get to my
home directory, we can type a tilde. And this applies to all
users, not just the root user. Whenever we type cd
tilde, we go to our home directory. 

-------------------code----------------------
root@8a65a7f2dd58:/# cd ~
root@8a65a7f2dd58:~#
-------------------code----------------------

*** 7- Manipulating Files and Directories ***

- Let's see how we can manipulate files and directories. So, we're currently in the root
directory and we want to go to my home directory. How can we do that? Do we remember? We type
cd tilde. Great.
-------------------code----------------------
root@8a65a7f2dd58:/# cd ~
-------------------code----------------------

- Now, in this directory we want to create a directory called test. So
we type mkdir test, let's verify, it's right here. As we told before, blue represents
a directory. 
-------------------code----------------------
root@8a65a7f2dd58:~# mkdir test
root@8a65a7f2dd58:~# ls
test
-------------------code----------------------

- Now, let's say we want to rename this directory. How do we do that? We use
the move command. With this we can rename files and folders or move them somewhere else. So,
we can move or rename test to docker. Alright, beautiful.
-------------------code----------------------
root@8a65a7f2dd58:~# mv test docker
root@8a65a7f2dd58:~# ls
docker
-------------------code----------------------

- Now, let's go in this directory. Now, to create a new file, we use the touch command. So we can create hello.txt. Look,
we have this new file here. This is a new empty file. 
-------------------code----------------------
root@8a65a7f2dd58:~# cd docker/
root@8a65a7f2dd58:~/docker# touch hello.txt
root@8a65a7f2dd58:~/docker# ls
hello.txt
-------------------code----------------------

- Also, using the touch command, we can
create multiple files in one go. So we can create file 1, file 2, and file 3.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# touch file1.txt file2.txt file3.txt
root@8a65a7f2dd58:~/docker# ls
file1.txt  file2.txt  file3.txt  hello.txt
-------------------code----------------------

- let's say we want to rename hello.txt to something else. Once again, we can use the move command. So we type h, press tab to get
autocompletion. We can rename this to hello-docker.txt. Or, we can move it to a different directory.
For example, we can move it to the etc directory. And here we're using an absolute path, because
my path has started from the root directory. Now, in this lesson, we don't want to move
this anywhere. So, we just want to rename this to hello-docker.txt.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# mv hello.txt hello-docker.txt
root@8a65a7f2dd58:~/docker# ls
file1.txt  file2.txt  file3.txt  hello-docker.txt
-------------------code----------------------

- Ahow we removed this entire word in one go, we pressed cmd and w. 

- back, hello-docker.txt. Now, let's see how we can remove one or more
files. To do that, use the rm command. Now, here we can type one or more files, so we can
say file 1.txt, file 2.txt.
-------------------code----------------------
root@8a65a7f2dd58:rm file1.txt file2.txt
-------------------code----------------------

- or we can use a pattern. For example, we can say, we want to
remove all files that start with file. Let's verify it. Beautiful, we only have hello-docker.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# rm file*
root@8a65a7f2dd58:~/docker# ls
hello-docker.txt
-------------------code----------------------

Now, let's get out of this directory and remove the directory itself. So, we type rm docker.
Now, we get an error saying docker is a directory.
-------------------code----------------------
root@8a65a7f2dd58:~/docker# cd ../
root@8a65a7f2dd58:~# rm docker/
rm: cannot remove 'docker/': Is a directory
-------------------code----------------------

- So, to remove directories, we have to use
the r option, which is short for recursive. So, we want to remove this directory and all
its content recursively.
-------------------code----------------------
root@8a65a7f2dd58:~# rm -r docker/
root@8a65a7f2dd58:~# ls
root@8a65a7f2dd58:~#
-------------------code----------------------

*** 8- Editing and Viewing Files ***

- Alright, let's see how we can edit and
view files. So earlier we briefly talked about nano.
Nano is a basic text editor for Linux. Now, on this image that we are running,
we don't have nano, so we have to install it. Do we remember the command for installing nano?
That is apt install nano.
- first we update apt
-------------------code----------------------
root@8a65a7f2dd58:~# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
Get:5 http://ports.ubuntu.com/ubuntu-ports noble/multiverse arm64 Packages [274 kB]
Get:6 http://ports.ubuntu.com/ubuntu-ports noble/restricted arm64 Packages [113 kB]
Get:7 http://ports.ubuntu.com/ubuntu-ports noble/universe arm64 Packages [19.0 MB]
Get:8 http://ports.ubuntu.com/ubuntu-ports noble/main arm64 Packages [1776 kB]
Get:9 http://ports.ubuntu.com/ubuntu-ports noble-updates/restricted arm64 Packages [1090 kB]
Get:10 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 Packages [1167 kB]
Get:11 http://ports.ubuntu.com/ubuntu-ports noble-updates/multiverse arm64 Packages [32.7 kB]
Get:12 http://ports.ubuntu.com/ubuntu-ports noble-updates/universe arm64 Packages [1315 kB]
Get:13 http://ports.ubuntu.com/ubuntu-ports noble-backports/universe arm64 Packages [16.1 kB]
Get:14 http://ports.ubuntu.com/ubuntu-ports noble-security/multiverse arm64 Packages [30.8 kB]
Get:15 http://ports.ubuntu.com/ubuntu-ports noble-security/universe arm64 Packages [1028 kB]
Get:16 http://ports.ubuntu.com/ubuntu-ports noble-security/restricted arm64 Packages [1041 kB]
Get:17 http://ports.ubuntu.com/ubuntu-ports noble-security/main arm64 Packages [843 kB]
Fetched 28.4 MB in 16s (1754 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
18 packages can be upgraded. Run 'apt list --upgradable' to see them.
-------------------code----------------------

- next install nano
-------------------code----------------------
root@8a65a7f2dd58:~# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  hunspell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 18 not upgraded.
Need to get 281 kB of archives.
After this operation, 909 kB of additional disk space will be used.
Get:1 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 nano arm64 7.2-2ubuntu0.1 [281 kB]
Fetched 281 kB in 2s (154 kB/s)
debconf: delaying package configuration, since apt-utils is not installed
Selecting previously unselected package nano.
(Reading database ... 4378 files and directories currently installed.)
Preparing to unpack .../nano_7.2-2ubuntu0.1_arm64.deb ...
Unpacking nano (7.2-2ubuntu0.1) ...
Setting up nano (7.2-2ubuntu0.1) ...
update-alternatives: using /bin/nano to provide /usr/bin/editor (editor) in auto mode
update-alternatives: warning: skip creation of /usr/share/man/man1/editor.1.gz because associated file /usr/share/man/man1/nano.1.gz (of link group editor) doesn't exist
update-alternatives: using /bin/nano to provide /usr/bin/pico (pico) in auto mode
update-alternatives: warning: skip creation of /usr/share/man/man1/pico.1.gz because associated file /usr/share/man/man1/nano.1.gz (of link group pico) doesn't exist
-------------------code----------------------


- Alright, now we have nano, so we can launch it,
and optionally supply a file name, let's say file1.txt.
So here we have a basic text editor, we can type
whatever we want, and when we are done, look down below,
the shortcut for exiting is control and x, so we're going to press that.
Now it's asking if we want to save the changes, so we press yes.
And here we confirm the file name, we can keep the same file, or change the file name.
Let's go ahead. So now, in this directory we have
file1.txt, beautiful. 
-------------------code----------------------
root@8a65a7f2dd58:~# nano file1.txt
root@8a65a7f2dd58:~# ls
file1.txt
-------------------code----------------------


- Now, to see the content of this file,
we have a few different commands. The simplest one is cat,
and this has nothing to do with cat, it's short for concatenate.
So later we will show we how we can use this command to concatenate or combine multiple files.
But with cat we can also see the content of a file, so if we say
cat file1.txt, we can see the content of this file.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt
hello
world
-------------------code----------------------


- Now, cat is useful if our file is short and
fits on one page, but if we're dealing with a long file, it's better to use
the more command. Let me give we an example, so
we're going to use cat to show the content of this file.
This is a really long file, so if we scroll up, look, we have a lot of text.
Now, sometimes we don't want to see all the content in one go,
we want to scroll down.
-------------------code----------------------
root@8a65a7f2dd58:/# cat /etc/debconf.conf
# This is the main config file for debconf. It tells debconf where to
# store data. The format of this file is a set of stanzas. Each stanza
# except the first sets up a database for debconf to use. For details, see
# debconf.conf(5) (in the debconf-doc package).
#
# So first things first. This first stanza gives the names of two databases.

# Debconf will use this database to store the data we enter into it,
# and some other dynamic data.
Config: configdb
# Debconf will use this database to store static template data.
Templates: templatedb

# World-readable, and accepts everything but passwords.
Name: config
Driver: File
Mode: 644
Reject-Type: password
Filename: /var/cache/debconf/config.dat
.....
-------------------code----------------------

-if we want to go page by page. This is where
we use the more command.  Now, down below, look, we can see
more 15%, so we are seeing 15% of this file. Now, if we press space, we can go to the next
page, so now we are at the position 33%. Alternatively, we can press enter
to go one line at a time.
-------------------code----------------------
root@8a65a7f2dd58:~# more /etc/debconf.conf
# Set up the configdb database. By default, it consists of a stack of two
# databases, one to hold passwords and one for everything else.
Name: configdb
Driver: Stack
Stack: config, passwords

# Set up the templatedb database, which is a single flat text file
--More--(39%)
-------------------code----------------------

-  Now, the problem with more is that we can only scroll down, we cannot
scroll up. So, to do that, we have to use a different command called less. So, to exit
here, we press q, good. Now, in this image we don't have less, so once again we have to manually
install it. So, apt install less.
-------------------code----------------------
root@8a65a7f2dd58:~# apt install less
-------------------code----------------------

- So, less is a newer command that is supposed to replace more. Let's go ahead.
Great. So, let's look at the same file using the less command.
So, now using the up and down arrows we can scroll down or up.
So, just by pressing up and down arrows. We also have space, we can go to the next page
and enter, just like the more command. And when we are done, we can press q.
-------------------code----------------------
root@8a65a7f2dd58:~# less /etc/debconf.conf
-------------------code----------------------

- Now, we have a couple more commands for viewing the content of a file.
We have head, which we can use to display the first
few lines. So, here we can supply an option and say, the number of lines we want to see is five.
Let's look at the same file. So, this shows the first five lines of this file.
-------------------code----------------------
root@8a65a7f2dd58:~# head -n 5 /etc/debconf.conf
# This is the main config file for debconf. It tells debconf where to
# store data. The format of this file is a set of stanzas. Each stanza
# except the first sets up a database for debconf to use. For details, see
# debconf.conf(5) (in the debconf-doc package).
#
-------------------code----------------------

- Similarly, we have tail, which shows the last few lines. So, we supply an option and say we want to look at the last five files.
-------------------code----------------------
root@8a65a7f2dd58:~# tail -n 5 /etc/debconf.conf
# In this example, we'd use Config: fulldb at the top of the file
# to make it use the combination of the databases.
#
# Even more complex and interesting setups are possible, see the
# debconf.conf(5) page for details.
-------------------code----------------------

*** 9- Redirection ***

- One of the important concepts in Linux is the concept of standard input
and output. So standard input represents the keyboard and standard
output represents the screen. But we can always change the source
of the input or the output. This is called redirection.


- a few examples. So we talked about the cat command to see the content
of a file. Let's say file1.txt. When we execute
this command, this command or this program reads data from this file
and prints it on the standard output which is the screen.
That is why we see the content.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt
hello
world
-------------------code----------------------


- But using the redirection operator
which is the greater than sign, we can redirect the output
from the screen to, let's say, a different file.
So now cat will read the content from this file and write it to this file.
Take a look. So we have file2.txt if we view it, we see
the exact same content as file1.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt > file2.txt
root@8a65a7f2dd58:~# ls
file1.txt  file2.txt
root@8a65a7f2dd58:~# cat file2.txt
hello
world
-------------------code----------------------

- Okay, now what is the point of this?
Well, earlier we told we that we can use the cat command to concatenate
or combine multiple files. So here we can say cat file1.txt
and file2.txt. If we press enter, cat is going to read the data
from both these files and print it on the terminal which is the standard
output. 
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt  file2.txt
hello
world
hello
world
-------------------code----------------------

- But once again, using the redirection operator we can write the result to a different file.
Combine.txt So this is how we can use this command to combine multiple files.
-------------------code----------------------
root@8a65a7f2dd58:~# cat file1.txt  file2.txt  > combined.txt
root@8a65a7f2dd58:~# cat combined.txt
hello
world
hello
world
-------------------code----------------------

- Now, the redirection operator is not
limited to the cat command, we can use it pretty much anywhere. For example,
earlier we talked about the echo command. If we say echo hello,
we see the result on the terminal. 
-------------------code----------------------
root@8a65a7f2dd58:~# echo hello.txt
hello.txt
-------------------code----------------------

- But if we say echo hello to
hello.txt Now we have a new file here, hello.txt which contains hello.
-------------------code----------------------
root@8a65a7f2dd58:~# echo "hello" > hello.txt
root@8a65a7f2dd58:~# cat hello.txt
hello
-------------------code----------------------

- So if we want to write a single line to a file, we don't have to use nano,
we can use the echo command. So echo whatever to
whatever file.txt. Okay? 

- another example we want we to get a long listing
of the files in the etsy directory and write the output to a file.
so To get a long listing, we type ls-l, then we specify the path, the etsy directory, now
instead of printing the result on the terminal we're going to write it to a file called
etc_list.txt.
-------------------code----------------------
root@8a65a7f2dd58:~# ls -l /etc/ > etc_files.tsxt
root@8a65a7f2dd58:~# cat etc_files.tsxt
total 300
drwxr-xr-x 1 root root    4096 Mar 17 16:30 alternatives
drwxr-xr-x 8 root root    4096 Jan 27 02:13 apt
-rw-r--r-- 1 root root    2319 Mar 31  2024 bash.bashrc
-rw-r--r-- 1 root root     367 Aug  2  2022 bindresvport.blacklist
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cloud
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cron.d
drwxr-xr-x 2 root root    4096 Jan 27 02:19 cron.daily
-rw-r--r-- 1 root root    2967 Apr 12  2024 debconf.conf
-rw-r--r-- 1 root root      11 Apr 22  2024 debian_version
drwxr-xr-x 2 root root    4096 Jan 27 02:19 default
drwxr-xr-x 4 root root    4096 Jan 27 02:19 dpkg
-rw-r--r-- 1 root root     685 Apr  8  2024 e2scrub.conf
-rw-r--r-- 1 root root     106 Jan 27 02:12 environment
-rw-r--r-- 1 root root      37 Jan 27 02:12 fstab
-rw-r--r-- 1 root root    2584 Jan 31  2024 gai.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 gnutls
-rw-r--r-- 1 root root     503 Jan 27 02:19 group
-rw-r--r-- 1 root root     434 Jan 27 02:12 group-
-rw-r----- 1 root shadow   429 Jan 27 02:19 gshadow
-rw-r----- 1 root shadow   364 Jan 27 02:12 gshadow-
-rw-r--r-- 1 root root      92 Apr 22  2024 host.conf
-rw-r--r-- 1 root root      13 Mar 17 15:46 hostname
-rw-r--r-- 1 root root     174 Mar 17 15:46 hosts
drwxr-xr-x 2 root root    4096 Jan 27 02:19 init.d
-rw-r--r-- 1 root root      26 Aug 23  2024 issue
-rw-r--r-- 1 root root      19 Aug 23  2024 issue.net
drwxr-xr-x 3 root root    4096 Jan 27 02:13 kernel
-rw-r--r-- 1 root root    5199 Jan 27 02:19 ld.so.cache
-rw-r--r-- 1 root root      34 Aug  2  2022 ld.so.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 ld.so.conf.d
-rw-r--r-- 1 root root     267 Apr 22  2024 legal
-rw-r--r-- 1 root root     191 Mar 31  2024 libaudit.conf
-rw-r--r-- 1 root root   12345 Feb 22  2024 login.defs
drwxr-xr-x 2 root root    4096 Jan 27 02:19 logrotate.d
-rw-r--r-- 1 root root     104 Aug 23  2024 lsb-release
-rw-r--r-- 1 root root       0 Jan 27 02:19 machine-id
-rw-r--r-- 1 root root     744 Apr  8  2024 mke2fs.conf
lrwxrwxrwx 1 root root      12 Mar 17 15:46 mtab -> /proc/mounts
-rw-r--r-- 1 root root   11424 May 23  2023 nanorc
-rw-r--r-- 1 root root      91 Apr 22  2024 networks
-rw-r--r-- 1 root root     494 Aug  2  2022 nsswitch.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:12 opt
lrwxrwxrwx 1 root root      21 Aug 23  2024 os-release -> ../usr/lib/os-release
-rw-r--r-- 1 root root     552 Oct 13  2022 pam.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 pam.d
-rw-r--r-- 1 root root     888 Jan 27 02:19 passwd
-rw-r--r-- 1 root root     839 Jan 27 02:12 passwd-
-rw-r--r-- 1 root root     582 Apr 22  2024 profile
drwxr-xr-x 2 root root    4096 Jan 27 02:19 profile.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc0.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc1.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc2.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc3.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc4.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc5.d
drwxr-xr-x 2 root root    4096 Dec  6  2023 rc6.d
drwxr-xr-x 2 root root    4096 Jan 27 02:12 rcS.d
-rw-r--r-- 1 root root     222 Mar 17 15:46 resolv.conf
lrwxrwxrwx 1 root root      13 Apr  8  2024 rmt -> /usr/sbin/rmt
drwxr-xr-x 4 root root    4096 Jan 27 02:19 security
drwxr-xr-x 2 root root    4096 Jan 27 02:17 selinux
-rw-r----- 1 root shadow   502 Jan 27 02:19 shadow
-rw-r----- 1 root shadow   474 Jan 27 02:12 shadow-
-rw-r--r-- 1 root root     118 Jan 27 02:13 shells
drwxr-xr-x 2 root root    4096 Jan 27 02:13 skel
-rw-r--r-- 1 root root      20 Jan 27 02:19 subgid
-rw-r--r-- 1 root root       0 Jan 27 02:13 subgid-
-rw-r--r-- 1 root root      20 Jan 27 02:19 subuid
-rw-r--r-- 1 root root       0 Jan 27 02:13 subuid-
-rw-r--r-- 1 root root    2209 Mar 24  2024 sysctl.conf
drwxr-xr-x 2 root root    4096 Jan 27 02:19 sysctl.d
drwxr-xr-x 4 root root    4096 Dec  6  2023 systemd
drwxr-xr-x 2 root root    4096 Jan 27 02:18 terminfo
drwxr-xr-x 2 root root    4096 Jan 27 02:19 update-motd.d
-rw-r--r-- 1 root root     681 Apr  8  2024 xattr.conf
-------------------code----------------------


- Using the greater than sign we can redirect the standard output
but we also have the less than sign to redirect the standard input.
we personally haven't found many use cases for this so we didn't cover it
in this lesson. 
-------------------code----------------------
root@8a65a7f2dd58:~# >
-------------------code----------------------


*** 10- Searching for Text ***

- Let's see how we can search for a string in a file.
So we have this grep command which is short for global regular
expression print. 


- let's say we want to search for the word hello in file1.txt.
What happened? Didn't we write hello to file1.txt?
Yes we did, but this search is case sensitive just like
everything else in Linux. 
-------------------code----------------------
root@8a65a7f2dd58:~# grep Hello file1.txt
-------------------code----------------------

- we research with case sensitive
-------------------code----------------------
root@8a65a7f2dd58:~# grep hello file1.txt
hello
-------------------code----------------------

- If we want to remove case sensitivity,
we have to use an option. That is
dash i. So case insensitive. Now we see the word hello highlighted in red. 
-------------------code----------------------
root@8a65a7f2dd58:~# grep -i Hello file1.txt
hello
-------------------code----------------------

- Let's look at another example. This time
we want to search for the word root in slash etsy slash password.
This file contains the list of user accounts on this machine. Not their
passwords, just their accounts.
On this line, which we think is the first line in this file,
we have three occurrences of root and that's why they're displayed in red.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i root /etc/passwd
root:x:0:0:root:/root:/bin/bash
-------------------code---------------------

- Now we can also search in multiple files. So let's search for hello
in file1.txt and file2.txt. That's one way. 
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello file1.txt file2.txt
file1.txt:hello
file2.txt:hello
-------------------code---------------------

- We can also use a pattern. So we can say we want to search in all files whose name starts with file.
So we use a wild card here.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello file*
file1.txt:hello
file2.txt:hello
-------------------code---------------------

- Now we can see in file1.txt we have hello and the same is true in file2.txt.
Now we can also search in a directory. So instead of typing a file name, we can type a directory name or we can use a period to refer to the current directory.
Now we get an error saying period is a directory. 


- So here we have to use an additional option
dash r which is short for recursive. So with this we can search this directory and all its subdirectories recursively.
Now look, in all these files we have references to hello. We have references to hello. 
-------------------code---------------------
root@8a65a7f2dd58:~# grep -i hello .
grep: .: Is a directory
-------------------code---------------------

- Now one last thing. In Linux we can combine multiple options.
So instead of having two different options, dash i and dash r,
we can combine them into one option. This gives us the exact same result.
-------------------code---------------------
root@8a65a7f2dd58:~# grep -ir hello .
./hello.txt:hello
./file1.txt:hello
./combined.txt:hello
./combined.txt:hello
./file2.txt:hello
-------------------code---------------------

- So using the grep command, we can search for a string in one or more files.

*** 11- Finding Files and Directories ***

- Let's talk about finding files and directories. So we're currently in my home directory
as we can tell from the tilde. Let's run ls so here we have combined file1, file2, files and hello.txt
Now of course on our machine we might have different files, it doesn't matter.
-------------------code---------------------
root@8a65a7f2dd58:~# ls
combined.txt  etc_files.tsxt  file1.txt  file2.txt  hello.txt
-------------------code---------------------

- Now in Linux we have the find command for finding files
and directories. If we execute this command without any arguments
we see all the files and directories in the current directory
recursively. So this command is going to go through every directory
in this directory and list their files. So on the top we have
.bashrc and .profile, these are two hidden files in the
current directory. we didn't see this earlier when we executed ls,
because by default ls doesn't show the hidden files and directories.
-------------------code---------------------
root@8a65a7f2dd58:~# find
.
./.bashrc
./.profile
./hello.txt
./file1.txt
./.local
./.local/share
./.local/share/nano
./etc_files.tsxt
./combined.txt
./file2.txt
./.lesshst
-------------------code---------------------

- Now, what option should we use to see the hidden files and directories?
Do we remember, dash a which is short for all. So now
we can see bashrc, profile, and local which is
a directory because it's blue. 
-------------------code---------------------
root@8a65a7f2dd58:~# ls -a
.  ..  .bashrc  .lesshst  .local  .profile  combined.txt  etc_files.tsxt  file1.txt  file2.txt  hello.txt
-------------------code---------------------

- So back to the find command, here we can see all the files and directories in the current directory.
Now, if we want to look somewhere else, we can supply a path.
So, we can search in the etsy directory. Now we can see all the files and directories starting from etsy.
-------------------code---------------------
root@8a65a7f2dd58:~# find /etc/
/etc/
/etc/dpkg
/etc/dpkg/dpkg.cfg
/etc/dpkg/origins
/etc/dpkg/origins/debian
/etc/dpkg/origins/default
/etc/dpkg/origins/ubuntu
/etc/dpkg/dpkg.cfg.d
/etc/dpkg/dpkg.cfg.d/docker-apt-speedup
/etc/dpkg/dpkg.cfg.d/excludes
/etc/group-
/etc/passwd-
.....
.....
....
-------------------code---------------------

- Okay? Now, let's get back to the current directory.
a various ways to filter the result. If we want to see only the directories,
we pass an option called type with the value of d.
Now we can see only the directories in the current directory.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type d
.
./.local
./.local/share
./.local/share/nano
-------------------code---------------------

- Alternatively, we can search for files. 
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f
./.bashrc
./.profile
./hello.txt
./file1.txt
./etc_files.tsxt
./combined.txt
./file2.txt
./.lesshst
-------------------code---------------------
- We can also filter by name. So, let's say we want to find
all the files whose name start with, let's say F.
Here in double quotes, we can type a pattern, we can say F star.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -name "f*"
./file1.txt
./file2.txt
-------------------code---------------------

- Now just remember that this search is case sensitive just like everything else in Linux.
So if we type a capital F here, we don't find anything.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -name "F*"
-------------------code---------------------

- Now, to make the search case insensitive, instead of name,
we use a different option that is iname.
-------------------code---------------------
root@8a65a7f2dd58:~# find -type f -iname "F*"
./file1.txt
./file2.txt
-------------------code---------------------

Alright, beautiful. Now here's a little exercise for we.
Using the find command, we want we to find all the python files in this image
and then write the result to a file called pythonfiles.txt.
-------------------code---------------------
root@8a65a7f2dd58:~# find / -type f -name "*.py"
/usr/share/apport/package-hooks/source_shadow.py
/usr/share/gdb/auto-load/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.33-gdb.py
/usr/share/gcc/python/libstdcxx/v6/__init__.py
/usr/share/gcc/python/libstdcxx/v6/printers.py
/usr/share/gcc/python/libstdcxx/v6/xmethods.py
/usr/share/gcc/python/libstdcxx/__init__.py
-------------------code---------------------

- Now, to write the result to a file, we're going to use the redirection operator.
So, we can write it to a file called pythonfiles.txt.
-------------------code---------------------
root@8a65a7f2dd58:~# find / -type f -name "*.py" > python-files.txt
root@8a65a7f2dd58:~# cat python-files.txt
/usr/share/apport/package-hooks/source_shadow.py
/usr/share/gdb/auto-load/usr/lib/aarch64-linux-gnu/libstdc++.so.6.0.33-gdb.py
/usr/share/gcc/python/libstdcxx/v6/__init__.py
/usr/share/gcc/python/libstdcxx/v6/printers.py
/usr/share/gcc/python/libstdcxx/v6/xmethods.py
/usr/share/gcc/python/libstdcxx/__init__.py
-------------------code---------------------
