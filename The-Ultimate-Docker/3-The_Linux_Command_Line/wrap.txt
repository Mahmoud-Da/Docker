*** 1- Introduction ***
All right, the next stop in our journey is the Linux command line.

- But why Linux? What if we're a Windows user?
Well, we still need to know a bit of Linux for a number of reasons.
For starters, Docker has its foundations built on top of basic Linux concepts.
So if we want to be productive and troubleshoot issues easily,
we need to know some of the basic Linux commands.

- Also, most tutorials online are based on Linux commands.
So if we don't understand these basic commands, we're not going to get far.
learning Linux is like learning English.
so everybody should know some English these days.
we don't need to speak it or write a book in it, but we need to understand it.
So unless we're a power Linux user, do not skip this section.
It's going to be super easy and extremely useful.
So let's jump in and get started.

*** 2- Linux Distributions ***

- Let's start off this section by talking about Linux distributions, 
also called Linux distros.

- So, as we probably know, Linux is open source software.
And for this reason, many individuals and communities
have created their own version of Linux called Linux distributions.

- Each of these distributions is made to fit specialized needs
like running servers, desktop computers, mobile phones and so on.

- So we have Ubuntu, which is one of the most popular Linux distributions.
We also have Debian, Alpine, which we briefly talked about, it's a very small Linux distribution.

- We also have Fedora, CentOS and so on.

- Believe it or not, there are more than a thousand Linux distributions out there.

- Now, most of these distributions support pretty much the same set of commands,
but sometimes we might discover differences along the way. So be aware of that.

- In this section, we're going to use Ubuntu Linux because it's one of the most popular distributions.
But if we have a preference for another distribution, that's totally fine.

*** 3- Running Linux ***
Alright, let's see how we can run Ubuntu on this machine.

- So, we go to hub.docker.com 
-------------------code----------------------
https://hub.docker.com/
-------------------code----------------------


- and search for Ubuntu. Over here we can see the official Ubuntu image
that's been downloaded more than 10 million times. 


- Let's have a quick look here.
So, for each image, we can see the command to pull
that image onto our machine.
-------------------code----------------------
$ docker pull ubuntu
-------------------code----------------------

- Now in this lesson, we're not going to use the pull command,
we're going to show we a shortcut. So, here in the terminal, instead of
running docker pull Ubuntu, we're going to run docker run Ubuntu.
-------------------code----------------------
$ docker run ubuntu
-------------------code----------------------

- Now, if we have this image
locally, docker is going to store the container with this image, otherwise
it's going to pull this image behind the scene and then store the container. 

- see, docker is unable to find this image locally, and now it's pulling it from docker hop.
-------------------code----------------------
$ docker run ubuntu
Unable to find image 'ubuntu:latest' locally
latest: Pulling from library/ubuntu
5b17151e9710: Pull complete
Digest: sha256:72297848456d5d37d1262630108ab308d3e9ec7ed1c3286a32fe09856619a782
Status: Downloaded newer image for ubuntu:latest
-------------------code----------------------

- Now, what happened? Well, docker started a container,
but because we didn't interact with this container, the container stopped.

- to prove this. So, if we run docker ps, we can see the list of running processes
or running containers. Look, we don't have any containers running here.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- but if we type docker ps dash a for all, we can see the stopped containers
as well. So we have two stopped containers. The first one is
using the Ubuntu image, this is the one that we just started.
And the second one is hello docker, which we started
earlier in the course.
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                   CREATED              STATUS                          PORTS     NAMES
cc3ce42ddbf2   ubuntu         "/bin/bash"               About a minute ago   Exited (0) About a minute ago             fervent_golick
8ee68b73826f   hello-docker   "docker-entrypoint.sâ€¦"   2 hours ago          Exited (0) 2 hours ago                    busy_brown
-------------------code----------------------

- So, to start a container and interact with it, we have to type docker run dash
it, that is short for interactive. We're going to start a container
in the interactive mode. And in this container
we're going to load the Ubuntu image which we have locally.
-------------------code----------------------
$ docker run -it ubuntu
root@ee871cc6ca5f:/#
-------------------code----------------------

- Now, what we have here is called
the shell. A shell is a program that takes our commands
and passes them to the operating system for execution.
Now, what we have here is called the shell prompt.

- the first part root represents the currently logged in user,
so by default we're logged in as the root user which has the highest privileges.
Then after the add sign, we have the name of the machine. So, this container has this
ID which is automatically generated by docker and in this case, it's like the name of a machine.
Okay? Then after the colon, we can see forward slash, that represents where we are in the file system.
A forward slash represents the root directory. That is the highest directory in the file system.
Then we have a pound "#" and this means we have the highest privileges because we've logged in as the root user.
If we logged in as a normal user, instead of a pound we would see a dollar sign "$".
-------------------code----------------------
root@ee871cc6ca5f:/#
-------------------code----------------------

- So, in this shell, we can execute a bunch of commands
for example, we can say echo, hello and this prints hello on the terminal.
-------------------code----------------------
root@ee871cc6ca5f:/# echo hello
hello
-------------------code----------------------

We can also say "whoami", This shows the current user.
-------------------code----------------------
root@ee871cc6ca5f:/# whoami
root
-------------------code----------------------

- So these commands that we're running here, this shell program that we told we about
takes these commands and passes them to the kernel for execution.
If we type echo dollar sign zero, we can see the location of this shell program.
Take a look. So, that is forward slash bin slash bash.
-------------------code----------------------
root@ee871cc6ca5f:/# echo $0
/bin/bash
-------------------code----------------------

- So bin is a folder or a directory and inside this directory, we have a program called bash
which is short for born again shell.
So apparently, Steve Bourne is the first person
who created a shell program. Bash or born again shell
is a reference to Steve Bourne.

- So bash is an enhanced version of the original shell program.
Now one thing we probably notice is that in Linux
we use a forward slash to separate files and directories.
But in Windows, we use a backslash.

- So that's one of the first differences.
The other difference is that Linux is a case sensitive operating system.
So if we type echo with a capital E,
it's not going to work.

- Bash tells us echo command not found.
So lowercase and uppercase letters are different.
And this is not limited to commands, it's applicable everywhere.
-------------------code----------------------
Echo $0
bash: Echo: command not found
-------------------code----------------------

- If we want to reference a file or a directory or a user,
pretty much anything, we should always spell it properly
with the right uppercase and lowercase letters.


- Using the up and down arrows,
we can go through the commands we have executed so far.
So this is a pretty useful shortcut we need to know
because we don't want to type these commands manually all the time.


- Also, using the history command,
we can see all the commands we have executed lately.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
-------------------code----------------------


- So, take a look.
So earlier we used whoami,
we also used echo and so on.
Now we can replay any of these commands
by typing an exclamation mark,
followed by the command number.
So if we type 2,
this is exactly like running whoami.
-------------------code----------------------
root@ee871cc6ca5f:/# history
    1  echo hello
    2  whoami
    3  echo $0
    4  Echo $0
    5  history
root@ee871cc6ca5f:/# !2
whoami
root
-------------------code----------------------

*** 4- Managing Packages ***

- These days, most operating systems
and development platforms come with a package manager. we've probably
worked with tools like npm, yarn, pip, and so on.

- Here in Ubuntu, we also have a package manager called apt, which is short
for advanced package tool. So let's execute this command.
Look, this command has a bunch of subcommands.
-------------------code----------------------
root@ee871cc6ca5f:/# apt
apt 2.7.14 (arm64)
Usage: apt [options] command

apt is a commandline package manager and provides commands for
searching and managing as well as querying information about packages.
It provides the same functionality as the specialized APT tools,
like apt-get and apt-cache, but enables options more suitable for
interactive use by default.

Most used commands:
  list - list packages based on package names
  search - search in package descriptions
  show - show package details
  install - install packages
  reinstall - reinstall packages
  remove - remove packages
  autoremove - automatically remove all unused packages
  update - update list of available packages
  upgrade - upgrade the system by installing/upgrading packages
  full-upgrade - upgrade the system by removing/installing/upgrading packages
  edit-sources - edit the source information file
  satisfy - satisfy dependency strings

See apt(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- So using list, we can see the list of packages, we can also search
for them, we can show details about the package, we can install, reinstall
and remove a package and so on. Now technically, apt is the
newer package manager. We also have apt-get, which we see a lot
in online tutorials.
-------------------code----------------------
root@ee871cc6ca5f:/# apt-get
apt 2.7.14 (arm64)
Usage: apt-get [options] command
       apt-get [options] install|remove pkg1 [pkg2 ...]
       apt-get [options] source pkg1 [pkg2 ...]

apt-get is a command line interface for retrieval of packages
and information about them from authenticated sources and
for installation, upgrade and removal of packages together
with their dependencies.

Most used commands:
  update - Retrieve new lists of packages
  upgrade - Perform an upgrade
  install - Install new packages (pkg is libc6 not libc6.deb)
  reinstall - Reinstall packages (pkg is libc6 not libc6.deb)
  remove - Remove packages
  purge - Remove packages and config files
  autoremove - Remove automatically all unused packages
  dist-upgrade - Distribution upgrade, see apt-get(8)
  dselect-upgrade - Follow dselect selections
  build-dep - Configure build-dependencies for source packages
  satisfy - Satisfy dependency strings
  clean - Erase downloaded archive files
  autoclean - Erase old downloaded archive files
  check - Verify that there are no broken dependencies
  source - Download source archives
  download - Download the binary package into the current directory
  changelog - Download and display the changelog for the given package

See apt-get(8) for more information about the available commands.
Configuration options and syntax is detailed in apt.conf(5).
Information about how to configure sources can be found in sources.list(5).
Package and version choices can be expressed via apt_preferences(5).
Security details are available in apt-secure(8).
                                        This APT has Super Cow Powers.
-------------------code----------------------

- Going forward, we're going to use apt because it's
easier to work with. So let's say we want to install a package called
nano. Nano is a basic text editor for Linux. Now if we press enter here,
we get an error because this image, this ubuntu image we are running
does not have nano. 
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: nano: command not found
-------------------code----------------------

- So this is where we use apt to install this package.
So if we type apt install nano, we get an error saying, unable to locate package nano.
-------------------code----------------------
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
E: Unable to locate package nano
-------------------code----------------------

- Why is this happening? Well, here in Linux, we have a package database
and this database might contain hundreds of packages, but not all these packages
are installed. So if we want to see all the packages in this database,
we type apt list. Look, these are all the packages. Now in front of these packages,
we can see some of them are installed. But not all packages in this database
are installed. 
-------------------code----------------------
root@ee871cc6ca5f:/# apt list
Listing... Done
apt/now 2.7.14build2 arm64 [installed,local]
base-files/now 13ubuntu10.1 arm64 [installed,local]
base-passwd/now 3.6.3build1 arm64 [installed,local]
bash/now 5.2.21-2ubuntu4 arm64 [installed,local]
bsdutils/now 1:2.39.3-9ubuntu6.2 arm64 [installed,local]
coreutils/now 9.4-3ubuntu6 arm64 [installed,local]
dash/now 0.5.12-6ubuntu5 arm64 [installed,local]
debconf/now 1.5.86ubuntu1 all [installed,local]
debianutils/now 5.17build1 arm64 [installed,local]
diffutils/now 1:3.10-1build1 arm64 [installed,local]
dpkg/now 1.22.6ubuntu6.1 arm64 [installed,local]
e2fsprogs/now 1.47.0-2.4~exp1ubuntu4.1 arm64 [installed,local]
.....
.....
-------------------code----------------------

- When we type apt install nano, this command looks at the package database
and in this database, it cannot find a package called nano.
So this is where we use the update command to update the package database.
Now, when we press enter, the next is going to all these sources,
like security.ubuntu.com and all these other websites
to download the list of packages. So now our package database is updated.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
...........
-------------------code----------------------

- So if we run apt list, we see far more packages. And as we can see,
most of these packages are not installed, because we don't have
installed in front of them. So now we can run apt install nano, and
nano is installed. So here's what we need to take away.
-------------------code----------------------
root@ee871cc6ca5f:/# apt update
Get:1 http://ports.ubuntu.com/ubuntu-ports noble InRelease [256 kB]
Get:2 http://ports.ubuntu.com/ubuntu-ports noble-updates InRelease [126 kB]
Get:3 http://ports.ubuntu.com/ubuntu-ports noble-backports InRelease [126 kB]
Get:4 http://ports.ubuntu.com/ubuntu-ports noble-security InRelease [126 kB]
Get:5 http://ports.ubuntu.com/ubuntu-ports noble/main arm64 Packages [1776 kB]
Get:6 http://ports.ubuntu.com/ubuntu-ports noble/universe arm64 Packages [19.0 MB]
Get:7 http://ports.ubuntu.com/ubuntu-ports noble/multiverse arm64 Packages [274 kB]
Get:8 http://ports.ubuntu.com/ubuntu-ports noble/restricted arm64 Packages [113 kB]
Get:9 http://ports.ubuntu.com/ubuntu-ports noble-updates/main arm64 Packages [1164 kB]
Get:10 http://ports.ubuntu.com/ubuntu-ports noble-updates/multiverse arm64 Packages [32.7 kB]
Get:11 http://ports.ubuntu.com/ubuntu-ports noble-updates/restricted arm64 Packages [1090 kB]
Get:12 http://ports.ubuntu.com/ubuntu-ports noble-updates/universe arm64 Packages [1311 kB]
Get:13 http://ports.ubuntu.com/ubuntu-ports noble-backports/universe arm64 Packages [16.1 kB]
Get:14 http://ports.ubuntu.com/ubuntu-ports noble-security/universe arm64 Packages [1028 kB]
Get:15 http://ports.ubuntu.com/ubuntu-ports noble-security/multiverse arm64 Packages [30.8 kB]
Get:16 http://ports.ubuntu.com/ubuntu-ports noble-security/main arm64 Packages [843 kB]
Get:17 http://ports.ubuntu.com/ubuntu-ports noble-security/restricted arm64 Packages [1041 kB]
Fetched 28.4 MB in 16s (1826 kB/s)
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
18 packages can be upgraded. Run 'apt list --upgradable' to see them.
root@ee871cc6ca5f:/# apt install nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
Suggested packages:
  hunspell
The following NEW packages will be installed:
  nano
0 upgraded, 1 newly installed, 0 to remove and 18 not upgraded.
-------------------code----------------------

- Before installing a package, we should always run apt update
to update our package database. And then we can install a package like nano.
-------------------code----------------------
apt update
apt update nano
-------------------code----------------------

- Now we'll talk about nano later in this section. But before going forward, let's make sure
that this package is installed properly.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
-------------------code----------------------


- So we have installed nano.
Now let's say we want to remove it.
So we type apt remove nano. It's asking for confirmation.
So nano is gone.
-------------------code----------------------
root@ee871cc6ca5f:/# apt remove nano
Reading package lists... Done
Building dependency tree... Done
Reading state information... Done
The following packages will be REMOVED:
  nano
0 upgraded, 0 newly installed, 1 to remove and 18 not upgraded.
After this operation, 909 kB disk space will be freed.
Do we want to continue? [Y/n] y
(Reading database ... 4451 files and directories currently installed.)
Removing nano (7.2-2ubuntu0.1) ...
-------------------code----------------------

- If we type nano,
we get this error saying no such file or directory.
Now here's a little exercise for we.
In this image we don't have python.
So we get an error.
-------------------code----------------------
root@ee871cc6ca5f:/# nano
bash: /usr/bin/nano: No such file or directory
-------------------code----------------------

- Homework: use apt to install python in this image.
Make sure it works and then remove it.

*** 5- Linux File System ***

- So, in Linux, just like Windows,
our files and directories are organized in a tree,
in a hierarchical structure. So, in Windows
we have a structure like this, with C drive on top
of the hierarchy, then below that we have directories like
program files, windows and so on. 
-------------------code----------------------
C:\
  Program Files
  Windows
-------------------code----------------------

- In Linux we have the root directory on top of the hierarchy.
Below that we have a bunch of standard directories, for example
we have bin, which includes binaries or programs. We have boot, which includes all the
files related to booting. Then we have dev, the first time we saw this, we thought this is short for development.
It's not. It's short for devices. So, in Linux
everything is a file, including devices,
directories, network sockets, pipes and so on.

-------------------code----------------------
- /
  bin
  boot
  dev
  etc
  home
  root
  lib
  var
  proc
-------------------code----------------------



- So, the files that are needed to access devices are
stored in this directory. Then we have etsy,
there are different opinions what is this short for, but one common
opinion is, this is short for editable text configuration.
So, this is where we have configuration files.

- We also have home, this is where home directories
for users are stored. So, on a machine with multiple users,
each user is going to have a home directory here.
We also have root, which is the home directory of the root user.
Only the root user can access this directory.
Then we have lib, which is used for keeping library files
like software library dependencies. We have var,
which is short for variable, and this is where we have files
that are updated frequently, like log files,
application data and so on. And finally, we have proc,
which includes files that represent running processes.

- So, once again, in Linux, everything is a file.
Processes, devices, even directories are files.
Now, we don't need to memorize any of these directories.
we just listed them here, so as we go through the course,
these directories look familiar to us.

*** 6- Navigating the File System ***

- Let's see how we can navigate the Linux file system. So the first command we're going to talk about is pwd
which is short for print working directory. With this we can see
where we are in the file system. So a forward slash
represents the root directory. 
-------------------code----------------------
root@8a65a7f2dd58:/# pwd
/
-------------------code----------------------

- Now to see the files and directories here, we type ls which is short for list. So we have
bin which we talked about earlier, that is short for binaries, this is where we have binary
files and programs, we have dev which includes files for devices,
we have boot which includes boot files, etsy which includes configuration
files and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, by default ls lists these items on multiple lines. If we don't like this layout and want to show
one item per line, we need to pass an option, that is dash
one. we might prefer this layout.
-------------------code----------------------
root@8a65a7f2dd58:/# ls -1
bin
boot
dev
etc
home
lib
media
mnt
opt
proc
root
run
sbin
srv
sys
tmp
usr
var
-------------------code----------------------

- We have another option, dash l, for seeing a long listing.
This listing includes more details. So in the first column we have the permissions of this file or directory.
The first time we see this, it might look really scary,
We'll talk about that later in this section. Over here, we can see
the user that owns this file or directory, we can see the size, we can see
the date and so on. 
-------------------code----------------------
root@8a65a7f2dd58:/# ls -l
total 48
lrwxrwxrwx   1 root root    7 Apr 22  2024 bin -> usr/bin
drwxr-xr-x   2 root root 4096 Apr 22  2024 boot
drwxr-xr-x   5 root root  360 Mar 17 15:46 dev
drwxr-xr-x   1 root root 4096 Mar 17 15:46 etc
drwxr-xr-x   3 root root 4096 Jan 27 02:19 home
lrwxrwxrwx   1 root root    7 Apr 22  2024 lib -> usr/lib
drwxr-xr-x   2 root root 4096 Jan 27 02:12 media
drwxr-xr-x   2 root root 4096 Jan 27 02:12 mnt
drwxr-xr-x   2 root root 4096 Jan 27 02:12 opt
dr-xr-xr-x 168 root root    0 Mar 17 15:46 proc
drwx------   2 root root 4096 Jan 27 02:19 root
drwxr-xr-x   4 root root 4096 Jan 27 02:19 run
lrwxrwxrwx   1 root root    8 Apr 22  2024 sbin -> usr/sbin
drwxr-xr-x   2 root root 4096 Jan 27 02:12 srv
dr-xr-xr-x  11 root root    0 Mar 17 15:46 sys
drwxrwxrwt   2 root root 4096 Jan 27 02:19 tmp
drwxr-xr-x  11 root root 4096 Jan 27 02:12 usr
drwxr-xr-x  11 root root 4096 Jan 27 02:19 var
-------------------code----------------------

- Now to change the current directory, we use
the cd command, we have the same command in windows. Now here we can
type a relative or an absolute path. A relative path
is relative to where we are. So in this root directory, we have directories like bin, boot and so on. So this is a relative
path. Now in contrast, an absolute path
always starts from the root directory. So, let's go to a directory starting with
e. Now we can press tab to get autocompletion, beautiful.
Now let's go to a directory starting with a. Now if we press tab,
nothing happens because we have multiple directories starting with a.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/a
alternatives/ apt/
-------------------code----------------------

- So we have to press tab one more time, great. So, we have
three entries, three directories, add user.conf, alternatives
and apt. So, let's type the second letter, p and then press tab.
-------------------code----------------------
root@8a65a7f2dd58:/# cd etc/apt/
-------------------code----------------------

- Now let's see what we have in this directory. So,
these blue items are directories and sources that list is a file.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# ls
apt.conf.d  auth.conf.d  keyrings  preferences.d  sources.list  sources.list.d  trusted.gpg.d
-------------------code----------------------v

- Now to get out of this directory we can go one level up by typing two periods.
-------------------code----------------------
root@8a65a7f2dd58:/etc/apt# cd ..
-------------------code----------------------

- Again, to get to the etsy directory or two levels up to get to the root directory.
Look, we're currently in the root directory.
-------------------code----------------------
root@8a65a7f2dd58:/etc# cd ../..
-------------------code----------------------

-  Now, when using ls, we can optionally specify a path. Let's say we're somewhere in the file system, but we want to
look at the content of another directory. we don't want to navigate to that directory.
So, we're currently in the root directory, we want to know what files and directories
we have inside the bin directory. So once again, we can type a
relative path or an absolute path starting from the root directory.
So, here are the binaries in this directory. Look at pwd. That's the command
that we just executed. So, pwd is a program in this directory. Here's another example.
Look at echo. So, most of the commands we have been exploring so far are programs
or binaries in the bin directory.
-------------------code----------------------
root@8a65a7f2dd58:/# ls bin
'['              cut                       expiry      join               mount           readlink            skill       uncompress
 addpart         dash                      expr        kill               mountpoint      realpath            slabtop     unexpand
 apt             date                      factor      last               mv              rename.ul           sleep       uniq
 apt-cache       dd                        faillog     lastb              namei           renice              snice       unlink
 apt-cdrom       deb-systemd-helper        fallocate   lastlog            nawk            reset               sort        unminimize
 apt-config      deb-systemd-invoke        false       ld.so              newgrp          resizepart          split       unshare
 apt-get         debconf                   fgrep       ldd                nice            rev                 stat        update-alternatives
 apt-key         debconf-apt-progress      find        link               nisdomainname   rgrep               stdbuf      uptime
 apt-mark        debconf-communicate       findmnt     linux32            nl              rm                  stty        users
 arch            debconf-copydb            flock       linux64            nohup           rmdir               su          utmpdump
 awk             debconf-escape            fmt         ln                 nproc           run-parts           sum         vdir
 b2sum           debconf-set-selections    fold        locale             nsenter         runcon              sync        vmstat
 base32          debconf-show              free        locale-check       numfmt          savelog             tabs        w
 base64          delpart                   getconf     localedef          od              script              tac         wall
 basename        df                        getent      logger             pager           scriptlive          tail        watch
 basenc          diff                      getopt      login              partx           scriptreplay        tar         wc
 bash            diff3                     gpasswd     logname            passwd          sdiff               taskset     wdctl
 bashbug         dir                       gpgv        ls                 paste           sed                 tee         whereis
 captoinfo       dircolors                 grep        lsattr             pathchk         select-editor       tempfile    which
 cat             dirname                   groups      lsblk              perl            sensible-browser    test        which.debianutils
 chage           dmesg                     gunzip      lscpu              perl5.38.2      sensible-editor     tic         who
 chattr          dnsdomainname             gzexe       lsipc              pgrep           sensible-pager      timeout     whoami
 chcon           domainname                gzip        lslocks            pidof           sensible-terminal   tload       xargs
 chfn            dpkg                      hardlink    lslogins           pidwait         seq                 toe         yes
 chgrp           dpkg-deb                  head        lsmem              pinky           setarch             top         ypdomainname
 chmod           dpkg-divert               hostid      lsns               pkill           setpriv             touch       zcat
 choom           dpkg-maintscript-helper   hostname    man                pldd            setsid              tput        zcmp
 chown           dpkg-query                iconv       mawk               pmap            setterm             tr          zdiff
 chrt            dpkg-realpath             id          mcookie            pr              sg                  true        zdump
 chsh            dpkg-split                infocmp     md5sum             printenv        sh                  truncate    zegrep
 cksum           dpkg-statoverride         infotocap   md5sum.textutils   printf          sha1sum             tset        zfgrep
 clear           dpkg-trigger              install     mesg               prlimit         sha224sum           tsort       zforce
 clear_console   du                        ionice      mkdir              ps              sha256sum           tty         zgrep
 cmp             echo                      ipcmk       mkfifo             ptx             sha384sum           tzselect    zless
 comm            egrep                     ipcrm       mknod              pwd             sha512sum           uclampset   zmore
 cp              env                       ipcs        mktemp             pwdx            shred               umount      znew
 csplit          expand                    ischroot    more               rbash           shuf                uname
-------------------code----------------------

 
- Now, let me show we a shortcut. Earlier we
told we that, here we have this home directory where each user
has a home directory. But the root user has a special home directory called root.
-------------------code----------------------
root@8a65a7f2dd58:/# ls
bin  boot  dev  etc  home  lib  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
-------------------code----------------------

- Now, to get here, there are two options.
We can type an absolute or relative path and go to root.
-------------------code----------------------
cd root/
-------------------code----------------------

- But there is a shortcut. So, we're currently in the root directory. To get to my
home directory, we can type a tilde. And this applies to all
users, not just the root user. Whenever we type cd
tilde, we go to our home directory. 

-------------------code----------------------
root@8a65a7f2dd58:/# cd ~
root@8a65a7f2dd58:~#
-------------------code----------------------
