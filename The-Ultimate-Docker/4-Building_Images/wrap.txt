*** 1- Introduction ***
The first step in using Docker to build and deploy applications is creating images. 
So having a solid understanding of Docker images is crucial for us. And that's what this section is all about.

- We'll be talking about creating Docker files, versioning images, sharing them, saving and
loading them, and a few optimization techniques for reducing the image size and speeding up builds.

In this section:
-------------------code----------------------
• Creating Docker files
• Versioning images
• Sharing images
• Saving and loading images
• Reducing the image size
• Speeding up builds
-------------------code----------------------

*** 2- Images and Containers ***

Alright, before we get started, let's make sure we have the right understanding of
images and containers. 
- Can we define what an image is, and how it's different from a container? 
An image includes everything
an application needs to run. So, it contains a cut down
operating system, like Linux or Windows. It also contains third party libraries,
application files, environment variables and so on. So, an image
contains all the files and configuration settings needed to run
an application. Once we have an image, we can start a container from it.
-------------------code----------------------
IMAGE
• A cut-down OS
• Third-party libraries
• Application files
• Environment variables
-------------------code----------------------

- A container is kind of like a virtual machine in the sense that it provides
an isolated environment for executing an application. And similar
to virtual machines, we can stop and restart containers. Now
technically, a container is just an operating system process, but it's a
special kind of process because it has its own file system which is provided
by the image.
-------------------code----------------------
CONTAINER
• Provides an isolated environment
• Can be stopped & restarted
• Is just a process!
-------------------code----------------------

-  Now, In the previous section we started a container from the Ubuntu image. Now we're going to
open up another terminal window. 
-------------------code----------------------
~  $ docker start -i 8a6
root@8a65a7f2dd58:/#
-------------------code----------------------

- Let's run docker ps to see the running processes or running containers.
So here's the container that we started in the previous section.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED        STATUS          PORTS     NAMES
8a65a7f2dd58   ubuntu    "/bin/bash"   14 hours ago   Up 45 seconds             eloquent_lichterman
-------------------code----------------------
PS: start command to start and exist container

- Now we're going to start a new container from the same image.
We type docker run, we want to run this in the interactive mode so we can work with it. And then we type
the name of the image, so Ubuntu.
-------------------code----------------------
~  $ docker run -it ubuntu
root@17e332c0bbd7:/#
-------------------code----------------------
PS: to create new container and start it

- here's the container ID and as we can see, this is different from
this other container. Now, back to our first container, we're currently
inside the home directory. So in the previous section we created
a bunch of directories and this deployment file.
-------------------code----------------------
~  $ docker ps
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
c315081d7859   ubuntu    "/bin/bash"   2 seconds ago    Up 1 second               charming_mccarthy
17e332c0bbd7   ubuntu    "/bin/bash"   24 seconds ago   Up 23 seconds             blissful_albattani
-------------------code----------------------

- Now, back to our new container, let's go to the home directory
and see what is here. There's nothing here. Here's the reason. A container gets its file system
from the image, but each container has its own write layer. So what we write in a given container
is invisible from other containers.
-------------------code----------------------
root@17e332c0bbd7:/# cd home/
root@17e332c0bbd7:/home# ls
ubuntu
-------------------code----------------------

- Of course, there is a way to share data between containers and we'll talk about that later in the course.
But what we want to understand here
is that each container is an isolated environment for executing an application.
It's an isolated universe. So whatever happens inside that universe
is invisible to other containers.

*** 3- Sample Web Application ***

- So over the next few lessons, we're going to take a front-end application built with
React and package it into a docker image. 

- To run this project on a new machine, first we have to
install node, then using npm we have to install third party dependencies
and finally, to start the project we have to type npm start. 
-------------------code----------------------
STEPS
• Install Node
• npm install
• npm start
-------------------code----------------------

- We have the same concept in other development stacks. So
whether we use C sharp or java or python or ruby, we have some tool to manage
the dependencies of our application and then we have a way to start our application.

- Here we have to use npm start. So, let's go ahead. This started at development server
listening on port 3000. So if we go to localhost port
3000, we can see our react application. This is just a basic react application
like a brand new project. 
-------------------code----------------------
localhost:3000
-------------------code----------------------

- we haven't done anything here and it doesn't really matter.
Later in the course, we're going to show we a real project that we have built using react
and node. So now that we understand what this project is and how we can
run it on a new machine, let's see how we can
use docker so we don't have to repeat all these steps every time we want to deploy
this on a new machine.

*** 4- Dockerfile Instructions ***
- The first step to dockerize an application is adding a docker file to it.

- what is a docker file?
It contains instructions for building an image.
we saw a few of these instructions before, but let's go through the complete list so we know what is available.
We have from for specifying the base image, so we take that base image
which contains a bunch of files and directories and then we build on top of it.
Then we have workdir for specifying the working directory. Once we use this command,
all the following commands will be executed in the current working directory.
We have copy and add for copying files and directories.
We have run for executing operating system commands. So all the Linux commands
that we talked about in the previous section, we can execute them using run.
Now, if we're on Windows, we can execute Windows commands using run as well.
We have env for setting environment variables, expose for text.
for telling docker that our container is starting on a given port.
User for specifying the user that should run the application.
Typically, we want to run our application using a user with limited privileges.
And we have command and entry point for specifying the command that should be executed
when we start a container. So that's the big picture.
-------------------code----------------------
DOCKERFILE
• FROM                 • ENV
• WORKDIR              • EXPOSE
• COPY                 • USER
• ADD                  • CMD
• RUN                  • ENTRYPOINT
-------------------code----------------------

Now, over the next few lessons, we're going to explore each of these commands in detail.
Pull our basic commands in detail.

*** 5- Choosing the Right Base Image ***

- Alright, let's start off by adding a dockerfile to this project. So,
here in the root of this project, we're going to add a new file called dockerfile.
Now the first instruction we're going to use is from, which we use for specifying the base image. The base image can be an
operating system like Linux or Windows or it can be an operating system
plus a runtime environment. 

- For example, if we're a C sharp developer, we want to start from a dotnet image. If we're a python developer,
we want to start from a python image. If we're a javascript developer, we want to start
from a node image. Now if we google docker samples, we can find
this page.
-------------------code----------------------
docs.docker.com/samples/
-------------------code----------------------

- in the left menu, we can see various examples of docker files for different technology
stacks. For example, for an aspen.net core application,
we can see a docker file. Now look at the from instruction. Over here, we have a full url
instead of an image. Because microsoft images are not hosted on docker
hub. They're hosted in microsoft container registry. That's why we have
MCR, which is short for microsoft container registry.
So an image can be in any registries. The default registry that docker
uses is docker hub. For any images, in other registries,
we have to type the full url. 
-------------------code----------------------
FROM mcr.microsoft.com/dotnet/core/sdk:3.1 AS build-env
-------------------code----------------------

- Now, don't just blindly take this url. Because the url can change, or the version
can change. So always do our own research. So that's one example.
If we're a Django developer, we want to start from
python 3. Or in the future, we might want to use
python 4. Now what about this project? Well, for this project,
we need node. Because as we saw, we need
npm to install the application dependencies and start the application. 

- So let's go to hub.docker.com and search for node.
-------------------code----------------------
hub.docker.com
-------------------code----------------------

- Now this is where things get a little bit interesting.
Because node repository on docker hub has hundreds of node images.
And this can be a little bit confusing. So, let's go to the tags.
Here we can see various node images. So if we scroll down, we can see there are
tons of node images for different versions built on
different versions of Linux.
For example, we have node version 14.16.0
on top of buster which, if we're not wrong, is
Debian Linux version 10.

- So we have different versions of node on different
versions of Linux. The image we should choose really depends on our application.
What version of node do we want to target? We can go to our docker file
and say, we want to start from node and by default, docker
assumes the latest tag. Do not ever use this.
Because if we build our application against the latest version of node, next time there is
a new version of node, if we rebuild our application's image, our application will
be built with a different version of node
and things can get unpredictable. So always use a specific version.
-------------------code----------------------
FROM node:latest
-------------------code----------------------

- So, back to docker hub. Let's say we want to build this application
against node version 14. So here we search for 14. Now once again we have
tens or maybe hundreds of node images for version 14.
Here's one we just talked about. There is more.
We have version 14 on top of buster. So this one doesn't have
the minor build number. It's just a major version number.
Now look at the size of this image. It's around 300 megabytes.
And why do we have multiple items in this list? Well, this image is built
for different operating system and CPU architectures.
So, there's two more here. As we can see, all of these
are built on top of Linux. So as far as we know, we don't have a node image
built on top of Windows. we could be wrong. But if we want to run on top of Windows,
we have to start from a Windows image and then install node on top of it.
There's no reason we want to do this
because Windows images are really large. we think they're over 2 gigabytes.

- So, back to the story. Depending on our CPU architecture,
when we pull an image, docker will automatically download the right docker image
for our CPU architecture, Now, we don't want to use any of these images
because these are way too large. And this is the compressed size.
When this is uncompressed, it's going to be around 1 gigabyte.
we want to go for a smaller image and deployments faster.

- So, on this page, let's search for Alpine.
Earlier we told we that, Alpine images are really small.
Look at this. The compressed size is around 40 megabytes.
This image is almost 10 times smaller than the other image we saw.
Now look at the image tag. It's very specific.
Version 14.16.0 of node, built on top of
Alpine 3.13. we're happy with this version, so we're going to copy this.
And then paste it after the FROM.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
-------------------code----------------------

- So that was the first step.
Now, back to our terminal window, here in the project directory, we're going to build an image.
So, we run docker build dash t for tagging the image.
We're going to call this image react app
and we type a period to tell docker where it can find a docker file.
That means in the current directory.
-------------------code----------------------
docker build -t react-app .
-------------------code----------------------

- Let's go ahead. Okay, the image was built.
So now, we're going to look at all the images
we have on this machine using docker images or docker image ls.
So currently we have three images.
Here's the image that we just built.
-------------------code----------------------
REPOSITORY     TAG       IMAGE ID       CREATED        SIZE
hello-docker   latest    817ba4c523a5   27 hours ago   160MB
<none>         <none>    8af7922e7fd1   27 hours ago   160MB
ubuntu         latest    c3d1a3432580   7 weeks ago    101MB
react-app      latest    322425dfa4aa   3 years ago    116MB
-------------------code----------------------


- Now let's start a container with this image
and see what happens. So docker run, we want to run this in the interactive mode
so we can play with it and the image is react app.
-------------------code----------------------
~  $ docker run -it react-app
Welcome to Node.js v14.16.0.
Type ".help" for more information.
>
-------------------code----------------------

- What's going on here? We're inside a node environment.
So here we can write javascript code and node will execute it.
For example, we can define a constant and then log the constant.
-------------------code----------------------
> const x = 1
undefined
> console.log(x)
1
-------------------code----------------------

- So we're inside a node environment.
We don't want this. We want to run bash
so we can look at the file system. So we press control and see.
Now it says to exit, press control and see one more time.
So the container is stopped. Let's run it one more time.
So docker run interactive react app. Now at the end,
we can specify the command to run
when starting this container. We want to run bash.
Now look. We get an error saying
this module is not found. Why is that?
Because alpine Linux doesn't come with bash. That's why it's a very small
Linux distribution. So it doesn't have many of the utilities
we're familiar with. 
-------------------code----------------------
~  $ docker run -it react-app bash
internal/modules/cjs/loader.js:883
  throw err;
  ^

Error: Cannot find module '/bash'
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:880:15)
    at Function.Module._load (internal/modules/cjs/loader.js:725:27)
    at Function.executeUserEntryPoint [as runMain] (internal/modules/run_main.js:72:12)
    at internal/main/run_main_module.js:17:47 {
  code: 'MODULE_NOT_FOUND',
  requireStack: []
}
-------------------code----------------------

- Instead of bash, it comes with shell. The original shell program.
So one more time. Docker run interactive
react app. Instead of bash, we're going to use shell.
-------------------code----------------------
~  $ docker run -it react-app sh
/ # ls
bin    dev    etc    home   lib    media  mnt    opt    proc   root   run    sbin   srv    sys    tmp    usr    var
-------------------code----------------------

- Now we're doing a shell session inside this container.
So let's look around. We have all these directors we're familiar with.
So this is alpine Linux and in this image we also have node.
So if we type node dash dash version, we can see the version of node
which is 14.16.0.

- Now in this image we don't have our application files.
We only have alpine Linux and node. So in the next lesson we're going to show we
how to copy application files into this image.
-------------------code----------------------
/ # node --version
v14.16.0
-------------------code----------------------

*** 6- Copying Files and Directories ***

- Now that we have a base image, the next step is to copy the application
files into the image. So for that we have two instructions, one is
copy, the other is add. They have the exact same syntax,
but add has a couple additional features, we'll talk about that later in this lesson.
-------------------code----------------------
ADD 
COPY
-------------------code----------------------

- So, let's start with copy. With this we can copy one or
more files or directories from the current directory, meaning
this directory over here into the image. So we cannot copy
anything outside of this directory. 

- Here's the reason. When we execute the build command, look at the last argument. A period means the
current directory. So when we execute this command, docker client
sends the content of this directory to docker engine. This is called the
build context. So docker client sends the build context to docker
engine, and then docker engine will start executing these commands
one by one. So at that point, docker engine does not have access
to any files or directories outside of this directory.
-------------------code----------------------
docker build -t react-app .
-------------------code----------------------

- So, here we can copy one or more files. For example, we can copy
package.json into slash app into the image. Now if this directory doesn't exist, docker will automatically
create it.
-------------------code----------------------
COPY package.json /app
-------------------code----------------------

-  We can also copy more than one file, so we can say
readme.md, and by the way, remember this is case sensitive because under the hood we are using
Linux. 
-------------------code----------------------
COPY package.json README.md /app
=> when using COPY with more than one source file, the destination must be a directory and end with a / or a \
-------------------code----------------------

- Now here we have a syntax arrow, look, when using
copy with more than one source file the destination must be a directory
and end with a forward slash. So, here we need to add a
forward slash.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
COPY package.json README.md /app/
-------------------code----------------------

- We can also use patterns. So, let's say, we want to copy all files
that start with package and end with json. So, whatever comes in between
we don't care. That's why we're using a wild card. So, in this directory
we have two files that match this pattern we have package-lock.json
and package.json. Package.json as we told we before includes the list of dependencies
and their versions. But the actual versions that may be installed on this machine
might be a little bit different from what we see here.
So, package-lock.json keeps track of the exact version of these dependencies
installed on this machine.
-------------------code----------------------
COPY package*.json /app/
-------------------code----------------------

- Now, what if we want to copy everything in the current directory into the
app directory? We use a period. So, this is all about source files
and directories.
-------------------code----------------------
COPY . /app/
-------------------code----------------------

-  Now, let's talk about the destination. So, here we're using
an absolute path because our path starts with a forward slash.
We can also use a relative path if we set the working directory first.
So, using the workdir instruction we can set the working directory.
Now, all the instructions that come after will be executed inside
this working directory. And with this we can replace this absolute path
with a relative path. So, we can use a period meaning the current directory. Okay?
-------------------code----------------------
WORKDIR /app
COPY . . 
-------------------code----------------------

- Now, one last thing about copy.
What if we want to copy a file that has
a space in it? So, let's say we have a file called hello world
dot txt. Look, we immediately get a syntax error.
-------------------code----------------------
COPY hello world.txt . 
=> when using COPY with more than one source file, the destination must be a directory and end with a / or a 
-------------------code----------------------

- This is where we use the other form of the
copy instruction. So, copy has another form where
we can pass an array of strings.
-------------------code----------------------
["", "", ""]
-------------------code----------------------

- So, multiple strings. Each string represents an
argument of the copy instruction. So, here, we're going to wrap
all these arguments inside brackets. Then, we're going to wrap
the first item, which is our source file in double quotes.
Then, we add a comma, and wrap the second argument in double quotes.
It's not a form that we use that often, but we thought to cover it to make this less
uncomprehending.
-------------------code----------------------
COPY ["hello world.txt", "."]
-------------------code----------------------

- So, let's simplify things. We're going to copy everything
in our context directory, which is the current directory,
into the current working directory of the image. Okay? Now,
we also have add, it has the exact same syntax as copy,
but add has two additional features. 
-------------------code----------------------
COPY . . 
ADD . .
-------------------code----------------------

- With add, we can add a file from a url, so here we can type
http, some url, and let's say some
file.json. So, if we have access to this file, we can add it to our
image. The other feature is that if we pass
a compressed file, add will automatically uncompress this
into a directory. So, we can use either of these instructions, but the
best practice is to use copy, because it's more straightforward, there's no magic
around it. Use that only if we need one of these additional features.
If we want to add a file from a url, or if we want to uncompress a compressed
file. 
-------------------code----------------------
ADD http://.../file.json .
ADD file.zip .
-------------------code----------------------

- So, let's get rid of this. We're going to copy everything
in the current directory into our image. So, let's go ahead and
rebuild our image. 
-------------------code----------------------
FROM node:14.16.0-alpine3.13
WORKDIR /app
COPY . . 
-------------------code----------------------

- Alright, now look at this line.
Transferring context. So, all the files and directors
in our current directory are being sent to docker engine.
Alright, the image is built, so let's start the container with this image.
-------------------code----------------------
app [master] $ docker build -t react-app .
[+] Building 1.8s (8/8) FINISHED                                                                                                   docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 125B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         1.7s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 2B                                                                                                                    0.0s
 => CACHED [1/3] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b            0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 546.22kB                                                                                                              0.0s
 => [2/3] WORKDIR /app                                                                                                                             0.0s
 => [3/3] COPY . .                                                                                                                                 0.0s
 => exporting to image                                                                                                                             0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:8816b1815607d3d204cd7f33a3fc141a29e6f96809a6a9a932af2bc578a20463                                                       0.0s
 => => naming to docker.io/library/react-app                                                                                                       0.0s
-------------------code----------------------

- we're going to run shell, so we can look at the file
system. Okay, look, we're inside the app directory,
because in our docker file, we set this directory as the current working
directory. Now, let's run ls. So, here we can see all the files
and directories we have in our project, including node modules.
So, this is all about copying files.
-------------------code----------------------
~  $ docker run -it react-app sh
/app # ls
Dockerfile    README.md     package.json  public        src           yarn.lock
-------------------code----------------------

*** 7- Excluding Files and Directories ***

- In the last lesson we saw that when we build our application, docker
client takes everything in this directory which is called the build context or
the context directory. So docker client takes everything here and sends
it to docker engine or docker daemon. 

- Now for this simple application which has absolutely no features, our build context was about
150 megabytes. But why is it so large? That's the
result of the node modules directory. So if we look over here, we can see
tons of directories and sub directories and this is a very simple project.

- As our application gets more complex and we use more third party
libraries, this node modules directory gets larger and larger. Now
there's a problem here. Later in the course when we talk about deployment, we will see
that our docker client will talk to a docker engine on a different machine.
So that means whatever we have in the build context has to be transferred
over the network. So if we have a large build context with a million files
in it, all these files have to be sent to the docker engine on the remote machine.
We don't want that. We don't really need to transfer this node modules directory
because all these dependencies are defined in package.json. So we can simply exclude this directory
and copy everything else and then restore these dependencies on the target
image. 

- And this has two benefits. The first benefit is that our build context
is smaller. So we transfer less data over the network.
The second benefit is that our build is going to be faster. So we don't have to wait
for all these files to be transferred to docker engine.

- Now how do we exclude this directory? Very easy. we are probably familiar
with the file ".gitignore" With this file, we can exclude some files and directories
from git. Now we have the same concept in docker. So we can
create a file in the root of this project called ignore and everything
is in lowercase. And here we can list the files and directories that should be excluded.
-------------------code----------------------
.dockerignore
-------------------code----------------------
 
- So we can exclude node modules.
Now, when we build a new image, docker will no longer transfer
this large gigantic directory to docker engine. Let's take a look.
So, we're going to run the build command one more time.
-------------------code----------------------
node_modules
-------------------code----------------------

- Look at our build context. It's only 10 kilobytes. So we reduce
our build context from 150 megabytes to 10 kilobytes.
That's a huge improvement. There is a problem though. If we start
a new container and look at the file system
of that container, we're not going to see
the node modules directory because we excluded
it, Let's verify it. 

- So, we're going to run a new container
from react app and then run shell inside that container.
Now in the app directory, let's look at all the files and directories.
Look, we only have two directories here, public and source. So node modules
is not here. This is where we need to run
npm install to install this dependencies. And that's what we will do next.
-------------------code----------------------
/app # ls
Dockerfile    README.md     package.json  public        src           yarn.lock
-------------------code----------------------

*** 8- Running Commands ***

- Alright, the next step is to install
our project dependencies using npm. This is where we use the run command.

- With this command, we can execute any commands that we normally execute
in a terminal session. So we can run npm install, we can also run any of the Linux or Windows commands.
For example, let's say we want to install Python on this image as well.
We can use apt or apt-get to install Python.
-------------------code----------------------
RUN npm install
RUN apt install python
-------------------code----------------------
- Now if we run this, we're going to get an error because alpine Linux doesn't have
apt package manager. It has another package manager called
APK. So be aware of these differences depending on the type of Linux
or Windows we're using.

- So, we don't need to do this in this lesson. Let's just install the dependencies of our project.
So, now, back to our terminal, let's rebuild the image.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
WORKDIR /app
COPY . . 
RUN npm install
-------------------code----------------------

- Alright, so now, docker engine is running npm install to download and install
these dependencies. This is going to take a few seconds, our image is ready.
-------------------code----------------------
app [master] $ docker build -t react-app .
[+] Building 10.5s (7/8)                                                                                                           docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 141B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         4.7s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/4] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 1.67kB                                                                                                                0.0s
 => CACHED [2/4] WORKDIR /app                                                                                                                      0.0s
 => [3/4] COPY . .                                                                                                                                 0.0s
 => [4/4] RUN npm install                                                                                                                          5.7s
 => => # npm WARN deprecated
 .....
-------------------code----------------------

- So, let's start a new container with this image
and run shell. Good. Now let's look at our app directory.
Alright, and here we have the node modules directory.
Beautiful. So, we're done with this step.
-------------------code----------------------
~  $ docker run -it react-app sh
/app # ls
Dockerfile         node_modules       package.json       src
README.md          package-lock.json  public             yarn.lock
-------------------code----------------------

*** 9- Setting Environment Variables ***

- Sometimes we need to set environment variables. For example, let's say
this frontend application needs to talk to a backend or an API.

- Quite often we set the URL of the API using an environment variable.
This is where we use the end instruction, so we can set API URL to, let's say, http, api
myapp.com, whatever, doesn't really matter.
-------------------code----------------------
ENV API_URL=http://api.myapp.com/
-------------------code----------------------

- We also have an older syntax without an equal sign that also works.
-------------------code----------------------
ENV API_URL http://api.myapp.com/
-------------------code----------------------

- personally prefer to have an equal sign so we can clearly see the value
of environment variables, but that's just our personal preference.

- Now, let's rebuild the image and inspect this environment variable in our
container. So, we're going to rebuild the image.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
WORKDIR /app
COPY . . 
RUN npm install
ENV API_URL=http://api.myapp.com/
-------------------code----------------------

- the image is built, so let's start a new container.
Now, do we remember the command that we use for inspecting environment variables?
We have a few options. One way is to use printenv to see all environment variables, so we can see
API URL over here.
-------------------code----------------------
~  $ docker run -it react-app sh
/app # printenv API_URL
http://api.myapp.com/
-------------------code----------------------

- We can also print the value of a particular environment variable. Another option is to use
echo, but here we have to use a dollar sign to print API
URL.
-------------------code----------------------
/app # echo $API_URL
http://api.myapp.com/
-------------------code----------------------

- so now whenever we start this container,
this environment variable is automatically set for us.

*** 10- Exposing Ports ***

Alright, let's take a quick break from our
docker file and start this application outside of docker. The way we have
always started it. So, from the project directory we run npm
start. 
-------------------code----------------------
npm start
> react-app@o.1.0 start 
> react-scripts start
-------------------code----------------------

-  Now this starts at development server
on port 3000, so if we go to local host port 3000, we can access this application. Now in the future
when we run this application inside a docker container, this port
3000 will be open on the container, not on the host.
-------------------code----------------------
localhost:3000
-------------------code----------------------

- This is something important we need to understand. So on the same machine
we can have multiple containers running the same image. All these containers
will be listening to port 3000, but the port 3000 on the host
is not going to be automatically mapped to these containers. So later,
in the next section we will see how to map a port on the host
to a port on these containers.
-------------------code----------------------
EXPOSE 3000
-------------------code----------------------

-  But for now we're going to go back to our docker
file and use the expose command to tell what port this container
will be listening on. That is port 3000.

- So, the expose command doesn't automatically publish the port on the host, it's just a form
of documentation to tell us this container
will eventually listen on port 3000. So later
when we properly run this application inside a docker container
we know that we should map a port on the host
to port 3000 on the container. We'll do that in the next section.

*** 11- Setting the User ***

- Alright, now let's talk about users.
So by default, docker runs our application with the root user
that has the highest privileges. 

- So that can open up security holes in our
system. So to run this application, we should create a regular user
with limited privileges. 

- But before doing that in the docker file,
let's open up a shell session on Alpine Linux and play with a few commands.
Now, , we're going to run docker run in the interactive mode
Alpine. So here we have a shell session.
-------------------code----------------------
$ docker run -it alpine
-------------------code----------------------

-  Now, in this image, we don't have the user add command.
-------------------code----------------------
/ # useradd
/bin/sh: useradd: not found
-------------------code----------------------

- Instead we have add user, So,
look at these options. There are two options we're going to use.
One of them is dash g for setting the primary group of the user
and the other is dash s for creating a system user.
-------------------code----------------------
/ # adduser
BusyBox v1.37.0 (2025-01-17 18:12:01 UTC) multi-call binary.

Usage: adduser [OPTIONS] USER [GROUP]

Create new user, or add USER to GROUP

	-h DIR		Home directory
	-g GECOS	GECOS field
	-s SHELL	Login shell
	-G GRP		Group
	-S		Create a system user
	-D		Don't assign a password
	-H		Don't create home directory
	-u UID		User id
	-k SKEL		Skeleton directory (/etc/skel)
-------------------code----------------------

- We're going to use a system user because this user is not a real user,
it's just for running an application.

- Now, before using this command, we have to create a group
so we can add this user to that group So to do that, we're going to use add group.
We're going to give this group a name, let's say app.
-------------------code----------------------
/ # addgroup app
-------------------code----------------------

- Now we can run add user, dash s for creating a system user,
dash g for setting the primary group, which is app,
and finally we specify the name of the user.
We're going to use the same name. This is a common best practice in Linux.
So whenever we create a new user, we create a primary group for that user with the same name, okay?
-------------------code----------------------
/ # adduser -S -G app app
-------------------code----------------------

- Now we have a new user, let's verify that this user is in the right group.
So we type groups, app. This shows the groups for the app user.
-------------------code----------------------
/ # groups app
app
-------------------code----------------------

- Now we're going to combine these two commands
into a single command. So let's create another group and a user.
We type add group, we can say moody or whatever,
we use double ampersand to combine two commands,
So we used a single command to perform two tasks.
-------------------code----------------------
addgroup moody && adduser -S -G moody moody
-------------------code----------------------

- Now, let's verify the groups for moody. So this is the command
that we're going to run in our docker file.
-------------------code----------------------
/ # groups moody
moody
-------------------code----------------------

- So let's copy this, now, back to our docker file,
we're going to run a command. How do we do this?
We use the run instruction. Then we paste our command,
and instead of moody, we're going to use app.
So we're going to create a group and a user called app,
Once we do that, then we can set the user using the user command.
So all the following commands will be executed using this user.
-------------------code----------------------
RUN addgroup app && adduser -S -G app app
USER app
-------------------code----------------------

- Let's rebuild our image. So, here's the build command,
let's go ahead. Alright, our image is ready.
Now look at the fifth step. That is our run command
for creating a new group and a new user.
-------------------code----------------------
$ docker build -t react-app .
[+] Building 30.9s (10/10) FINISHED                                                                                                docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 241B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         1.7s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/5] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 1.31MB                                                                                                                0.0s
 => CACHED [2/5] WORKDIR /app                                                                                                                      0.0s
 => [3/5] COPY . .                                                                                                                                 0.0s
 => [4/5] RUN npm install                                                                                                                         26.9s
 => [5/5] RUN addgroup app && adduser -S -G app app                                                                                                0.1s
 => exporting to image                                                                                                                             2.1s
 => => exporting layers                                                                                                                            2.1s
 => => writing image sha256:7072f2f889bc06c712fdd966582f8c8c97b0727b02c26926021af2ecf05c3856                                                       0.0s
 => => naming to docker.io/library/react-app
-------------------code----------------------

- Now, we might have noticed that building this image
took probably a long time.
That was because of the step. Installing the dependencies.
Now, we might argue that earlier, we excluded the node modules directory
so our builds would be faster. But our builds are still slow
because every time we build this image, all these dependencies
have to be installed. Don't worry about that. We're going to optimize
this later in this section.

- Now, let's start a new container
and make sure the current user is the app user,
not the root user, So, docker run in the interactive mode,
we're going to run react app and start a shell session.
-------------------code----------------------
$ docker run -it react-app sh
-------------------code----------------------

- we check the current user So, it's the app user.
-------------------code----------------------
/app $ whoami
app
-------------------code----------------------

- Now, let's look at something interesting.
we're going to get a long listing.
These are the files in our application.
Now, all these files, as we can see, are owned by the root user.
And in this column, we can see the permissions
of the root user. So, the root user
can write to any of these files or directories,
but the current user running this session is the app user.
So, this user falls into the others group.
That means the app user is not able to write to any of these files.
-------------------code----------------------
/app $ ls -l
total 1272
-rw-r--r--    1 root     root           165 Mar 20 02:24 Dockerfile
-rw-r--r--    1 root     root          3362 Mar 18 06:18 README.md
drwxr-xr-x 1115 root     root         36864 Mar 20 02:25 node_modules
-rw-r--r--    1 root     root        757495 Mar 20 02:25 package-lock.json
-rw-r--r--    1 root     root           813 Mar 18 06:18 package.json
drwxr-xr-x    2 root     root          4096 Mar 18 06:18 public
drwxr-xr-x    2 root     root          4096 Mar 18 06:18 src
-rw-r--r--    1 root     root        485703 Mar 20 02:16 yarn.lock
-------------------code----------------------

- In contrast, if we executed this application
with the root user, a hacker could potentially
rewrite something in our application.

*** 12- Defining Entrypoints ***

- All right, our docker file is almost ready.
Now how do we start our application? Well, earlier we saw that. Here in the
project directory, we can start the application by running npm start.
-------------------code----------------------
npm start
-------------------code----------------------

- So this is the command that we should execute when starting a container.
So, let's start a container, docker run. Now we're not going to use the interactive mode because we don't want to interact with this container.
We're not going to run a shell session. We just want to start the application.
So, we type the image name. Now let's see if we execute
this command up to this point. Our container
started and then stopped because we didn't specify a command or
a program to execute. 
-------------------code----------------------
$ docker run react-app
-------------------code----------------------

- So this is where we're going to type npm start. Take a look.
All right, we got a permission error. Look over here. Permission denied.
-------------------code----------------------
$ docker run react-app npm start

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.2/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Failed to compile.

EACCES: permission denied, mkdir '/app/node_modules/.cache'
-------------------code----------------------

- why we're getting this error?
In our docker file, we set the user at the end. So we executed
all these previous instructions as the root user,
but then we switched to a regular user with limited privileges.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
WORKDIR /app
COPY . . 
RUN npm install
ENV API_URL=http://api.myapp.com/
EXPOSE 3000
RUN addgroup app && adduser -S -G app app
USER app
-------------------code----------------------

- So, we should move these two lines on the top. So first,
we set the user, then we create the working directory, copy files, and so on.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
RUN addgroup app && adduser -S -G app app
USER app
WORKDIR /app
COPY . . 
RUN npm install
ENV API_URL=http://api.myapp.com/
EXPOSE 3000
-------------------code----------------------

- Now we have to rebuild our image and start a new container.
All right, our image is ready.
-------------------code----------------------
$ docker build -t react-app .
-------------------code----------------------

- So, let's start a new container.
All right, our web server started on port 3000, but as we told before,
this is port 3000 of the container, not local host.
So, if we go to "3000" address, we're not going to be able to access the application.
In the next section, we will show we how to map a port from the host
to a port on the container.
-------------------code----------------------
$ docker run react-app npm start

> react-app@0.1.0 start /app
> react-scripts start

ℹ ｢wds｣: Project is running at http://172.17.0.2/
ℹ ｢wds｣: webpack output is served from
ℹ ｢wds｣: Content not from webpack is served from /app/public
ℹ ｢wds｣: 404s will fallback to /
Starting the development server...

Compiled successfully!

You can now view react-app in the browser.

  Local:            http://localhost:3000
  On Your Network:  http://172.17.0.2:3000

Note that the development build is not optimized.
To create a production build, use yarn build.
-------------------code----------------------

- let's stop this process. Let's bring up
the run command. Now, here's a problem.
We don't want to have to specify this command every time we start a container.
This is where we use the command instruction.
-------------------code----------------------
$ docker run react-app npm start
-------------------code----------------------

- So, back to our docker file, at the end,
using the command instruction, we can supply a default command to be executed.
So, npm start. Now, back to the terminal,
once we rebuild the image, then we can start a container
by simply running docker run react app.
We don't have to specify the command every time.
-------------------code----------------------
CMD npm start
-------------------code----------------------

- Just remember, because the command instruction is for supplying the default command,
it doesn't make sense to have multiple command instructions
in a docker file. If we have multiple command instructions,
only the last one will take effect. Be aware of that.

- Now, we might be wondering, what is the difference between
the command instruction CMD and RUN? Because with both these,
we can execute commands. Here's the difference.
The run instruction is a build time instruction.
So, this is executed at the time of building the image.
So, when building the image, we're installing npm dependencies,
and these dependencies are stored in the image.
In contrast, the command instruction is a runtime instruction.
So, it's executed when starting a container.

- Now, this command instruction has two forms. What we see here
is called the shell form. We also have
another form called execute form, which takes an array of strings. So,
npm and start.
-------------------code----------------------
CMD [ "npm", "start" ]
-------------------code----------------------

- What is the difference? Well,
if we use this syntax, docker will execute this command
inside a separate shell. That is why it's called
the shell form. Now, on Linux, that shell is
slash bin slash shell, the original shell program. On Windows,
it's cmd or command prompt.
Now, the common best practice is to use the execute form
because with this, we can execute this command directly
and there's no need to spin up another shell process.
Also, this makes it easier and faster to clean up resources when we stop containers.
So, always use the execute form.
-------------------code----------------------
# Shell form
# /bin/sh -> Linux
# cmd -> Windows
CMD npm start

# Exec form
CMD [ "npm", "start" ]
-------------------code----------------------

-  here's our command instruction. Now,
we also have another instruction called entry point,
which is very similar to command.
So, it has two forms, the shell form or the execute form.
So, it takes an array of strings. Now,
-------------------code----------------------
# Shell form
ENTRYPOINT npm start

# Exec form
ENTRYPOINT [ "npm", "start" ]
-------------------code----------------------

- what is the difference? Well,
we can always overwrite the default command when starting a container with CMD.
So, back to the terminal, when we run this container,
we can supply another command. So, we can say echo hello and this will overwrite
this command over here.
So, for the same reason, here we can run
a shell session and of course, we want to use the interactive mode.
-------------------code----------------------
$ docker run react-app echo hello
-------------------code----------------------

- Now, in contrast, we cannot easily overwrite the entry point
when running a container. If we want to do that,
we have to use the entry point option.
Now, a lot of people forget to use this. That's why it's a little bit harder
to overwrite the entry point.
-------------------code----------------------
$ docker run react-app --entrypoint
-------------------code----------------------

- So, in practical terms,
we often want to use entry point
when we know for sure that this is the command
or this is the program that should be executed whenever we start a container.
There is no exception.


- In contrast, with the command instruction "CMD", we have
a bit more flexibility. we can always overwrite it. So,
we want to use this instruction for executing ad hoc commands in a container.
Now, which instruction we use is a matter of personal preference.
With both these instructions, we can supply a default command. Some people prefer
the command instruction, other people prefer the entry point. we personally prefer
the former.

- our docker file is in good shape, but if we have noticed,
our builds are slow. We'll talk about
optimizing them next.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
RUN addgroup app && adduser -S -G app app
USER app
WORKDIR /app
COPY . . 
RUN npm install
ENV API_URL=http://api.myapp.com/
EXPOSE 3000
CMD [ "npm", "start" ]
-------------------code----------------------

*** 13- Speeding Up Builds ***

- we've probably noticed that our builds are fairly slow. Every time we make a
small change, we have to rebuild and wait almost half a minute. So let's see how we
can optimize these builds.

- The first thing we need to understand here is the concept
of layers in docker. An image is essentially a collection of layers.
You can think of a layer as a small file system that only includes
modified files. So when docker tries to build an image for us,
it executes each of these instructions and creates a new layer.
That layer only includes the files that were modified as a result of that
instruction.
-------------------code---------------------- 
FROM node:14.16.0-alpine3.13
RUN addgroup app && adduser -S -G app app
USER app
WORKDIR /app
COPY . .
RUN npm install
ENV API_URL=http://api.myapp.com/
EXPOSE 3000
CMD [ "npm", "start" ]
-------------------code----------------------

- So for our first instruction, docker is going to take the node image
and put it in a layer. Now more accurately, the node image itself
is several layers. But let's not worry about that for now. Let's just imagine
we have a single layer and this layer includes all the linux and node files.

- Then docker is going to execute the second instruction to add a group
and a user. Once again, it's going to create a new layer because
as we saw in the previous section, when we add a user or a group, something is
written to the file system. So a couple of files are modified. So this layer
will only include the modified files.

- Similarly, docker will execute all these other instructions and create several layers.
Let's have a quick look at these layers. So here in the terminal we type
docker history and the name of our image, react app.
-------------------code----------------------
$ docker history react-app
IMAGE          CREATED             CREATED BY                                       SIZE      COMMENT
8b2a2f4a760e   About an hour ago   EXPOSE map[3000/tcp:{}]                          0B        buildkit.dockerfile.v0
<missing>      About an hour ago   ENV API_URL=http://api.myapp.com/                0B        buildkit.dockerfile.v0
<missing>      About an hour ago   RUN /bin/sh -c npm install # buildkit            365MB     buildkit.dockerfile.v0
<missing>      About an hour ago   COPY . . # buildkit                              1.34MB    buildkit.dockerfile.v0
<missing>      About an hour ago   WORKDIR /app                                     0B        buildkit.dockerfile.v0
<missing>      About an hour ago   USER app                                         0B        buildkit.dockerfile.v0
<missing>      About an hour ago   RUN /bin/sh -c addgroup app && adduser -S -G…   4.84kB    buildkit.dockerfile.v0
<missing>      3 years ago         /bin/sh -c #(nop)  CMD ["node"]                  0B
<missing>      3 years ago         /bin/sh -c #(nop)  ENTRYPOINT ["docker-entry…   0B
<missing>      3 years ago         /bin/sh -c #(nop) COPY file:238737301d473041…   116B
<missing>      3 years ago         /bin/sh -c apk add --no-cache --virtual .bui…   7.91MB
<missing>      3 years ago         /bin/sh -c #(nop)  ENV YARN_VERSION=1.22.5       0B
<missing>      3 years ago         /bin/sh -c addgroup -g 1000 node     && addu…   102MB
<missing>      3 years ago         /bin/sh -c #(nop)  ENV NODE_VERSION=14.16.0      0B
<missing>      3 years ago         /bin/sh -c #(nop)  CMD ["/bin/sh"]               0B
<missing>      3 years ago         /bin/sh -c #(nop) ADD file:3b16ffee2b26d8af5…   5.35MB
-------------------code----------------------

- we're only going to look at these two columns created by and size. In this column we can see
the instruction that created a new layer and in the size column we can
see the size of that layer. Now we have to read this list from bottom to top. So
look over here. First we have this group of layers that come
from node and Linux. So earlier we told we that when we use the from instruction
that instruction is going to bring in several layers that belong to Linux
and node and then we're going to build on top of those layers.


- Now look at our run instruction for adding a new user.
That's the command that we typed earlier,
Now look at the size of this layer. It's 4 kilobytes because only a couple of files are
modified as a result of this command.
-------------------code----------------------
<missing>      About an hour ago   RUN /bin/sh -c addgroup app && adduser -S -G…   4.84kB    buildkit.dockerfile.v0
-------------------code----------------------

- Now look at how this instruction is executed.
It's executed inside slash bin slash shell because we use this instruction
in the shell form. In contrast
if we use the execute form this command would be executed
directly. 

- Next we set the current user. The size of this layer is 0. No files
are changed. Then we set the working directory
then we copy all the application files and
over here we can see the size of this layer is 1.6 megabytes.
Then we run npm install and once all these dependencies are installed
they are stored in this layer and the size of this layer is
365MB megabytes. So an image is
essentially a collection of these layers.
So we understand what layers are.
-------------------code----------------------
<missing>      About an hour ago   RUN /bin/sh -c npm install # buildkit            365MB     buildkit.dockerfile.v0
-------------------code----------------------

- Now Docker has an optimization mechanism built into it.
So next time we ask Docker to build this image it's going to look at the first instruction
and see if the instruction is changed or not. If it's not changed
it's not going to rebuild this layer. It's going to reuse it from its cache.
That's the optimization we was talking about.
Then Docker is going to look at the second instruction.
Once again, nothing is changed here so Docker is going to reuse
this layer from its cache. In contrast if we made a tiny change here
let's say if we changed app to app 2 then Docker had to rebuild this layer.
-------------------code----------------------
RUN addgroup app2 && adduser -S -G app2 app2
-------------------code----------------------

- Now, look at this line. Copy all these files.
This is a special instruction because with this instruction Docker cannot tell
if anything has changed or not. So it has to look at the content of files as well.
And that means if we make a tiny change in our application
if we write one extra line of code Docker cannot reuse this layer from its cache
it has to rebuild it.

- And this is where the problem happens.
Once the layer is rebuilt all the following layers have to be rebuilt as well.
So Docker cannot reuse this layer from its cache.
It has to install all NPM dependencies. And this is exactly where
we have a bottleneck. We have to wait half a minute
for all these dependencies to be installed. It doesn't make sense.

- So to optimize our build we have to separate the installation
of third party dependencies from copying our application files.
How do we do that?
Very easy. Instead of copying all the files in one go
first we want to copy the files needed for installing third party dependencies.
other words in our case the package files files.
-------------------code----------------------
Package-lock.json
and package.json
-------------------code----------------------


- These are the only files that we need for running NPM install.
Okay? So we're going to copy package *.json then we run NPM install
and finally we copy all the application files.
Now with this new setup if we haven't changed any of our application dependencies
Docker is going to reuse this layer from its cache. Because package.json
is not modified.
-------------------code----------------------
COPY package*.json .
RUN npm install
COPY . .
-------------------code----------------------

- Similarly, Docker is not going to reinstall
all NPM dependencies because this instruction is not changed.
If it changes to NPM update then yes Docker had to rebuild this layer.
-------------------code----------------------
RUN npm update
-------------------code----------------------

- when using install nothing has changed here so Docker can reuse its cache.
Then we're copying our application files and of course this layer should always be rebuilt.
And that's totally fine. and now this is our docker file.
-------------------code----------------------
FROM node:14.16.0-alpine3.13
RUN addgroup app && adduser -S -G app app
USER app
WORKDIR /app
COPY package*.json .
RUN npm install
COPY . .
ENV API_URL=http://api.myapp.com/
EXPOSE 3000
CMD [ "npm", "start" ]
-------------------code----------------------

- So let's run a quick test. Back to the terminal
let's rebuild this image. Alright, now look over here.
On this line we can see cached because Docker is reusing
the layer cache for this instruction. The same is true
for setting the working directory. Now this is the first time
we're building this Docker file that's why this is a new layer that we have
this layer has to be built and of course dependencies have to be installed as well.
-------------------code----------------------
app +[master] $ docker build -t react-app .
[+] Building 34.0s (11/11) FINISHED                                                                                                docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 283B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         3.7s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 1.34MB                                                                                                                0.0s
 => CACHED [2/6] RUN addgroup app && adduser -S -G app app                                                                                         0.0s
 => CACHED [3/6] WORKDIR /app                                                                                                                      0.0s
 => [4/6] COPY package*.json .                                                                                                                     0.0s
 => [5/6] RUN npm install                                                                                                                         28.1s
 => [6/6] COPY . .                                                                                                                                 0.0s
 => exporting to image                                                                                                                             2.1s
 => => exporting layers                                                                                                                            2.1s
 => => writing image sha256:e24dbe1387e137459a2c8633d898c003f9649d3a3d903c2c52a6ebc03ec2b938                                                       0.0s
 => => naming to docker.io/library/react-app                                                                                                       0.0s
-------------------code----------------------

- So let's wait until this is done. after the image is built.
Now let's go modify our application code and do another build.
So we're going to go to this file readme.md and add a plus here.
Very simple.
-------------------code----------------------
# Getting Started with Create React App+
-------------------code----------------------

- Now, let's do another build. Alright, our build was super fast
because we didn't have to wait for the installation of
third party dependencies.
Look at this line. Once again we are using layer caching.
-------------------code----------------------
app +[master] $ docker build -t react-app .
[+] Building 0.9s (11/11) FINISHED                                                                                                 docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 283B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         0.8s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 5.02kB                                                                                                                0.0s
 => CACHED [2/6] RUN addgroup app && adduser -S -G app app                                                                                         0.0s
 => CACHED [3/6] WORKDIR /app                                                                                                                      0.0s
 => CACHED [4/6] COPY package*.json .                                                                                                              0.0s
 => CACHED [5/6] RUN npm install                                                                                                                   0.0s
 => [6/6] COPY . .                                                                                                                                 0.0s
 => exporting to image                                                                                                                             0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:27fa9bf420d8a22f104ff636a87b49967cff753c3971f2b4f934abc4602e5334                                                       0.0s
 => => naming to docker.io/library/react-app                                                                                                       0.0s
-------------------code----------------------

- So here's what we need to take away from this lesson.
To optimize our build we should organize our Docker file
such that the instructions that don't change frequently
should be on the top and the instructions or files that change frequently
should be down to bottom.
-------------------code----------------------
  Stable instructions
         |
         |
         |
         |
         |
  changing instructions
-------------------code----------------------

*** 14- Removing Images ***

- Let's talk about removing images.
So first we run docker images. Now in this list we have a bunch of images
that have no name and no tag. These are what we call dangling images,
meaning loose images. These are essentially layers that have no relationship
with a tagged image. So as we were changing our docker file and rebuilding
our image, docker was creating these layers and at some point these layers
lost the relationship with our react app image. So as we work with docker,
we see these dangling images popping up all the time.
-------------------code----------------------
$ docker images
REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
react-app      latest    27fa9bf420d8   38 minutes ago   482MB
<none>         <none>    e24dbe1387e1   40 minutes ago   482MB
<none>         <none>    8b2a2f4a760e   2 hours ago      481MB
<none>         <none>    7072f2f889bc   2 hours ago      481MB
<none>         <none>    e7798d53f6dc   46 hours ago     481MB
<none>         <none>    4813ee97e523   46 hours ago     481MB
<none>         <none>    8816b1815607   46 hours ago     116MB
hello-docker   latest    817ba4c523a5   3 days ago       160MB
<none>         <none>    8af7922e7fd1   3 days ago       160MB
alpine         latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu         latest    c3d1a3432580   7 weeks ago      101MB
<none>         <none>    322425dfa4aa   3 years ago      116MB
-------------------code----------------------

- To get rid of them we have to use the prune command. So we type docker image
prune. It's asking for confirmation. Yes.
Alright. Nothing was deleted in this case because we still have containers
running an older react app image.
-------------------code----------------------
$ docker image prune
WARNING! This will remove all dangling images.
Are we sure we want to continue? [y/N] y
Deleted Images:
Total reclaimed space: 0B
-------------------code----------------------

- Let's verify it. So, we run docker ps. Currently we have no running containers.
But we probably have a bunch of containers in the stopped state.
-------------------code----------------------
$ docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
-------------------code----------------------

- So, we run docker ps dash a, that is short for all. So look, we have tons of containers
that are currently stopped. 
-------------------code----------------------
$ docker ps -a
CONTAINER ID   IMAGE          COMMAND                   CREATED        STATUS                      PORTS     NAMES
049537cb6ce1   8b2a2f4a760e   "docker-entrypoint.s…"   2 hours ago    Exited (0) 50 minutes ago             adoring_villani
99abff021260   7072f2f889bc   "docker-entrypoint.s…"   2 hours ago    Exited (0) 2 hours ago                reverent_benz
9b35adaaeddd   7072f2f889bc   "docker-entrypoint.s…"   2 hours ago    Exited (0) 2 hours ago                zealous_driscoll
f74413e58fb8   7072f2f889bc   "docker-entrypoint.s…"   2 hours ago    Exited (130) 2 hours ago              flamboyant_pascal
e91757161e5e   alpine         "/bin/sh"                 3 hours ago    Exited (130) 2 hours ago              sleepy_chebyshev
7d682d60854e   e7798d53f6dc   "docker-entrypoint.s…"   46 hours ago   Exited (255) 3 hours ago              vibrant_saha
1a1dd3327d20   4813ee97e523   "docker-entrypoint.s…"   46 hours ago   Exited (130) 46 hours ago             thirsty_shaw
cc5b5a086f5d   8816b1815607   "docker-entrypoint.s…"   46 hours ago   Exited (130) 46 hours ago             strange_hermann
35f1dcc85d59   8816b1815607   "docker-entrypoint.s…"   46 hours ago   Exited (130) 46 hours ago             relaxed_albattani
773c8e44c24f   322425dfa4aa   "docker-entrypoint.s…"   47 hours ago   Exited (0) 46 hours ago               modest_brown
934145a0b3b5   322425dfa4aa   "docker-entrypoint.s…"   47 hours ago   Exited (1) 47 hours ago               laughing_faraday
c30f57516ae3   322425dfa4aa   "docker-entrypoint.s…"   47 hours ago   Exited (0) 47 hours ago               nostalgic_chebyshev
c315081d7859   ubuntu         "/bin/bash"               47 hours ago   Exited (0) 47 hours ago               charming_mccarthy
17e332c0bbd7   ubuntu         "/bin/bash"               47 hours ago   Exited (0) 46 hours ago               blissful_albattani
8a65a7f2dd58   ubuntu         "/bin/bash"               2 days ago     Exited (130) 47 hours ago             eloquent_lichterman
ee871cc6ca5f   ubuntu         "/bin/bash"               3 days ago     Exited (129) 2 days ago               naughty_mclean
cc3ce42ddbf2   ubuntu         "/bin/bash"               3 days ago     Exited (0) 3 days ago                 fervent_golick
8ee68b73826f   hello-docker   "docker-entrypoint.s…"   3 days ago     Exited (0) 3 days ago                 busy_brown
-------------------code----------------------

- So we can get rid of these containers as well.
using docker container prune. So it's asking if we want to remove all
stopped containers.So all these
stopped containers are deleted and this freed up on this machine 150 megabytes of space.
-------------------code----------------------
$ docker container prune
WARNING! This will remove all stopped containers.
Are we sure we want to continue? [y/N] y
Deleted Containers:
049537cb6ce1c73b3b979372479459a2c0263055968f87a8d0070fd572aa8a9c
99abff0212602685f06783b15e732ef0f72dda5cb74c28d6c3995a1ea9d96161
9b35adaaeddda3a325485ee4c8556d139bd262168a53ec67a21ee1e4f6b11695
f74413e58fb8c794ddd45171a7d727368e27ba2ab78f73e6b82738dfe3261741
e91757161e5e7665ff45864eeebd667a6426443834b2bcf5c03fd808af475942
7d682d60854e6fe2b68242a96f85a630526ed900d2dfa511e2a9902b80bc6439
1a1dd3327d207dea3db1c8fce88f61253a244a9ac49a72225a3014fb6becedd8
cc5b5a086f5d719ada06f8175334a3b9a1e33d119cc3db23b450fe2c0e0e6916
35f1dcc85d5904b50f64fcb37906c5c189d8d9cb069578c3eb857445ddcd900b
773c8e44c24f3efa4a6ebf2932d68b8d754596a8c87dae2b44e747b7e907d3a3
934145a0b3b5d9e2d0c7cad3798248eae964039e952d26a8f9fcbb9e2732969d
c30f57516ae360ab32c363df6ec69eb30c551bd51717898294a79e0b484c134d
c315081d7859160ae749eba1b5170edd1d4f183061b1353874173d61747ae233
17e332c0bbd762f8c4be847c75c0e961c58791fa70d78476c7064764aeb740ed
8a65a7f2dd58c27e212586079cb02dc73c9203debdfcbcb3da50f387c183ecc0
ee871cc6ca5f1cc8e07a34d5bd23a1f942c20209f0c3e7ed23d24055d1d53e15
cc3ce42ddbf23626a38a6320d76e507d32fd5cf49e9e9a3ad351f0334b7216d1
8ee68b73826f38bb5b90a55b0e46fc30f898cb3012d286dbb8c797fd869be2a2

Total reclaimed space: 150.3MB
-------------------code----------------------

- Now, let's run docker image prune one more time. Yes.
Great. So all these dangling images are removed.
-------------------code----------------------
$ docker image prune
WARNING! This will remove all dangling images.
Are we sure we want to continue? [y/N] y
Deleted Images:
deleted: sha256:8816b1815607d3d204cd7f33a3fc141a29e6f96809a6a9a932af2bc578a20463
deleted: sha256:4813ee97e523048ca4718fad986644d6289f2d930591f77e4f05bf7b263d716d
deleted: sha256:322425dfa4aa806cd14b7952ee48efebb79d0b05fbed2c49649791c511fa16c4
deleted: sha256:7072f2f889bc06c712fdd966582f8c8c97b0727b02c26926021af2ecf05c3856
deleted: sha256:8b2a2f4a760ea543b4992e7728c54b4328d938e51983d50543fb4366e6464a67
deleted: sha256:e7798d53f6dc0966f9ec44b4ea2a20c1a1153d4cd89564219df8a646dfda1432

Total reclaimed space: 0B
-------------------code----------------------

- Now, if we run docker images, we only see
the proper images we have created or pulled from docker hop.
-------------------code----------------------
$ docker images
REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
react-app      latest    27fa9bf420d8   42 minutes ago   482MB
hello-docker   latest    817ba4c523a5   3 days ago       160MB
alpine         latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu         latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------

- Now, how do we remove one of those images?
We run docker image. So all image management operations
start with docker image. If we simply press enter here,
we can see all these subcommands.
-------------------code----------------------
$ docker image

Usage:  docker image COMMAND

Manage images

Commands:
  build       Build an image from a Dockerfile
  history     Show the history of an image
  import      Import the contents from a tarball to create a filesystem image
  inspect     Display detailed information on one or more images
  load        Load an image from a tar archive or STDIN
  ls          List images
  prune       Remove unused images
  pull        Download an image from a registry
  push        Upload an image to a registry
  rm          Remove one or more images
  save        Save one or more images to a tar archive (streamed to STDOUT by default)
  tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE

Run 'docker image COMMAND --help' for more information on a command.
-------------------code----------------------

- So we can build an image, this is equivalent
to running docker build. we can also see the history of an image,
we can load an image, we can prune images
and so on. 

- Now, in this list we also have remove, for removing
one or more images. So, let's bring up the list of images
one more time, because here we need the name or the id of an image.
-------------------code----------------------
$ docker images
REPOSITORY     TAG       IMAGE ID       CREATED          SIZE
react-app      latest    27fa9bf420d8   42 minutes ago   482MB
hello-docker   latest    817ba4c523a5   3 days ago       160MB
alpine         latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu         latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------

- So, we can run docker image remove, we can either reference an image by its name,
for example we can remove react app.
-------------------code----------------------
$ docker image rm react-app
-------------------code----------------------

-  or we can reference using its image id, df3.
-------------------code----------------------
$ docker image rm 27f
-------------------code----------------------

- And if we want to remove multiple images we type them all here, separated
by a space.
-------------------code----------------------
$ docker image rm 27f 817
-------------------code----------------------

- Now in this demo we want to delete hello docker image. 
-------------------code----------------------
$ docker image rm hello-docker
Untagged: hello-docker:latest
Deleted: sha256:817ba4c523a5f02b3f85d33324a901e432cf33219df45953bc906e87cedf41bd
-------------------code----------------------
-let's verify it's gone, docker images.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
react-app    latest    27fa9bf420d8   45 minutes ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------


*** 15- Tagging Images ***

- Alright, let's talk about tags.
If we have noticed, whenever we build an image or pull it from docker-hop
by default docker uses the latest tag. 

- Now this latest tag is just a label, there is nothing special about it. So it doesn't necessarily mean
this is the latest version of our image. If we don't tag our images
properly, latest can point to an older image.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
react-app    latest    27fa9bf420d8   2 hours ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago   8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago   101MB
-------------------code----------------------

- Also keep in mind that latest is totally fine for development, but
we shouldn't use it in production. You don't want to put an image with the latest tag in our
production or staging server, because if something goes wrong, we cannot
easily troubleshoot issues. Because we don't know what version we're really
running in production. If we want to do a rollback or an upgrade, how can
we tell what version we're running in production, if it's always latest.
So we should always use explicit tags to identify what version we're
running in each environment, in our test environment, staging and production.

- For development, latest is totally fine. Now, in this lesson we're going to show we
how to tag our images properly, but before we get started, we want to do a
clean build, so we start on a clean docker build.
-------------------code----------------------
$ docker build -t react-app .
-------------------code----------------------

- let's look at our images. We have three images and all of them have the latest tag.
Now how can we tag an image? Well, there are two ways. One way is to
tag an image while building it.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
react-app    latest    27fa9bf420d8   2 hours ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago   8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago   101MB
-------------------code----------------------

-  So we type docker build dash t for tag, so far we have just typed the image name,
but we can type a colon followed by a tag.
-------------------code----------------------
$ docker build -t react-app:1 .
-------------------code----------------------

- Now what tag should we use? Well, this is where different teams have different preferences.
Some teams like code-names. Let's say we have a version called Buster, and
everyone in our team knows what Buster version is all about. Then we can
use it as a tag. Other teams prefer semantic versioning, like 3.1.5.
This approach is common amongst teams that don't release that often.
Now teams that release frequently prefer build numbers, let's say build 76 or
77. Now quite often this is done automatically by
continuous integration and deployment tool. So if we use a
continuous integration or deployment tool in our organization, we can configure
our tool to check out the latest code
from our repository, build an image and automatically tag it with
the current build number.


- So let's go ahead and give this image a tag like version 1 and build it.

- Alright, our build was
blazing fast. Let's look at the images one more time.
Alright, here we have an interesting situation.
This react app image that we have has two tags,
one and latest. So it's the same image with multiple tags.
How do we know? Look at the image ID. Both these images
have the same identifier.  So an image can have multiple tags.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
react-app    1         27fa9bf420d8   2 hours ago   482MB
react-app    latest    27fa9bf420d8   2 hours ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago   8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago   101MB
-------------------code----------------------

- Now what if we made a mistake and want to remove this tag? Well,
we use the remove command. So docker image remove
and here we type the image name followed by the tag.
-------------------code----------------------
$ docker image remove react-app:1
Untagged: react-app:1
-------------------code----------------------

- the tag is gone. So let's look at the images.
Perfect, we only have the latest tag. So one way to tag
an image is while building it.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
react-app    latest    27fa9bf420d8   2 hours ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago   8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago   101MB
-------------------code----------------------

- But what if we want to tag an image after?
We use the tag command. So docker images tag
first we identify our source image we can use the
full image name and its tag or we can use an image
ID. Whatever we prefer. So we're going to get this image and
apply a new tag to it. React app version 1.
-------------------code----------------------
$ docker image tag react-app:latest react-app:1
-------------------code----------------------

- Now let's verify that everything is in the right shape.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
react-app    1         27fa9bf420d8   2 hours ago   482MB
react-app    latest    27fa9bf420d8   2 hours ago   482MB
alpine       latest    8d591b0b7dea   4 weeks ago   8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago   101MB
-------------------code----------------------

-  Now earlier we told we that the latest tag can get out of order. 
Let's see that in action. So
we're going to go back to our project and make a tiny change.
In this readme file we're going to add a couple more pluses
simulating a change in the application's code.
-------------------code----------------------
# Getting Started with Create React App++++
-------------------code----------------------

- Now we're going to build a new image. So
let's say docker build dash t, react app.
Let's say this is version 2.
-------------------code----------------------
$ docker build -t react-app:2 .
[+] Building 1.7s (11/11) FINISHED                                                                                                 docker:desktop-linux
 => [internal] load build definition from Dockerfile                                                                                               0.0s
 => => transferring dockerfile: 283B                                                                                                               0.0s
 => [internal] load metadata for docker.io/library/node:14.16.0-alpine3.13                                                                         1.6s
 => [internal] load .dockerignore                                                                                                                  0.0s
 => => transferring context: 89B                                                                                                                   0.0s
 => [1/6] FROM docker.io/library/node:14.16.0-alpine3.13@sha256:2c51dc462a02f15621e7486774d36d048a27225d581374b002b8477a79a59b4b                   0.0s
 => [internal] load build context                                                                                                                  0.0s
 => => transferring context: 5.02kB                                                                                                                0.0s
 => CACHED [2/6] RUN addgroup app && adduser -S -G app app                                                                                         0.0s
 => CACHED [3/6] WORKDIR /app                                                                                                                      0.0s
 => CACHED [4/6] COPY package*.json .                                                                                                              0.0s
 => CACHED [5/6] RUN npm install                                                                                                                   0.0s
 => [6/6] COPY . .                                                                                                                                 0.0s
 => exporting to image                                                                                                                             0.0s
 => => exporting layers                                                                                                                            0.0s
 => => writing image sha256:0211703e719b294529c6ff5579540f917db0778d832ae1cc85925770778759d2                                                       0.0s
 => => naming to docker.io/library/react-app:2                                                                                                     0.0s
-------------------code----------------------

- Now let's look at the images. So we have two versions
of this image, version 2 and version 1. Now look at
the latest tag. It's pointing to the first version. Because both these
tags are pointing to the same image, which is older.
we built this image at the beginning of this lesson. 
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED          SIZE
react-app    2         0211703e719b   33 seconds ago   482MB
react-app    1         27fa9bf420d8   2 hours ago      482MB
react-app    latest    27fa9bf420d8   2 hours ago      482MB
alpine       latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------

- So here's what we need to take away. The latest tag
doesn't necessarily reference the latest image.
You have to explicitly apply it to the latest image. So how do we do that?
- We're going to identify new image name. 
-------------------code----------------------
docker image tag react-app:2 react-app:latest
-------------------code----------------------

- or we can use the image id.
-------------------code----------------------
docker image tag 021 react-app:latest
-------------------code----------------------


- now we verify it. we can see the IMAGE ID of the image of 
latest tag is equal to the IMAGE ID to the tag 2.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED              SIZE
react-app    2         0211703e719b   About a minute ago   482MB
react-app    latest    0211703e719b   About a minute ago   482MB
react-app    1         27fa9bf420d8   2 hours ago          482MB
alpine       latest    8d591b0b7dea   4 weeks ago          8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago          101MB
-------------------code----------------------

*** 16- Sharing Images ***

- Let's see how we can share our images with others. So head over to
hub.docker.com and create a new account. It's absolutely free and it's going to take
only a few seconds. Now let us log in with our account.

- So on our home page of docker account we can create a new repository.
And this is similar to creating a github repository. So we can have a repository, and in this repository
we can have multiple images with different tags. So let's create a new one.
We're going to give it a name. we're going to use the same name that we used for our image.
Now we can give it a description. We can make it public or private.
If we have a free account, we only get one private repository. But we can always upgrade
to get additional private repositories. Now optionally, we can connect our account
to our github account. So every time we do a push, docker hub automatically pulls the
latest code and builds a new image. Now we're not going to do that in this lesson
so let's go ahead and create.

- So here we have a repository and this is the name of our repository.
So our user name slash our image name.
Now to push our image to this repository, we have to give it this tag.
moody or whatever our user name is slash react app.

- So back to the terminal, let's look at our images.
-------------------code----------------------
$ docker images
REPOSITORY   TAG       IMAGE ID       CREATED              SIZE
react-app    2         0211703e719b   About a minute ago   482MB
react-app    latest    0211703e719b   About a minute ago   482MB
react-app    1         27fa9bf420d8   2 hours ago          482MB
alpine       latest    8d591b0b7dea   4 weeks ago          8.17MB
ubuntu       latest    c3d1a3432580   7 weeks ago          101MB
-------------------code----------------------

- Let's say we want to publish the latest version of this image. So
docker image tag we're going to tag this image we're going to use the image ID so
021 we're going to give it a new tag moody slash react app.
-------------------code----------------------
docker image tag 021 moody/react-app
-------------------code----------------------

- Now if we don't specify a tag docker will automatically use latest
we don't want to do that, we want to use an explicit tag.

- Now, let's look at our images one more time. So now, this image
with this ID has three tags. Here's the first tag, tag 2.
We also have the latest tag, but we also
have moody slash react app with tag 2.
All these tags are pointing to the same image on our machine.
-------------------code----------------------
$ docker images
REPOSITORY        TAG       IMAGE ID       CREATED          SIZE
react-app         2         0211703e719b   24 minutes ago   482MB
react-app         latest    0211703e719b   24 minutes ago   482MB
moody/react-app   2         0211703e719b   24 minutes ago   482MB
react-app         1         27fa9bf420d8   2 hours ago      482MB
alpine            latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu            latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------

- So now we're ready to push this image. First we have to
login. So docker login we use our credentials.
-------------------code----------------------
docker login
-------------------code----------------------

- Now we type docker push and here we specify our image.
So moody slash react app version 2.
Alright, now docker is pushing each of the layers
in our image. So the first time we push
this image, this is going to take a little while
because one of our layers, the layer that includes all npm dependencies
is fairly large. So once we push this image, our future pushes will
be faster. Assuming that we have not changed our application dependencies.
So our image is pushed.
-------------------code----------------------
$ docker push moody/react-app:2
The push refers to repository [docker.io/moody/react-app]
3ff22e1554cc: Pushed
240fdbca2c7f: Pushing
169. 9MB/177. 8MB
1d5961f2bb06: Pushed
4882914c8ed8: Pushed
216002df1993: Pushed
5e51c4be24db: Mounted from library/node
-------------------code----------------------

- Now, let's refresh this page. So in this
repository, we have one tag, that is tag 2 which is built for Linux.

- Now back to our project, let's make a
small change to this readme file and do another push.
-------------------code----------------------
# Getting Started with Create React App++++!
-------------------code----------------------

- Back to the terminal, first we need to build this image, so
build dash t, react app, let's say version 3.
That was super fast.
-------------------code----------------------
$ docker build -t react-app:3 .
-------------------code----------------------

-  Now, let's look at the images. This is our version 3.
-------------------code----------------------
$ docker images
REPOSITORY        TAG       IMAGE ID       CREATED          SIZE
react-app         3         ae37a5ac6ae3   3 seconds ago    482MB
react-app         2         0211703e719b   29 minutes ago   482MB
react-app         latest    0211703e719b   29 minutes ago   482MB
moody/react-app   2         0211703e719b   29 minutes ago   482MB
react-app         1         27fa9bf420d8   2 hours ago      482MB
alpine            latest    8d591b0b7dea   4 weeks ago      8.17MB
ubuntu            latest    c3d1a3432580   7 weeks ago      101MB
-------------------code----------------------

- Now we want to give this image an extra tag that starts with
moody, or our username. So, docker image tag, we're going to tag react app version 3
with moody slash react app version 3.
-------------------code----------------------
$ docker image tag ae3 moody/react-app:3
-------------------code----------------------

- So, let's say docker push, moody
react app version 3. Alright,
now look, some of these layers
already exist, so this push is a lot faster than
the previous push.
-------------------code----------------------
$ docker push moody/react-app:3
The push refers to repository [docker.io/moody/react-app]
3ff22e1554cc: Pushed
240fdbca2c7f: Pushing
169. 9MB/177. 8MB
1d5961f2bb06: Pushed
4882914c8ed8: Pushed
216002df1993: Pushed
5e51c4be24db: Mounted from library/node
-------------------code----------------------

- Now back on docker hub, let's
refresh. Now in this repository we have
two tags, beautiful. Alright, now that our image is on docker hub,
we can pull it on any machine that runs docker.
Just like pulling any other images from docker hub.
